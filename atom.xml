<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2021-03-15T00:42:56.653Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[悲观锁和乐观锁]]></title>
        <id>http://weakcc.github.io/post/bei-guan-suo-he-le-guan-suo/</id>
        <link href="http://weakcc.github.io/post/bei-guan-suo-he-le-guan-suo/">
        </link>
        <updated>2021-03-15T00:18:20.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="悲观锁">悲观锁</h1>
<p>在关系数据库管理系统里，悲观并发控制（又名<code>悲观锁</code>，Pessimistic Concurrency Control，缩写<code>PCC</code>）是一种并发控制的方法。</p>
<p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<b>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</b>）。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="悲观锁">悲观锁</h1>
<p>在关系数据库管理系统里，悲观并发控制（又名<code>悲观锁</code>，Pessimistic Concurrency Control，缩写<code>PCC</code>）是一种并发控制的方法。</p>
<p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<b>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</b>）。</p>
<!-- more -->
<pre><code class="language-mysql">//0.开始事务            
begin;/begin work;/start transaction; (三者选一就可以)              
//1.查询出商品信息               
select status from t_goods where id=1 for update;              
//2.根据商品信息生成订单                
insert into t_orders (id,goods_id) values (null,1);              
//3.修改商品 status 为2               
update t_goods set status=2;              
//4.提交事务             
commit;
</code></pre>
<p>悲观并发控制实际上是<code>先取锁再访问</code>的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。<br>
需要注意的是， <code>FOR UPDATE</code> 生效需要同时满足两个条件时才生效：</p>
<ul>
    <li>数据库的引擎为 innoDB</li>
    <li>操作位于事务块中（BEGIN/COMMIT）</li>
</ul>
<h1 id="乐观锁">乐观锁</h1>
<p>在关系数据库管理系统里，乐观并发控制（又名<code>乐观锁</code>，Optimistic Concurrency Control，缩写<code>OCC</code>）是一种并发控制的方法。</p>
<p>乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制<code>version</code>和 CAS（Compare And Swap 比较与交换）算法实现（<b>乐观锁适用于多读的应用类型，这样可以提高吞吐量</b>）。</p>
<p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<pre><code class="language-mysql">1.查询出商品信息
select (status,status,version) from t_goods where id=#{id}
2.根据商品信息生成订单
3.修改商品 status 为2
update t_goods set status=2,version=version+1 where id=#{id} and version=#{version};
</code></pre>
<p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。<br>
需要注意的是，如果运用的不是版本号而是商品库存等其他字段可能会出现<code>ABA</code>问题：</p>
<p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <code>ABA</code> 问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP 在操作断点续传时文件如何分割合并]]></title>
        <id>http://weakcc.github.io/post/php-zai-cao-zuo-duan-dian-xu-chuan-shi-wen-jian-ru-he-fen-ge-he-bing/</id>
        <link href="http://weakcc.github.io/post/php-zai-cao-zuo-duan-dian-xu-chuan-shi-wen-jian-ru-he-fen-ge-he-bing/">
        </link>
        <updated>2021-03-02T02:17:45.000Z</updated>
        <summary type="html"><![CDATA[<p>php 实现断点续传，就需要把大文件分割成多个小文件，然后单个上传。传完后在合并。</p>
]]></summary>
        <content type="html"><![CDATA[<p>php 实现断点续传，就需要把大文件分割成多个小文件，然后单个上传。传完后在合并。</p>
<!-- more -->
<pre><code class="language-php">&lt;?php

/**
 * 分隔文件
 */
function file_split($filePath, $tmpDir = &quot;tmp&quot;, $fileSize = 1024)
{
    $fp = fopen($filePath, 'rb');
    $i = 0;
    $no = 1;
    while (!feof($fp)) {
        $file = fread($fp, $fileSize);
        $fileName = pathinfo($filePath, PATHINFO_FILENAME);
        $tmpFp = fopen('./' . $tmpDir . '/' . $fileName . sprintf('%04d', $no) . '.' . $i . '-' . ($i + $fileSize) . '.tmp', 'wb');
        fwrite($tmpFp, $file, $fileSize);
        fclose($tmpFp);
        $i += $fileSize + 1;
        $no++;
    }
    fclose($fp);
}

/**
 * 合并文件
 */
function file_merge($tmpDir, $mergeFileName = 'merge.zip', $fileSize = 1024)
{
    $tmpFilePaths = glob($tmpDir . '/*.tmp');
    @unlink($mergeFileName);
    $fp = fopen($mergeFileName, 'w+');
    foreach ($tmpFilePaths as $v) {
        $tmpFp = fopen($v, 'rb');
        $content = fread($tmpFp, $fileSize);
        fwrite($fp, $content, $fileSize);
        unset($content);
        unlink($v);
        fclose($tmpFp);
    }
    fclose($fp);
}

$dir = 'tmp';
// 切割文件
file_split('./1.zip', $dir);
// 合并文件
file_merge($dir);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二维数组根据某个字段排序]]></title>
        <id>http://weakcc.github.io/post/er-wei-shu-zu-gen-ju-mou-ge-zi-duan-pai-xu/</id>
        <link href="http://weakcc.github.io/post/er-wei-shu-zu-gen-ju-mou-ge-zi-duan-pai-xu/">
        </link>
        <updated>2021-01-29T07:13:28.000Z</updated>
        <summary type="html"><![CDATA[<pre><code class="language-php">array_multisort(array_column($array, 'key'), SORT_DESC, $array);
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code class="language-php">array_multisort(array_column($array, 'key'), SORT_DESC, $array);
</code></pre>
<!-- more -->
<pre><code class="language-php">&lt;?php

$arr = [
    [
        'a' =&gt; '1',
        'b' =&gt; '你'
    ],
    [
        'a' =&gt; '3',
        'b' =&gt; '我'
    ],
    [
        'a' =&gt; '2',
        'b' =&gt; '他'
    ],
];

array_multisort(array_column($arr, 'a'), SORT_ASC, $arr);

print_r($arr);

//Array
//(
//    [0] =&gt; Array
//    (
//            [a] =&gt; 1
//            [b] =&gt; 你
//        )
//
//    [1] =&gt; Array
//(
//            [a] =&gt; 2
//            [b] =&gt; 他
//        )
//
//    [2] =&gt; Array
//(
//            [a] =&gt; 3
//            [b] =&gt; 我
//        )
//
//)
</code></pre>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go sql 知识总结]]></title>
        <id>http://weakcc.github.io/post/sql-zhi-shi-zong-jie/</id>
        <link href="http://weakcc.github.io/post/sql-zhi-shi-zong-jie/">
        </link>
        <updated>2021-01-21T02:39:29.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="1-sql-驱动">1. sql 驱动</h1>
<p>推荐驱动：<br>
* MySQL/MariaDB  —— <a href="https://github.com/go-sql-driver/mysql/">github.com/go-sql-driver/mysql/</a><br>
* Postgres SQL  —— <a href="https://github.com/lib/pq">github.com/lib/pq</a><br>
* SQLite3  —— <a href="https://github.com/mattn/go-sqlite3">github.com/go-sql-driver/mysql/</a><br>
* Oracle  —— <a href="https://github.com/mattn/go-oci8">github.com/go-sql-driver/mysql/</a><br>
* SQL Serve  —— <a href="https://github.com/denisenkom/go-mssqldb">github.com/go-sql-driver/mysql/</a></p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="1-sql-驱动">1. sql 驱动</h1>
<p>推荐驱动：<br>
* MySQL/MariaDB  —— <a href="https://github.com/go-sql-driver/mysql/">github.com/go-sql-driver/mysql/</a><br>
* Postgres SQL  —— <a href="https://github.com/lib/pq">github.com/lib/pq</a><br>
* SQLite3  —— <a href="https://github.com/mattn/go-sqlite3">github.com/go-sql-driver/mysql/</a><br>
* Oracle  —— <a href="https://github.com/mattn/go-oci8">github.com/go-sql-driver/mysql/</a><br>
* SQL Serve  —— <a href="https://github.com/denisenkom/go-mssqldb">github.com/go-sql-driver/mysql/</a></p>
<!-- more -->
<h1 id="2-sqldb">2. sql.DB</h1>
<p><code>sql.DB</code> 结构是 <code>database/sql</code> 包封装的一个数据库操作对象，包含了操作数据库的基本方法。大部分时间我们操作数据库都使用它。<br>
可以把 <code>sql.DB</code> 当做是连接池，它内部会自动维护 SQL 连接的关闭和创建。</p>
<h1 id="3-连接池设置">3. 连接池设置</h1>
<pre><code class="language-go">// 设置最大连接数
db.SetMaxOpenConns(100)

// 设置最大空闲连接数
db.SetMaxIdleConns(25)

// 设置每个链接的过期时间
db.SetConnMaxLifetime(5 * time.Minute)
</code></pre>
<h1 id="4-dsn">4. DSN</h1>
<p><code>DSN</code> 全称为 <code>Data Source Name</code>，表示数据库连接源，用于定义数据库的连接信息，不同数据库的 DSN 格式不同，MySQL 的 DSN 格式如下：</p>
<pre><code class="language-go">// [用户名[:密码]@][协议(数据库服务器地址)]]/数据库名称?参数列表
[username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]
</code></pre>
<p>为了更加直观，我们可以使用 mysql.Config 来创建连接信息：</p>
<pre><code class="language-go">// 设置数据库连接信息
config := mysql.Config{
    User:                 &quot;homestead&quot;,
    Passwd:               &quot;secret&quot;,
    Addr:                 &quot;127.0.0.1:33060&quot;,
    Net:                  &quot;tcp&quot;,
    DBName:               &quot;goblog&quot;,
    AllowNativePasswords: true,
}

fmt.Println(&quot;conn: &quot;, config.FormatDSN())
</code></pre>
<h1 id="5-初始化-sqldb">5. 初始化 sql.DB</h1>
<p>一般而言，我们使用 <code>Open()</code> 方法便可初始化并返回一个 <code>*sql.DB</code> 实例，如下：</p>
<pre><code class="language-go">func Open(driverName, dataSourceName string) (*DB, error)
</code></pre>
<p>使用 <code>Open()</code> 方法只要传入驱动名称及对应的 DSN 便可，使用很简单，也很通用，当需要连接不同数据库时，只需要修改驱动名与 DSN 即可。配合 mysql.Config 使用：</p>
<pre><code class="language-go">db, err = sql.Open(&quot;mysql&quot;, config.FormatDSN())
</code></pre>
<p>使用 <code>Open()</code> 时需要知道的是 —— 我们只是做好连接的准备，并未真是连接到数据库上。因未发生连接，所以即使配置信息有误，也不会报错。所以一般我们在使用的时候，会搭配 <code>Ping()</code> 进行测试：</p>
<pre><code class="language-go">err = db.Ping()
if err != nil {
    log.Fatal(err)
}
</code></pre>
<p><code>Ping()</code> 会与数据库服务器发生连接，如果连接信息有错误，err 就会有值，否为 nil。<br>
DB 的连线都是被设计来当作长连线使用的，所以不该频繁的 Open、Close。Open 取得的 db 实例，要重复利用，不应该去重复生成。</p>
<h1 id="5-prepare-和-stmt">5. Prepare 和 Stmt</h1>
<p><code>sql.DB.Prepare()</code> 方法会返回一个 <code>sql.Stmt</code> 对象，与 Stmt 相关的方法如下：</p>
<pre><code class="language-go">stmt.Exec()
stmt.Query()
stmt.QueryRow()
stmt.Close()
</code></pre>
<p>做单独的语句查询时，谨记调用 <code>defer stmt.Close()</code> 来关闭 SQL 连接。<br>
使用 Prepare 语句会发送两次请求到数据库服务器上，第一次是调用 Prepare() 语句时，第二次是调用以上提到的四个 Stmt 方法时：<br>
<img src="http://weakcc.github.io/post-images/1611198623133.png" alt="" loading="lazy"><br>
使用 Prepare 语句会发送两次请求到数据库服务器上，第一次是调用 Prepare() 语句时，第二次是调用以上提到的四个 Stmt 方法时：</p>
<pre><code class="language-go">func (db *DB) Exec(query string, args ...interface{}) (Result, error)
func (db *DB) Query(query string, args ...interface{}) (*Rows, error)
func (db *DB) QueryRow(query string, args ...interface{}) *Row
</code></pre>
<h1 id="6-exec">6. Exec()</h1>
<p>一般增加、删除、更新，或者修改表结构，都使用 <code>sql.DB</code> 中的 <code>Exec()</code> 方法来处理。<br>
语法如下：</p>
<pre><code class="language-go">func (db *DB) Exec(query string, args ...interface{}) (Result, error)
</code></pre>
<p>单参数为<b>纯文本模式</b>，不使用 Prepare，只发送一条 SQL 查询：</p>
<pre><code class="language-go">db.Exec(&quot;DELETE FROM articles WHERE id = &quot; + strconv.FormatInt(a.ID, 10))
</code></pre>
<p>多参数为 <b>Prepare 模式</b>，底层使用 Prepare 语句，会发送两条 SQL 查询：</p>
<pre><code class="language-go">query := &quot;UPDATE articles SET title = ?, body = ? WHERE id = ?&quot;
rs, err := db.Exec(query, title, body, id)
</code></pre>
<p>第二个及以上的参数为 SQL 占位符对应的数据。<br>
<code>Exec()</code> 方法会返回一个 <code>sql.Result</code> 类型的实例。</p>
<h1 id="7-sqlresult">7. sql.Result</h1>
<p>Result 的定义如下，包含两个方法：</p>
<pre><code class="language-go">type Result interface {
    LastInsertId() (int64, error)
    RowsAffected() (int64, error)
}
</code></pre>
<p><code>LastInsertId()</code> 方法只用在 <code>INSERT</code> 语句且数据表有自增 ID 时才有返回自增 ID 值，否则返回 0。<br>
<code>RowsAffected()</code> 表示影响的数据表行数，我们以此来判断 <code>SQL</code> 语句是否执行成功。<br>
SQL 语法正确的情况下 <code>RowsAffected()</code> 为 0 ，则表示 SQL 执行成功了，但是数据库里的数据没有任何变更。例如说我们的数据库中并没有 ID 为 6 的数据，这时候执行以下语句：</p>
<pre><code class="language-go">DELETE FROM articles WHERE id=6
</code></pre>
<p>就会出现 SQL 执行成功了，但是数据未更改的情况。</p>
<h1 id="8-query">8. Query()</h1>
<p>一般使用 <code>sql.DB</code> 中的 <code>Query()</code> 来查询得到多条数据。语法如下：</p>
<pre><code class="language-go">func (db *DB) Query(query string, args ...interface{}) (*Rows, error)
</code></pre>
<p>如下获取所有文章的例子：</p>
<pre><code class="language-go">rows, err := db.Query(&quot;SELECT * from articles&quot;)
</code></pre>
<p><code>Query()</code> 方法返回一个 <code>sql.Rows</code> 结构体，代表一个查询结果集。<br>
你可能发现了，Query 和 Exec 都可以执行 SQL 语句，<b>那他们的区别是什么呢？</b><br>
Exec 只会返回最后插入 ID 和影响行数，而 Query 会返回数据表里的内容（结果集）。<br>
或者可以这么记：</p>
<blockquote>
<p>Query 中文译为 <b>查询</b>，而 Exec 译为 <b>执行</b>。想查询数据，使用 Query。想执行命令，使用 Exec。</p>
</blockquote>
<h1 id="9-sqlrows">9. sql.Rows</h1>
<p><code>sql.Rows</code> 所包含的方法如下：</p>
<pre><code class="language-go">func (rs *Rows) Close() error                            //关闭结果集
func (rs *Rows) ColumnTypes() ([]*ColumnType, error)    //返回数据表的列类型
func (rs *Rows) Columns() ([]string, error)             //返回数据表列的名称
func (rs *Rows) Err() error                      // 错误集
func (rs *Rows) Next() bool                      // 游标，下一行
func (rs *Rows) Scan(dest ...interface{}) error  // 扫描结构体
func (rs *Rows) NextResultSet() bool            
</code></pre>
<p>结果集在检出完 err 以后，遍历数据之前，应调用 <code>defer rows.Close()</code> 来关闭 SQL 连接。<br>
一般我们会使用 <code>rows.Next()</code> 来遍历数据，如：</p>
<pre><code class="language-go">var articles []Article
//2. 循环读取结果
for rows.Next() {
    var article Article
    // 2.1 扫码每一行的结果并赋值到一个 article 对象中
    err := rows.Scan(&amp;article.ID, &amp;article.Title, &amp;article.Body)
    if err != nil {
        log.Fatal(err)
    }
    // 2.2 将 article 追加到 articles 的这个数组中
    articles = append(articles, article)
}
// 2.3 检测循环时是否发生错误
err = rows.Err()
if err != nil {
    log.Fatal(err)
}
</code></pre>
<p>循环完毕需检测是否发生错误。<br>
<code>rows.Scan()</code> 参数的顺序很重要，需要和查询的结果的 column 对应。</p>
<pre><code class="language-go">SELECT * from articles
</code></pre>
<p>而我们的 articles 的表结构为：</p>
<pre><code class="language-go">CREATE TABLE `articles` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `body` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
</code></pre>
<p>查询到的每一行的 column 顺序是 id, title, body，因此 rows.Scan 也需要按照此顺序不然会造成数据读取的错位。</p>
<h1 id="10-queryrow">10. QueryRow()</h1>
<p>如果是读取一行数据，可以使用 QueryRow()，语法定义如下：</p>
<pre><code class="language-go">func (db *DB) QueryRow(query string, args ...interface{}) *Row
</code></pre>
<p>返回的是一个 <code>sql.Row</code> 对象，与其相关的调用有：</p>
<pre><code class="language-go">func (r *Row) Scan(dest ...interface{}) error
</code></pre>
<p><code>sql.Row</code> 没有 <code>Close</code> 方法，当我们调用 <code>Scan()</code> 时就会自动关闭 SQL 连接。所以为了防止忘记关闭而浪费资源，一般需要养成连着调用 <code>Scan()</code> 习惯：</p>
<pre><code class="language-go">article := Article{}
query := &quot;SELECT * FROM articles WHERE id = ?&quot;
err := db.QueryRow(query, id).Scan(&amp;article.ID, &amp;article.Title, &amp;article.Body)
</code></pre>
<p>以上我们从数据库中读取对应 ID 的一条数据，并立刻调用 <code>Scan()</code> 读取数据到 article 变量里。<br>
当出现请求结果不止一条数据的情况，<code>QueryRow()</code> 会只使用第一条数据。</p>
<h1 id="11-context-上下文">11. Context 上下文</h1>
<p>三个常用的 SQL 请求方法都有其支持上下文的版本，如下：</p>
<pre><code class="language-go">func (db *DB) Exec(query string, args ...interface{}) (Result, error)
func (db *DB) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)
func (db *DB) Query(query string, args ...interface{}) (*Rows, error)
func (db *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)
func (db *DB) QueryRow(query string, args ...interface{}) *Row
func (db *DB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row
</code></pre>
<p>支持 Context 上下文的方法传参标准库 context 里的 context.Context 对象实例。<br>
在一些特殊场景里，我们需要 SQL 请求在执行还未完成时，我们可以取消他们（cancel），或者为请求设置最长执行时间（timeout），就会用到这些方法。<br>
在这里你只需要记住有这些方法即可，手动管理上下文 SQL  请求使用场景较少，篇幅考虑这里不做赘述。<br>
另外需要知道的是，所有的请求方法底层都是用其上下文版本的方法调用，且传入默认的上下文，例如 Exec() 的源码：</p>
<pre><code class="language-go">func (db *DB) Exec(query string, args ...interface{}) (Result, error) {
    return db.ExecContext(context.Background(), query, args...)
}
</code></pre>
<p>底层调用的是 <code>ExecContext()</code> 方法。<code>context.Background()</code> 是默认的上下文，这是一个空的 <code>context</code> ，我们无法对其进行取消、赋值、设置 deadline 等操作。</p>
<h1 id="12-事务处理-sqltx">12. 事务处理 sql.Tx</h1>
<p>在前面课程的 SQL 操作中，我们都没有开启事务，如果没有开启事务，当其中某个语句执行错误，则前面已经执行的 SQL 语句无法回滚。<br>
对于一些要求比较严格的业务逻辑来说，如付款、转账等，应该在同一个事务中提交多条 SQL 语句，避免发生执行出错无法回滚事务的情况。<br>
使用以下可以开启事务：</p>
<pre><code class="language-go">func (db *DB) Begin() (*Tx, error)
func (db *DB) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)
</code></pre>
<p><code>Begin()</code> 和 <code>BeginTxt()</code> 方法返回一个 sql.Tx 结构体，他支持以上我们提到过的几种查询方法：</p>
<pre><code class="language-go">func (tx *Tx) Exec(query string, args ...interface{}) (Result, error)
func (tx *Tx) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)
func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error)
func (tx *Tx) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)
func (tx *Tx) QueryRow(query string, args ...interface{}) *Row
func (tx *Tx) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row

// 预编译 Prepare
func (tx *Tx) Stmt(stmt *Stmt) *Stmt
func (tx *Tx) StmtContext(ctx context.Context, stmt *Stmt) *Stmt
func (tx *Tx) Prepare(query string) (*Stmt, error)
func (tx *Tx) PrepareContext(ctx context.Context, query string) (*Stmt, error)
</code></pre>
<p>使用这同一个 <code>sql.Tx</code> 对数据库进行操作，就会在同一个事务中提交。</p>
<p>当使用 <code>sql.Tx</code> 的操作方式操作数据后，需要使用 <code>sql.Tx</code> 的 <code>Commit()</code> 方法提交事务，如果出错，则可以使用 <code>sql.Tx</code> 中的 <code>Rollback()</code> 方法回滚事务，保持数据的一致性，下面是这两个方法的定义：</p>
<pre><code class="language-go">func (tx *Tx) Commit() error
func (tx *Tx) Rollback() error
</code></pre>
<p>下面是个简单的示例：</p>
<pre><code class="language-go">func (s Service) DoSomething() (err error) {
    // 1. 创建事务
    tx, err := s.db.Begin()
    if err != nil {
        return
    }
    // 2. 如果请求失败，就回滚所有 SQL 操作，否则提交
    //    defer 会在当前方法的最后执行
    defer func() {
        if err != nil {
            tx.Rollback()
            return err
        }
        err = tx.Commit()
    }()

    // 3. 执行各种请求
    if _, err = tx.Exec(...); err != nil {
        return err
    }
    if _, err = tx.Exec(...); err != nil {
        return err
    }
    // ...
    return nil
}
</code></pre>
<p>需要注意的是，所有 SQL 操作都必须使用 <code>tx</code> 来操作，才能支持事务，如果中间使用 <code>db.Exec()</code> 那这条语句是无法回滚的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[优雅地实现在 Python 退出时强制运行一段代码]]></title>
        <id>http://weakcc.github.io/post/you-ya-di-shi-xian-zai-python-tui-chu-shi-qiang-zhi-yun-xing-yi-duan-dai-ma/</id>
        <link href="http://weakcc.github.io/post/you-ya-di-shi-xian-zai-python-tui-chu-shi-qiang-zhi-yun-xing-yi-duan-dai-ma/">
        </link>
        <updated>2020-11-28T08:30:15.000Z</updated>
        <summary type="html"><![CDATA[<p>如果有这样一个场景，你要给一个项目开发测试程序，程序开始运行的时候，会创建初始环境，测试完成以后，会清理环境。<br>
使用 Python 自带的 <code>atexit</code> 这个模块</p>
<pre><code class="language-python">import atexit

@atexit.register
def clean():
    print(&quot;清理环境相关的代码&quot;)

def test():
    print(&quot;这里先执行&quot;)
    example = {'a': 1, 'b': 2}
    print(example['c'])  # 显然这里会报错

test()

# 这里先执行
# Traceback (most recent call last):
# 清理环境相关的代码
#   File &quot;/Users/dupeng/m7/Python/Web/demo.py&quot;, line 15, in &lt;module&gt;
#     test()
#   File &quot;/Users/dupeng/m7/Python/Web/demo.py&quot;, line 12, in test
#     print(example['c'])  # 显然这里会报错
# KeyError: 'c'
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>如果有这样一个场景，你要给一个项目开发测试程序，程序开始运行的时候，会创建初始环境，测试完成以后，会清理环境。<br>
使用 Python 自带的 <code>atexit</code> 这个模块</p>
<pre><code class="language-python">import atexit

@atexit.register
def clean():
    print(&quot;清理环境相关的代码&quot;)

def test():
    print(&quot;这里先执行&quot;)
    example = {'a': 1, 'b': 2}
    print(example['c'])  # 显然这里会报错

test()

# 这里先执行
# Traceback (most recent call last):
# 清理环境相关的代码
#   File &quot;/Users/dupeng/m7/Python/Web/demo.py&quot;, line 15, in &lt;module&gt;
#     test()
#   File &quot;/Users/dupeng/m7/Python/Web/demo.py&quot;, line 12, in test
#     print(example['c'])  # 显然这里会报错
# KeyError: 'c'
</code></pre>
<!-- more -->
<p><code>atexit</code> 使用中有下面几个注意事项：</p>
<ul>
<li>你可以注册多个退出函数，他们会按照注册时间从晚到早以此执行。例如
<pre><code class="language-python">import atexit

@atexit.register
def clean_1():
    ...

@atexit.register
def clean_2():
    ...
</code></pre>
<p>会先运行 <code>clean_2()</code> 后运行 <code>clean_1()</code></li></p>
<li>如果 `clean()` 函数有参数，那么你可以不用装饰器，而是直接调用 `atexit.register(clean_1, 参数1, 参数2, 参数3='xxx')`</li>
<li>如果程序是被你没有处理过的系统信号杀死的，那么注册的函数无法正常执行</li>
<li>如果发生了严重的Python内部错误，你注册的函数无法正常执行</li>
<li>如果你手动调用了 `os._exit()`，你注册的函数无法正常执行</li>
</ul>
<blockquote>
<p>https://mp.weixin.qq.com/s/Q65F49ZhFV02mqVPyxILHg</p>
</blockquote>
]]></content>
    </entry>
</feed>