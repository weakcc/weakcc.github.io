<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2021-06-18T07:17:19.229Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[Redis 实现消息队列]]></title>
        <id>http://weakcc.github.io/post/redis-shi-xian-xiao-xi-dui-lie/</id>
        <link href="http://weakcc.github.io/post/redis-shi-xian-xiao-xi-dui-lie/">
        </link>
        <updated>2021-06-18T03:44:12.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="消息队列是什么">消息队列是什么</h2>
<p><code>消息队列</code>：把要传输的数据放在队列中。消息是两个服务之间沟通的媒介，队列就是两个服务之间进行沟通消息的载体或容器。（把数据放到消息队列叫做<b>生产者</b>，从消息队列里面取数据叫做<b>消费者</b>）</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="消息队列是什么">消息队列是什么</h2>
<p><code>消息队列</code>：把要传输的数据放在队列中。消息是两个服务之间沟通的媒介，队列就是两个服务之间进行沟通消息的载体或容器。（把数据放到消息队列叫做<b>生产者</b>，从消息队列里面取数据叫做<b>消费者</b>）</p>
<!-- more -->
<h2 id="为什么要使用消息队列">为什么要使用消息队列</h2>
<p>常用于解决并发系统中资源的一致性问题（超卖），提升峰值的处理能力，同时保证消息的顺序性、可恢复性、必送达性。<br>
核心作用：<code>异步</code>，<code>解耦</code>，<code>削峰</code>。<br>
优点：</p>
<ul>
    <li>异步处理（短信通知，终端状态推送，APP推送，用户注册）</li>
    <li>数据同步（业务数据推送同步）</li>
    <li>重试补偿（记账失败重试）</li>
    <li>系统解耦（通讯上下行，终端异常监控，分布式事件中心，订单仓储物流）</li>
    <li>流量削峰（秒杀场景下的下单处理）</li>
    <li>发布订阅（服务状态的变化通知，分布式事件中心）</li>
    <li>高并发缓冲（日志服务，监控上报）</li>
</ul>
缺点：
<ul>
    <li>系统可用性降低，系统引入的外部依赖越多</li>
    <li>系统复杂度提高</li>
    <li>一致性问题</li>
</ul>
<h2 id="基于-list-的-lpush-rpop-实现的生产消费模式">基于 list 的 lpush + rpop 实现的生产/消费模式</h2>
<p>优点：</p>
<ul>
    <li>低延迟（消息几乎无延迟）</li>
</ul>
缺点：
<ul>
    <li>做消费者确认 ACK 麻烦，不能保证消费者消费信息后是否成功处理的问题（宕机或处理异常等），通常需要维护一个 Pending（等待）列表，保证消息处理确认</li>
    <li>不支持分组消费</li>
    <li>不能重复消费，一旦消费就会删除</li>
    <li>不能做广播模式，如 pub/sub，消息发布/订阅模型</li>
</ul>
<h2 id="基于-pubsub-的发布订阅模式">基于 pub/sub 的发布/订阅模式</h2>
<p>此模式允许生产者只生产一次消息，由中间件负责将消息复制到多个消息队列，每个消息队列由对应的消费者组成消费。<br>
<code>pub/sub</code> 模式不适合做消息存储，消息积压类的业务，而是擅长处理广播，即时通讯，即时反馈的业务。<br>
优点：</p>
<ul>
    <li>典型的广播模式，一个消息可以发布到多个消费者</li>
    <li>多信道订阅，消费者可以同时订阅多个信道，从而接收多类消息</li>
    <li>消息即时发送，消息不用等待消费者读取，消费者会自动接收到信道发布的消息</li>
</ul>
缺点：
<ul>
    <li>消息一旦发布，不能接收。换句话说就是发布时若客户端不在线，则消息丢失，不能寻回</li>
    <li>若消费者客户端出现消息积压，到一定程度，会被强制断开，导致消息意外丢失。通常发生在消息的生产远大于消费速度时</li>
</ul>
<p>基于 <code>list</code> 实现的生产 / 消费模式队列，在应用中使用场景最为广泛。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jupyter 基本使用]]></title>
        <id>http://weakcc.github.io/post/jupyter-ji-ben-shi-yong/</id>
        <link href="http://weakcc.github.io/post/jupyter-ji-ben-shi-yong/">
        </link>
        <updated>2021-05-14T08:58:12.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="服务启动与停止-cmd">服务启动与停止（ CMD ）</h3>
<pre><code>- 启动 jupyter notebook
- 停止 Control + C</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h3 id="服务启动与停止-cmd">服务启动与停止（ CMD ）</h3>
<pre><code>- 启动 jupyter notebook
- 停止 Control + C
</code></pre>
<!-- more -->
<h3 id="cell-两种模式">cell 两种模式</h3>
<pre><code>- code     : 编写代码 ( y 修改为 code 模式 )
- markdown : 编写笔记 ( m 修改为 markdown 模式 )
</code></pre>
<h3 id="模式切换">模式切换</h3>
<pre><code>- 当前 cell 侧边为蓝色时，表示此时为命令模式，按 Enter 切换为编辑模式
- 当前 cell 侧边为绿色时，表示此时为编辑模式，按 Esc 切换为命令模式
</code></pre>
<h3 id="快捷键">快捷键</h3>
<pre><code>- a 在上方新建 cell
- b 在下方新建 cell
- x 删除
- y 修改为 code 模式
- m 修改为 markdown 模式
- shift + enter 运行当前 cell 并跳转到下一个 cell
- command + enter 运行当前 cell 
- tab 自动补全
- shift + tab 打开帮助文档
- dd 删除当前 cell
- z 撤销删除</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 8.0 安装与配置]]></title>
        <id>http://weakcc.github.io/post/mysql-80-bi-zhi-bi-hui/</id>
        <link href="http://weakcc.github.io/post/mysql-80-bi-zhi-bi-hui/">
        </link>
        <updated>2021-05-14T01:17:17.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="安装与配置">安装与配置</h1>
<p>MySQL 8.0 下载地址</p>
<pre><code>https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="安装与配置">安装与配置</h1>
<p>MySQL 8.0 下载地址</p>
<pre><code>https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz
</code></pre>
<!-- more -->
<h2 id="下载">下载</h2>
<pre><code>wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz
</code></pre>
<h2 id="解压">解压</h2>
<pre><code># 将文件改为tar格式
xz -d mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz
# 解压tar文件
tar xf mysql-8.0.15-linux-glibc2.12-x86_64.tar
</code></pre>
<h2 id="移动">移动</h2>
<p>移动到 <code>/usr/local/mysql</code></p>
<pre><code>mv mysql-8.0.15-linux-glibc2.12-x86_64 /usr/local/mysql
</code></pre>
<p>安全保障新建一个账户 <code>mysql</code></p>
<pre><code># 名字自取，配置文件别忘记同步更新
adduser mysql
</code></pre>
<h2 id="配置">配置</h2>
<p>更新配置文件信息</p>
<pre><code>vim /etc/my.cnf
</code></pre>
<p>配置内容如下</p>
<pre><code>[client]
# 设置3306端口
port            = 3306
socket          = /usr/local/mysql/data/mysql.sock
[mysqld]
# Skip #
skip_name_resolve              = 1
skip_external_locking          = 1 
skip_symbolic_links     = 1
# GENERAL #
# 用户
user = mysql
# 创建新表时将使用的默认存储引擎
default_storage_engine = InnoDB
# 服务端使用的字符集默认为UTF8
character-set-server = utf8
socket  = /usr/local/mysql/data/mysql.sock
pid_file = /usr/local/mysql/data/mysqld.pid
# 设置mysql的安装目录
basedir = /usr/local/mysql
port = 3306
bind-address = 0.0.0.0
explicit_defaults_for_timestamp = off
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
#read_only=on
# MyISAM #
key_buffer_size                = 32M
#myisam_recover                 = FORCE,BACKUP

# undo log #
innodb_undo_directory = /usr/local/mysql/undo
innodb_undo_tablespaces = 8

# SAFETY #
max_allowed_packet             = 100M
#允许连接失败的次数。防止有人从该主机试图攻击数据库系统
max_connect_errors             = 1000000
sysdate_is_now                 = 1
#innodb = FORCE
#innodb_strict_mode = 1
secure-file-priv='/tmp'
default_authentication_plugin='mysql_native_password'
# Replice #
 server-id = 1001
 relay_log = mysqld-relay-bin
 gtid_mode = on
 enforce-gtid-consistency
 log-slave-updates = on
 master_info_repository =TABLE
 relay_log_info_repository =TABLE


# DATA STORAGE #
# 设置mysql数据库的数据的存放目录
 datadir = /usr/local/mysql/data/
 tmpdir = /tmp
 
# BINARY LOGGING #
 log_bin = /usr/local/mysql/sql_log/mysql-bin
 max_binlog_size = 1000M
 binlog_format = row
 binlog_expire_logs_seconds=86400
# sync_binlog = 1

 # CACHES AND LIMITS #
 tmp_table_size                 = 32M
 max_heap_table_size            = 32M
 # 允许最大连接数
 max_connections                = 4000
 thread_cache_size              = 2048
 open_files_limit               = 65535
 table_definition_cache         = 4096
 table_open_cache               = 4096
 sort_buffer_size               = 2M
 read_buffer_size               = 2M
 read_rnd_buffer_size           = 2M
# thread_concurrency             = 24
 join_buffer_size = 1M
# table_cache = 32768
 thread_stack = 512k
 max_length_for_sort_data = 16k


 # INNODB #
 innodb_flush_method            = O_DIRECT
 innodb_log_buffer_size = 16M
 innodb_flush_log_at_trx_commit = 2
 innodb_file_per_table          = 1
 innodb_buffer_pool_size        = 256M
 #innodb_buffer_pool_instances = 8
 innodb_stats_on_metadata = off
 innodb_open_files = 8192
 innodb_read_io_threads = 16
 innodb_write_io_threads = 16
 innodb_io_capacity = 20000
 innodb_thread_concurrency = 0
 innodb_lock_wait_timeout = 60
 innodb_old_blocks_time=1000
 innodb_use_native_aio = 1
 innodb_purge_threads=1
 innodb_change_buffering=all
 innodb_log_file_size = 64M
 innodb_log_files_in_group = 2
 innodb_data_file_path  = ibdata1:256M:autoextend
 
 innodb_rollback_on_timeout=on
 # LOGGING #
 log_error                      = /usr/local/mysql/sql_log/mysql-error.log
 # log_queries_not_using_indexes  = 1
 # slow_query_log                 = 1
  slow_query_log_file            = /usr/local/mysql/sql_log/slowlog.log

 # TimeOut #
 #interactive_timeout = 30
 #wait_timeout        = 30
 #net_read_timeout = 60

[mysqldump]
quick
max_allowed_packet = 100M

[mysql]
no-auto-rehash
# Remove the next comment character if you are not familiar with SQL
#safe-updates

[myisamchk]
key_buffer_size = 256M
sort_buffer_size = 256M
read_buffer = 2M
write_buffer = 2M

[mysqlhotcopy]
interactive-timeout
</code></pre>
<p>建立各种文件存储文件同时赋予 <code>mysql</code> 权限</p>
<pre><code>cd /usr/local/mysql/

mkdir data undo sql_log

# 赋予 mysql 属主
chown mysql:mysql data/ undo/ sql_log/
</code></pre>
<p>配置环境 <code>/ect/profile</code> 变量方便 <code>mysql</code> 启动</p>
<pre><code># 末尾添加
export PATH=$PATH:/usr/local/mysql/bin
# 更新配置source /etc/profile
</code></pre>
<h2 id="初始化">初始化</h2>
<pre><code>mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
</code></pre>
<p>把启动 <code>mysql.sever</code> 移动到 <code>/etc/init.d</code> 中</p>
<pre><code>cp support-files/mysql.server /etc/init.d/mysqld
</code></pre>
<h2 id="启动">启动</h2>
<pre><code>/etc/init.d/mysqld start
# 查看进程状态
ps -ef | grep mysql
</code></pre>
<h2 id="登录">登录</h2>
<p>登录 <code>mysql</code></p>
<pre><code>cat sql_log/mysql-error.log | grep password
# [Note] [MY-010454] [Server] A temporary password is generated for root@localhost:Py1Olku2-u8v
# Py1Olku2-u8v 就为初始的临时密码# 连接 mysqlmysql -uroot -pPy1Olku2-u8v
</code></pre>
<p>重置密码</p>
<pre><code>alter user user() identified by '123456';
# 密码线上需要复杂些，这本地测试
# 退出，重新登录
mysql -uroot -p123456
# 成功登录，结束
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[消息队列]]></title>
        <id>http://weakcc.github.io/post/xiao-xi-dui-lie/</id>
        <link href="http://weakcc.github.io/post/xiao-xi-dui-lie/">
        </link>
        <updated>2021-03-16T00:48:30.000Z</updated>
        <content type="html"><![CDATA[<p><code>消息（Message）</code>：传输的数据。<br>
<code>队列（Queue）</code>：队列是一种先进先出的数据结构。<br>
<code>消息队列</code>是消息的传输过程中保存消息的容器，也可以简单理解为：<b>把要传输的数据放在队列中</b>。</p>
<p>一般来说，<b>消息队列是一种异步的服务间通信方式，是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构</b>。使用较多的消息队列有<code>RocketMQ</code>、<code>RabbitMQ</code>、<code>Kafka</code>等。</p>
<blockquote>
<p>生产者：把数据放到消息队列叫做生产者<br>
消费者：从消息队列里边取数据叫做消费者</p>
</blockquote>
<h1 id="为什么要用消息队列消息队列的应用场景">为什么要用消息队列（消息队列的应用场景）</h1>
<p>常用应用场景：解耦、异步、削峰</p>
<h2 id="解耦">解耦</h2>
<p>应用耦合：<b>多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败</b></p>
<p>系统未解耦：以电商应用为例，用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障或者因为升级等原因暂时不可用，都会造成下单异常，影响用户体验。（图1-1）</p>
<p>系统解耦：使用消息队列解耦合，比如物流系统发生故障，需要几分钟才能修复，在这段时间内，物流系统要处理的数据被缓存到消息队列中，用户的下单操作正常完成。当物流系统恢复后，补充处理被缓存到消息队列中的订单数据，终端系统感知不到物流系统发生的故障。（图1-2）<br>
<img src="http://weakcc.github.io/post-images/1615859297884.png" alt="" loading="lazy"><br>
当订单系统不需要物流系统时，不用消息队列需要来回修改耦合的代码，用 MQ 后只需在物流系统消费者处不在接收订单队列信息即可。降低了人工成本，代码便于维护。</p>
<h2 id="异步">异步</h2>
<p>异步处理：<b>多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间</b></p>
<p>系统未异步：A 系统接收一个请求，需要在自己本地写库，还需要在B、C、D三个系统写库，自己本地写库要 3ms，B、C、D三个系统写库分别要 300ms、450ms、200ms。最终请求总延迟是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户体验很差，一般的互联网企业，对于用户的直接操作，容忍必须要 200ms 以内，对用户是无感知的，用户通过浏览器发起请求，等待 1s，这个几乎是无法接受的。（图1-1）</p>
<p>系统异步：如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假设耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长为 5 + 3 = 8ms，响应速度大大提升，改善了用户的体验。（图1-2）<br>
<img src="http://weakcc.github.io/post-images/1615860664817.png" alt="" loading="lazy"></p>
<h2 id="削峰">削峰</h2>
<p>限流削峰：<b>广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况</b></p>
<p>应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮（图1-1）。有了消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以大大提升系统的稳定性和用户体验（图1-2）。</p>
<p>一般情况，为了保证系统的稳定性，如果系统负载超过阈值，就会阻止用户请求，这会影响用户体验，而如果使用消息队列将请求缓存起来，等待系统处理完毕后通知用户下单完成，这样下单体验也好点。</p>
<p>业务系统正常时段的 QPS 如果是1K，流量最高峰是10K，为了应对流量高峰配置高性能的服务器显然不划算，这时可以使用消息队列对峰值流量进行削峰。<br>
<img src="http://weakcc.github.io/post-images/1615870854381.png" alt="" loading="lazy"></p>
<h1 id="各种消息队列产品的比较">各种消息队列产品的比较</h1>
<h1 id="消息队列的优点和缺点">消息队列的优点和缺点</h1>
<h1 id="如何保证消息队列的高可用">如何保证消息队列的高可用</h1>
<h1 id="如何保证消息不丢失">如何保证消息不丢失</h1>
<h1 id="如何保证消息不被重复消费如何保证消息消费的幂等性">如何保证消息不被重复消费（如何保证消息消费的幂等性）</h1>
<h1 id="如何保证消息消费的顺序性">如何保证消息消费的顺序性</h1>
<h1 id="基于-mq-的分布式事务实现">基于 MQ 的分布式事务实现</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Laradock 搭建基于 Docker 的 PHP 开发环境]]></title>
        <id>http://weakcc.github.io/post/shi-yong-laradock-da-jian-ji-yu-docker-de-php-kai-fa-huan-jing/</id>
        <link href="http://weakcc.github.io/post/shi-yong-laradock-da-jian-ji-yu-docker-de-php-kai-fa-huan-jing/">
        </link>
        <updated>2021-03-15T07:31:19.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="首先将-laradock-项目代码克隆到本地">首先将 Laradock 项目代码克隆到本地</h1>
<pre><code class="language-shell">git clone https://github.com/Laradock/laradock.git
</code></pre>
<h1 id="进入-laradock-目录将-env-example-重命名为-env">进入 laradock 目录将 env-example 重命名为 .env</h1>
<pre><code class="language-shell">cp env-example .env
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="首先将-laradock-项目代码克隆到本地">首先将 Laradock 项目代码克隆到本地</h1>
<pre><code class="language-shell">git clone https://github.com/Laradock/laradock.git
</code></pre>
<h1 id="进入-laradock-目录将-env-example-重命名为-env">进入 laradock 目录将 env-example 重命名为 .env</h1>
<pre><code class="language-shell">cp env-example .env
</code></pre>
<!-- more -->
<p>编辑<code>.env</code>文件</p>
<pre><code># 编辑
APP_CODE_PATH_HOST=../ # 项目路径
CHANGE_SOURCE=true # 切换源
WORKSPACE_TIMEZONE=PRC # 时区
PHP_VERSION=7.3
MYSQL_VERSION=8.0
# 新增
DB_HOST=mysql
REDIS_HOST=redis
QUEUE_HOST=beanstalkd
</code></pre>
<h1 id="运行容器">运行容器</h1>
<pre><code class="language-shell">docker-compose up -d nginx mysql redis beanstalkd
</code></pre>
<h1 id="创建项目">创建项目</h1>
<pre><code class="language-shell">composer create-project --prefer-dist laravel/laravel test
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1615796925712.png" alt="" loading="lazy"></figure>
<h1 id="做-nginx-配置">做 nginx 配置</h1>
<p><img src="http://weakcc.github.io/post-images/1615797075338.png" alt="" loading="lazy"><br>
<img src="http://weakcc.github.io/post-images/1615797081492.png" alt="" loading="lazy"><br>
重启 nginx</p>
<pre><code class="language-shell">docker-compose up -d nginx
</code></pre>
<p>就可以通过浏览器访问了。</p>
<h1 id="错误">错误</h1>
<p>问题：<br>
ERROR: for nginx  Cannot start service nginx: Ports are not available: port is already allocated.<br>
<img src="http://weakcc.github.io/post-images/1615794973501.png" alt="" loading="lazy"><br>
解决：<br>
指定80端口已经被占用，关闭相应的服务再重新运行上述命令即可</p>
]]></content>
    </entry>
</feed>