<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2021-11-16T08:40:11.337Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[通过 MVCC（多版本并发控制）保证数据库事务的一致性]]></title>
        <id>http://weakcc.github.io/post/tong-guo-mvccduo-ban-ben-bing-fa-kong-zhi-bao-zheng-shu-ju-ku-shi-wu-de-yi-zhi-xing/</id>
        <link href="http://weakcc.github.io/post/tong-guo-mvccduo-ban-ben-bing-fa-kong-zhi-bao-zheng-shu-ju-ku-shi-wu-de-yi-zhi-xing/">
        </link>
        <updated>2021-11-12T00:18:09.000Z</updated>
        <summary type="html"><![CDATA[<p><code>MVCC</code> 的英文全称是 <strong>Multiversion Concurrency Control</strong>，中文意思是多版本并发控制技术。原理是，通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。</p>
]]></summary>
        <content type="html"><![CDATA[<p><code>MVCC</code> 的英文全称是 <strong>Multiversion Concurrency Control</strong>，中文意思是多版本并发控制技术。原理是，通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。</p>
<!-- more -->
<h2 id="undo-日志链表">undo 日志链表</h2>
<p>当 InnoDB 引擎底层开启一个新事务的时候，会分配一个全局唯一的事务 ID，该事务 ID 写入 undo 日志的同时也会存储到数据表记录簇拥索引的 <code>trx_id</code> 隐藏列中。<br>
<img src="http://weakcc.github.io/post-images/1636676416765.png" alt="" loading="lazy"><br>
另一个隐藏列 <code>roll_pointer</code> 指针会指向该记录上一个版本的 undo 日志，发生事务回滚时我们可以通过该指针找到这条记录要回滚到的版本。<br>
这样，每次记录更新后，上一个版本的值就会被存放到 undo 日志中，并且将当前最新记录的 <code>roll_pointer</code> 指针指向该 undo 日志，这样一来，所有的 <code>roll_pointer</code> 指针串成一个链表，该链表被称作版本链，版本链的头节点就是当前记录最新版本的值。<br>
🌰<br>
现在假设有一个<code>事务 A（id=50）</code>，插入了一条数据，那么此时这条数据的隐藏字段以及指向的 <code>undo log</code> 如下图所示，插入的这条数据的值是 A，因此此时<code>事务 A</code> 的 id 是 50，所以这条数据的 <code>txr_id</code> 就是 50，<code>roll_pointer</code> 指向一个空的 <code>undo log</code>，因为之前这条数据是没有的。<br>
<img src="http://weakcc.github.io/post-images/1636681437542.png" alt="" loading="lazy"><br>
接着有一个<code>事务 B</code> 跑来修改了一下这条数据，把值改成了值 B，<code>事务 B</code> 的 id 是 58，那么此时更新之前会生成一个 <code>undo log</code> 记录之前的值，然后会把 <code>roll pointer</code> 指向这个实际的 <code>undo log</code> 回滚日志，如下图所示<br>
<img src="http://weakcc.github.io/post-images/1636681605467.png" alt="" loading="lazy"><br>
接着<code>事务 C</code> 同理，如下图所示<br>
<img src="http://weakcc.github.io/post-images/1636681701729.png" alt="" loading="lazy"><br>
多个事务串行执行的时候，每个人修改了一行数据，都会更新隐藏字段 <code>txr_id</code> 和 <code>roll_pointer</code>，同时之前多个数据快照对应的 <code>undo log</code>，会通过 <code>roll_pointer</code> 指针串联起来，形成一个重要的版本链。</p>
<h2 id="readview-可读视图">ReadView （可读视图）</h2>
<p>ReadView 实际上是当前系统中所有活跃事务的列表，主要包含以下组成部分：</p>
<ul>
<li><code>m_ids</code>：在生成 ReadView 时当前系统中活跃的事务 ID 列表</li>
<li><code>min_trx_id</code>：在生成 ReadView 时当前系统中活跃的事务中最小的事务 ID，也就是 m_ids 中的最小值</li>
<li><code>max_trx_id</code>：在生成 ReadView 时系统中应该分配给下一个事务的 ID 值</li>
<li><code>creator_trx_id</code>：生成 ReadView 的事务对应的事务 ID，也就是当前事务 ID</li>
</ul>
<p>有了这个 ReadView 之后，在访问某条记录时，只需要按照下边的步骤判断该记录的某个版本是否可见：</p>
<ul>
<li>如果被访问版本的 <code>trx_id</code> 属性值与 ReadView 中的 <code>tcreator_trx_id</code> 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本记录可以被当前事务访问</li>
<li>如果被访问版本的 <code>trx_id</code> 属性值小于 ReadView 中的 <code>min_trx_id</code> 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本记录可以被当前事务访问</li>
<li>如果被访问版本的 <code>trx_id</code> 属性值大于或等于 ReadView 中的 <code>max_trx_id</code> 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本记录不可以被当前事务访问</li>
<li>如果被访问版本的 <code>trx_id</code> 属性值在 ReadView 的 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，那就需要判断一下 <code>trx_id</code> 属性值是不是在 <code>m_ids</code> 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本记录可以被访问</li>
<li>如果某个版本的记录对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录</li>
</ul>
<p>🌰<br>
假设原来数据库里就有一行数据，很早以前就有事务插入过了，事务 id 是 32，他的初始值，如下图<br>
<img src="http://weakcc.github.io/post-images/1636682975510.png" alt="" loading="lazy"><br>
接着呢，此时两个事务并发来执行了，一个<code>事务 A</code>（id=45），一个<code>事务 B</code>（id=59），<code>事务 B</code> 是要去更新这行数据的，<code>事务 A</code> 是要去读取这行数据的，此时两个事务如下<br>
<img src="http://weakcc.github.io/post-images/1636683099964.png" alt="" loading="lazy"><br>
现在<code>事务 A</code> 直接开启一个 <code>ReadView</code>，这刚 <code>ReadView</code> 里的 <code>m_ids</code> 就包含了<code>事务 A</code> 和<code>事务 B</code> 的两个 id，45 和 59，然后 <code>min_trx_id</code> 就是 45，<code>max_trx_id</code> 就是 60，<code>creator_trx_id 就是 45，是</code>事务 A` 自己。</p>
<p>这刚时候<code>事务 A</code> 第一次查询这行数据，会走一个判断，就是判断一下当前这行数据的 <code>trx_id</code> 是否小于 <code>ReadView</code> 中的 <code>min_trx_id</code>，此时发现 <code>trx_id=32</code> ，是小于 <code>ReadView</code> 里的 <code>min_trx_id</code> 就是 45 的，说明你事务开启之前，修改这行数据的事务早已提交，所以此时可以查询这行数据，如下<br>
<img src="http://weakcc.github.io/post-images/1636683428146.png" alt="" loading="lazy"><br>
接着<code>事务 B</code> 开始动手了，他把这行数据的值改为了值 B，然后这行数据的 <code>trx_id</code> 设置为自己的 id，也就是 59，同时 <code>roll_pointer</code> 指向了修改之前生成的一个 <code>undo log</code>，接着这个<code>事务 B</code> 就提交了，如下<br>
<img src="http://weakcc.github.io/post-images/1636683586822.png" alt="" loading="lazy"><br>
这个时候 <code>事务 A</code> 再次查询，此时查询的时候，会发现一个问题，那就是此时数据行里的 <code>trx_id=59</code>，那么这个 <code>trx_id</code> 是大于 <code>ReadView</code> 里的 <code>min_trx_id（45）</code>，同时小于 <code>ReadView</code> 里的 <code>max_trx_id（60）</code>，说明更新这条数据的事务，很可能就跟自己差不多是同时开启的，于是会看一下这个 <code>trx_id=59</code>，是否在 <code>ReadView</code> 的 <code>m_ids</code> 列表里的？果然，在 <code>ReadView</code> 的 <code>m_ids</code> 列表里，有 45 和 59 两个事务 id，直接证实了，这个修改数据的事务是跟自己同一时段并发执行然后提交的，所以这行数据是不能查询的，如下<br>
<img src="http://weakcc.github.io/post-images/1636683916110.png" alt="" loading="lazy"><br>
既然这行数据不能查询，那么查询什么呢？<br>
简单，顺着这条数据的 <code>roll_pointer</code> 顺着 <code>undo log</code> 日志链条往下找，就会找到最近一条 <code>undo log</code>，<code>trx_id</code> 是 32，此时发现 <code>trx_id=32</code>，是小于 <code>ReadView</code> 里的 <code>min_trx_id（45）</code>的，说明这个 <code>undo log</code> 版本必然是在<code>事务 A</code> 开启之前就执行且提交的。<br>
好了，那么就查询最近的 <code>undo log</code> 里的值就好了，这就是 <code>undo log</code> 对版本链条的作用，他可以保存一个快照链条，让你可以读到之前的快照值。如下<br>
<img src="http://weakcc.github.io/post-images/1636684163556.png" alt="" loading="lazy"><br>
多个事务并发执行的时候，<code>事务 B</code> 更新的值，通过这套 <strong>ReadView + undo log</strong> 日志链条的机制，就可以保证<code>事务 A</code> 不会读到并发执行的<code>事务 B</code> 更新的值，只会读到之前的值。</p>
<p>接着假设<code>事务 A</code> 自己更新了这行数据，改为值 A，<code>trxt_id</code>修好为 45，同时保存之前<code>事务 B</code> 修改值的快照，如下<br>
<img src="http://weakcc.github.io/post-images/1636684360943.png" alt="" loading="lazy"><br>
此时<code>事务 A</code> 来查询这条数据的值，会发现这个 <code>trx_id=45</code>，居然跟自己的 <code>ReadView</code>里的 <code>creator_trx_id（45）</code>是一样的，说明什么？</p>
<p>说明这行数据的就是自己修改的，自己修改的值当然是可以看到的，如下<br>
<img src="http://weakcc.github.io/post-images/1636684489534.png" alt="" loading="lazy"><br>
接着在事务A执行的过程中，突然开启一个<code>事务 C</code>，这个事务的 id 是 78，然后他更新了那行数据的值为值 C，还提交了，如下<br>
<img src="http://weakcc.github.io/post-images/1636684574035.png" alt="" loading="lazy"><br>
这个时候<code>事务 A</code> 再去查询，会发现当前数据的 <code>trx_id=78</code>，大于了自己的 <code>ReadView</code> 中的 <code>max_trx_id（60）</code>，此时说明了什么？</p>
<p>说明是这个 <code>事务 A</code> 开启之后，然后有一个事务更新了数据，自己当然是不能看到的，如下<br>
<img src="http://weakcc.github.io/post-images/1636684712358.png" alt="" loading="lazy"><br>
此时就会顺着 <code>undo log</code> 多版本链条往下找，先找到值 A 是自己之前修改过的版本，因为那个 <code>trx_id=45</code> 跟自己的 <code>ReadVie</code> 里的 <code>creator_trx_id</code> 是一样的，所以此时直接读取自己之前修改的那个版本，如下<br>
<img src="http://weakcc.github.io/post-images/1636684860422.png" alt="" loading="lazy"></p>
<blockquote>
<p>注：在 MySQL InnoDB 引擎中，只有 READ COMMITTD 和 REPEATABLE READ 这两种隔离级别才可以使用 MVCC，应对高并发事务，MVCC 比单纯的加行锁更有效，开销更小。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ 从入门到放弃]]></title>
        <id>http://weakcc.github.io/post/rabbitmq-cong-ru-men-dao-fang-qi/</id>
        <link href="http://weakcc.github.io/post/rabbitmq-cong-ru-men-dao-fang-qi/">
        </link>
        <updated>2021-11-11T06:24:30.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="概念说明">概念说明</h1>
<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1636619280369.png" alt="" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<h1 id="概念说明">概念说明</h1>
<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1636619280369.png" alt="" loading="lazy"></figure>
<!-- more -->
<h2 id="broker">Broker</h2>
<p>简单来说就是消息队列服务器实体。</p>
<h2 id="exchange">Exchange</h2>
<p>消息交换机，它指定消息按什么规则，路由到哪个队列。</p>
<h2 id="queue">Queue</h2>
<p>消息队列载体，每个消息都会被投入到一个或多个队列。</p>
<h2 id="binding">Binding</h2>
<p>绑定，它的作用就是把 <code>exchange</code> 和 <code>queue</code> 按照路由规则绑定起来。</p>
<h2 id="routing-key">Routing Key</h2>
<p>路由关键字，<code>exchange</code> 根据这个关键字进行消息投递。</p>
<h2 id="vhost">vhost</h2>
<p>虚拟主机，一个 <code>broker</code> 里可以开设多个 <code>vhost</code>，用作不同用户的权限分离。</p>
<h2 id="producer">producer</h2>
<p>消息生产者，就是投递消息的程序。</p>
<h2 id="consumer">consumer</h2>
<p>消息消费者，就是接受消息的程序。</p>
<h2 id="channel">channel</h2>
<p>消息通道，在客户端的每个连接里，可建立多个 <code>channel</code>，每个 <code>channel</code> 代表一个会话任务。</p>
<h2 id="使用过程">使用过程</h2>
<ul>
<li>
<ol>
<li>客户端连接到消息队列服务器，打开一个channel</li>
</ol>
</li>
<li>
<ol start="2">
<li>客户端声明一个 <code>exchange</code>，并设置相关属性</li>
</ol>
</li>
<li>
<ol start="3">
<li>客户端声明一个 <code>queue</code>，并设置相关属性</li>
</ol>
</li>
<li>
<ol start="4">
<li>客户端使用 <code>routing key</code>，在 <code>exchange</code> 和 <code>queue</code> 之间建立好绑定关系</li>
</ol>
</li>
<li>
<ol start="5">
<li>客户端投递消息到 <code>exchange</code></li>
</ol>
</li>
</ul>
<p><code>exchange</code> 接收到消息后，就根据消息的 <code>key</code> 和已经设置的 <code>binding</code>，进行消息路由，将消息投递到一个或多个队列里。</p>
<p><code>exchange</code> 也有几个类型，完全根据 <code>key</code> 进行投递的叫做 <strong>Direct</strong> 交换机，例如，绑定时设置了 <code>routing key</code>为 “abc”，那么客户端提交的消息，只有设置了 <code>key</code> 为 “abc” 的才会投递到队列。对 <code>key</code> 进行模式匹配后进行投递的叫做 <strong>Topic</strong> 交换机，符号 <b>#</b> 匹配一个或多个词，符号 <b>*</b> 匹配正好一个词。例如 “abc.#” 匹配 “abc.def.ghi”，“abc.*” 只匹配 “abc.def”。还有一种不需要 <code>key</code> 的，叫做 <strong>Fanout</strong> 交换机，它采取广播模式，一个消息进来时，投递到与该交换机绑定的所有队列。</p>
<h3 id="direct">Direct</h3>
<figure data-type="image" tabindex="2"><img src="http://weakcc.github.io/post-images/1636619505554.png" alt="" loading="lazy"></figure>
<h3 id="fanout">Fanout</h3>
<figure data-type="image" tabindex="3"><img src="http://weakcc.github.io/post-images/1636619513185.png" alt="" loading="lazy"></figure>
<h3 id="topic">Topic</h3>
<figure data-type="image" tabindex="4"><img src="http://weakcc.github.io/post-images/1636619518110.png" alt="" loading="lazy"></figure>
<p><strong>RabbitMQ</strong> 支持消息的持久化，也就是数据写在磁盘上：</p>
<ul>
<li>
<ol>
<li><code>exchange</code> 持久化，在声明时指定 <code>durable =&gt; 1</code></li>
</ol>
</li>
<li>
<ol start="2">
<li><code>queue</code> 持久化，在声明时指定 <code>durable =&gt; 1</code></li>
</ol>
</li>
<li>
<ol start="3">
<li>消息持久化，在投递时指定 <code>delivery_mode =&gt; 2</code>（1是非持久化）</li>
</ol>
</li>
</ul>
<blockquote>
<p>如果 exchange 和 queue 都是持久化的，那么它们之间的 binding 也是持久化的。如果 exchange 和 queue 两者之间有一个持久化，一个非持久化，就不允许建立绑定。</p>
</blockquote>
<h1 id="mac-下搭建-php-开发环境">Mac 下搭建 PHP 开发环境</h1>
<h2 id="安装-rabbitmq">安装 RabbitMQ</h2>
<pre><code class="language-php">brew install rabbitmq

brew install rabbitmq-c

pecl install amqp
</code></pre>
<blockquote>
<p>安装过程提示：Set the path to librabbitmq install prefix [autodetect]<br>
解决办法：/usr/local/Cellar/rabbitmq-c/0.11.0</p>
</blockquote>
<h2 id="php-中实现消息发送和接收">PHP 中实现消息发送和接收</h2>
<p><code>send.php</code></p>
<pre><code class="language-php">&lt;?php
/**
 * 发送消息
 */

$exchangeName = 'demo';
$routeKey = 'hello';
$message = 'Hello World!';

// 建立TCP连接
$connection = new AMQPConnection([
    'host' =&gt; 'localhost',
    'port' =&gt; '5672',
    'vhost' =&gt; '/',
    'login' =&gt; 'guest',
    'password' =&gt; 'guest'
]);
$connection-&gt;connect() or die(&quot;Cannot connect to the broker!\n&quot;);

try {
    $channel = new AMQPChannel($connection);

    $exchange = new AMQPExchange($channel);
    $exchange-&gt;setName($exchangeName);
    $exchange-&gt;setType(AMQP_EX_TYPE_DIRECT);
    $exchange-&gt;declareExchange();

    echo 'Send Message: ' . $exchange-&gt;publish($message, $routeKey) . &quot;\n&quot;;
    echo &quot;Message Is Sent: &quot; . $message . &quot;\n&quot;;
} catch (AMQPConnectionException $e) {
    var_dump($e);
}

// 断开连接
$connection-&gt;disconnect();
</code></pre>
<p><code>receive.php</code></p>
<pre><code class="language-php">&lt;?php
/**
 * 接收消息
 */

$exchangeName = 'demo';
$queueName = 'hello';
$routeKey = 'hello';

// 建立TCP连接
$connection = new AMQPConnection([
    'host' =&gt; 'localhost',
    'port' =&gt; '5672',
    'vhost' =&gt; '/',
    'login' =&gt; 'guest',
    'password' =&gt; 'guest'
]);
$connection-&gt;connect() or die(&quot;Cannot connect to the broker!\n&quot;);

$channel = new AMQPChannel($connection);

$exchange = new AMQPExchange($channel);
$exchange-&gt;setName($exchangeName);
$exchange-&gt;setType(AMQP_EX_TYPE_DIRECT);

echo 'Exchange Status: ' . $exchange-&gt;declareExchange() . &quot;\n&quot;;

$queue = new AMQPQueue($channel);
$queue-&gt;setName($queueName);

echo 'Message Total: ' . $queue-&gt;declareQueue() . &quot;\n&quot;;

echo 'Queue Bind: ' . $queue-&gt;bind($exchangeName, $routeKey) . &quot;\n&quot;;

var_dump(&quot;Waiting for message...&quot;);

// 消费队列消息
while(TRUE) {
    $queue-&gt;consume('processMessage');
}

// 断开连接
$connection-&gt;disconnect();

function processMessage($envelope, $queue) {
    $msg = $envelope-&gt;getBody();
    var_dump(&quot;Received: &quot; . $msg);
    $queue-&gt;ack($envelope-&gt;getDeliveryTag()); // 手动发送ACK应答
}
</code></pre>
<p>测试：<br>
打开两个终端<br>
先运行接收者脚本监听消息发送</p>
<pre><code class="language-shell">php receive.php
</code></pre>
<p>在另一个终端中运行消息发送脚本</p>
<pre><code class="language-shell">php send.php
</code></pre>
<p>然后会在消费者终端中看到消息被接收并打印出来。</p>
<h2 id="消息分发机制">消息分发机制</h2>
<p>对于计算密集型任务，需要将其分发给多个消费者进行处理。<br>
<code>task.php</code></p>
<pre><code class="language-php">&lt;?php
/**
 * 分发任务
 */

$exchangeName = 'task';
$queueName = 'worker';
$routeKey = 'worker';
$message = empty($argv[1]) ? 'Hello World!' : $argv[1];

// 建立TCP连接
$connection = new AMQPConnection([
    'host' =&gt; 'localhost',
    'port' =&gt; '5672',
    'vhost' =&gt; '/',
    'login' =&gt; 'guest',
    'password' =&gt; 'guest'
]);
$connection-&gt;connect() or die(&quot;Cannot connect to the broker!\n&quot;);

try {
    $channel = new AMQPChannel($connection);

    $exchange = new AMQPExchange($channel);
    $exchange-&gt;setName($exchangeName);
    $exchange-&gt;setType(AMQP_EX_TYPE_DIRECT);
    $exchange-&gt;declareExchange();

    echo 'Send Message: ' . $exchange-&gt;publish($message, $routeKey) . &quot;\n&quot;;
    echo &quot;Message Is Sent: &quot; . $message . &quot;\n&quot;;
} catch (AMQPConnectionException $e) {
    var_dump($e);
}

// 断开连接
$connection-&gt;disconnect();
</code></pre>
<p><code>worker.php</code></p>
<pre><code class="language-php">&lt;?php
/**
 * 处理任务
 */

$exchangeName = 'task';
$queueName = 'worker';
$routeKey = 'worker';

// 建立TCP连接
$connection = new AMQPConnection([
    'host' =&gt; 'localhost',
    'port' =&gt; '5672',
    'vhost' =&gt; '/',
    'login' =&gt; 'guest',
    'password' =&gt; 'guest'
]);
$connection-&gt;connect() or die(&quot;Cannot connect to the broker!\n&quot;);

$channel = new AMQPChannel($connection);

$exchange = new AMQPExchange($channel);
$exchange-&gt;setName($exchangeName);
$exchange-&gt;setType(AMQP_EX_TYPE_DIRECT);

echo 'Exchange Status: ' . $exchange-&gt;declareExchange() . &quot;\n&quot;;

$queue = new AMQPQueue($channel);
$queue-&gt;setName($queueName);

echo 'Message Total: ' . $queue-&gt;declareQueue() . &quot;\n&quot;;

echo 'Queue Bind: ' . $queue-&gt;bind($exchangeName, $routeKey) . &quot;\n&quot;;

var_dump(&quot;Waiting for message...&quot;);

// 消费队列消息
while(true) {
    $queue-&gt;consume('processMessage');
}

// 断开连接
$connection-&gt;disconnect();

function processMessage($envelope, $queue) {
    $msg = $envelope-&gt;getBody();
    var_dump(&quot;Received: &quot; . $msg);
    sleep(substr_count($msg, '.')); // 为每一个点号模拟1秒钟操作
    $queue-&gt;ack($envelope-&gt;getDeliveryTag()); // 手动发送ACK应答
}
</code></pre>
<h3 id="轮询分发">轮询分发</h3>
<p><strong>轮询分发</strong>，打开两个终端，分别运行</p>
<pre><code class="language-shell">php worker.php
</code></pre>
<p>然后再开一个终端进行任务分发</p>
<pre><code class="language-shell">php task.php 第一条消息...
php task.php 第二条消息...
php task.php 第三条消息...
php task.php 第四条消息...
php task.php 第五条消息...
php task.php 第六条消息...
</code></pre>
<figure data-type="image" tabindex="5"><img src="http://weakcc.github.io/post-images/1636696898388.png" alt="" loading="lazy"></figure>
<h3 id="消息确认">消息确认</h3>
<p>每个 Consumer 可能需要一段时间才能处理完收到的数据。如果在这个过程中，Consumer 出错或异常退出，而数据还没有处理完成，那么这段数据就丢失了。因为我们采用 no-ack 的方式进行确认，也就是说，每次 Consumer 接到数据后，不管是否处理完成，RabbitMQ Server 会立即把这个 Message 标记为完成，然后从 Queue 中删除。</p>
<p>为了保证数据不被丢失，RabbitMQ 支持消息确认机制，这种机制下不能采用 no-ack，而应该是在处理完数据后发送 ack。如果处理中途 Consumer 退出了，但是没有发送 ack，那么 RabbitMQ 就会把这个 Message 发送到下一个 Consumer，这样就保证了在 Consumer 异常退出的情况下数据也不会丢失。</p>
<p>这里并没有用到超时机制，RabbitMQ 仅仅通过 Consumer 的连接中断来确认该 Message 并没有被正确处理，也就是说，RabbitMQ 给 Consumer 足够长的时间来做数据处理。</p>
<p>之前的例子中，我们在代码中使用了 <code>$queue-&gt;ack($envelope-&gt;getDeliveryTag());</code>，这就是消息确认机制的应用，这种情况下，即使中断任务执行，也不会影响 RabbitMQ 中消息的处理，RabbitMQ 会将其发送给下一个 Consumer 进行处理。</p>
<p>如果忘记了 ack，那么后果很严重。当 Consumer 退出时，Message 会重新分发。然后 RabbitMQ 会占用越来越多的内存，由于 RabbitMQ 会长时间运行，因此这个“内存泄漏”是致命的。针对这行场景，可以通过以下命令进行<br>
Debug</p>
<pre><code class="language-shell">sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged
</code></pre>
<h3 id="消息持久化">消息持久化</h3>
<p>为了保证在 RabbitMQ 退出或者 crash 了数据不丢失，需要将 Queue 和 Message 持久化。<br>
Exchange 的持久化</p>
<pre><code class="language-shell">$exchange-&gt;setFlags(AMQP_DURABLE);
</code></pre>
<p>Queue 的持久化</p>
<pre><code class="language-shell">$queue-&gt;setFlags(AMQP_DURABLE);
</code></pre>
<h3 id="fair-dispatch-公平分发">Fair dispatch 公平分发</h3>
<p>轮询的弊病：依次分发，周而复始，在某些 Consumer 负载很重的时候，还是会分发给它。<br>
我们可以使用 <code>$channel-&gt;setPrefetchCount()</code> 方法，并设置 prefetch_count = 1。这样是告诉 RabbitMQ，在同一时刻，不要发送超过 1 条消息给一个工作者（worker），直到它已经处理了上一条消息并且作出了响应。这样，RabbitMQ 就会把消息分发给下一个空闲的工作者（worker）。</p>
<h2 id="消息订阅publishsubscribe">消息订阅（Publish/Subscribe）</h2>
<p>我们将创建一个日志系统，它包含两个部分：第一个部分负责发出log（Producer），第二个部分负责接收并打印（Consumer）。我们将构建两个 Consumer，第一个将 log 写到物理磁盘上；第二个将 log 输出到屏幕。</p>
<h3 id="exchange-2">Exchange</h3>
<p>Exchange 决定将 Message 发送到具体的 Queue，至于是发送给一个 Queue 还是多个 Queue，则需要通过 Exchange 的类型类决定。Exchange 分为三种类型：direct、topic 和 fanout。fanout 就是广播模式，会将 Message 都放到它所知道的所有 Queue 中</p>
<pre><code class="language-php">$exchange-&gt;setType(AMQP_EX_TYPE_FANOUT);
</code></pre>
<p>现在我们可以直接通过 Exchange，而不需要 routing_key 来发送 Message 了</p>
<pre><code class="language-php">$exchange-&gt;publish($message);
</code></pre>
<h3 id="临时队列">临时队列</h3>
<p>截至现在，我们用的 Queue 都是有名字的。使用有名字的 Queue，使得在 Producer 和 Consumer 之前共享 Queue 成为可能。</p>
<p>在我们的日志系统中，不需要有名字的队列，要实现这个目标，需要在声明队列时不指定名称，而由系统随机分配</p>
<pre><code class="language-php">$queue = new AMQPQueue($channel);
//$queue-&gt;setName($queueName);
$queue-&gt;setFlags(AMQP_EXCLUSIVE);
$queue-&gt;declareQueue();
//$queue-&gt;bind($exchangeName, $routeKey);
</code></pre>
<p>这时，通过 $queue-&gt;getName() 获取到的队列名称是随机生成的。</p>
<h3 id="绑定">绑定</h3>
<p>建立 Exchange 与 Queue 之间的绑定</p>
<pre><code class="language-php">$queue-&gt;bind($exchangeName);
</code></pre>
<h3 id="演示代码">演示代码</h3>
<p><code>emit_logs.php</code></p>
<pre><code class="language-php">&lt;?php
/**
 * 发送消息
 */

$exchangeName = 'logs';
$message = 'Hello World!';

// 建立TCP连接
$connection = new AMQPConnection([
    'host' =&gt; 'localhost',
    'port' =&gt; '5672',
    'vhost' =&gt; '/',
    'login' =&gt; 'guest',
    'password' =&gt; 'guest'
]);
$connection-&gt;connect() or die(&quot;Cannot connect to the broker!\n&quot;);

try {
    $channel = new AMQPChannel($connection);

    $exchange = new AMQPExchange($channel);
    $exchange-&gt;setName($exchangeName);
    $exchange-&gt;setType(AMQP_EX_TYPE_FANOUT);
    $exchange-&gt;declareExchange();

    echo 'Send Message: ' . $exchange-&gt;publish($message) . &quot;\n&quot;;
    echo &quot;Message Is Sent: &quot; . $message . &quot;\n&quot;;
} catch (AMQPConnectionException $e) {
    var_dump($e);
}

// 断开连接
$connection-&gt;disconnect();
</code></pre>
<p><code>receive_logs.php</code></p>
<pre><code class="language-php">&lt;?php
/**
 * 接收消息
 */

$exchangeName = 'logs';

// 建立TCP连接
$connection = new AMQPConnection([
    'host' =&gt; 'localhost',
    'port' =&gt; '5672',
    'vhost' =&gt; '/',
    'login' =&gt; 'guest',
    'password' =&gt; 'guest'
]);
$connection-&gt;connect() or die(&quot;Cannot connect to the broker!\n&quot;);

$channel = new AMQPChannel($connection);

$exchange = new AMQPExchange($channel);
$exchange-&gt;setName($exchangeName);
$exchange-&gt;setType(AMQP_EX_TYPE_FANOUT);
$exchange-&gt;declareExchange();

$queue = new AMQPQueue($channel);
$queue-&gt;setFlags(AMQP_EXCLUSIVE);
$queue-&gt;declareQueue();
$queue-&gt;bind($exchangeName);

var_dump(&quot;Waiting for message...&quot;);

// 消费队列消息
while(true) {
    $queue-&gt;consume('processMessage');
}

// 断开连接
$connection-&gt;disconnect();

function processMessage($envelope, $queue) {
    $msg = $envelope-&gt;getBody();
    var_dump(&quot;Received: &quot; . $msg);
    $queue-&gt;ack($envelope-&gt;getDeliveryTag()); // 手动发送ACK应答
}
</code></pre>
<p><strong>演示流程</strong><br>
打开两个终端，一个消费者队列负责将日志写入文件</p>
<pre><code class="language-shell">php receive_logs.php &gt; logs_from_rabbit.log
</code></pre>
<p>一个负责将日志输出到屏幕</p>
<pre><code class="language-shell">php receive_logs.php
</code></pre>
<p>然后再打开一个终端，将日志信息发送到所有队列</p>
<pre><code class="language-shell">php emit_logs.php
</code></pre>
<p>这样，会发现所有队列会同时接收到日志并进行相应的处理。</p>
<h2 id="通过主题进行消息分发">通过主题进行消息分发</h2>
<p>对于 Message 的 <code>routing_key</code> 字符串格式是有限制的：以点号&quot;.&quot;分割的字符表，如php.laravel，并且长度不能超过 255 个字节。<br>
对于 <code>routing_key</code> 而言，有两个特殊字符</p>
<ul>
<li><code>*</code>：代表任意单词</li>
<li><code>#</code>：代表0个或多个单词</li>
</ul>
<p>Topic Exchange 与其他 Exchange 的转化<br>
<code>routing_key</code> 是 <code>#</code>，会接收所有 Message，此时等同于 Fanout Exchange；<br>
<code>routing_key</code> 不包含 <code>#</code> 或 <code>*</code>，则等同于 Direct Exchange</p>
<h3 id="演示代码-2">演示代码</h3>
<p><code>emit_logs_topic.php</code></p>
<pre><code class="language-php">&lt;?php
/**
 * 发送消息
 */

$exchangeName = 'topic_logs';
$topic = empty($argv[1]) ? 'anonymous.info' : $argv[1]; // 主题
$message = empty($argv[2]) ? 'Hello World!' : $argv[2];

// 建立TCP连接
$connection = new AMQPConnection([
    'host' =&gt; 'localhost',
    'port' =&gt; '5672',
    'vhost' =&gt; '/',
    'login' =&gt; 'guest',
    'password' =&gt; 'guest'
]);
$connection-&gt;connect() or die(&quot;Cannot connect to broker!\n&quot;);

$channel = new AMQPChannel($connection);
$exchange = new AMQPExchange($channel);
$exchange-&gt;setName($exchangeName);
$exchange-&gt;setType(AMQP_EX_TYPE_TOPIC);
$exchange-&gt;declareExchange();

$exchange-&gt;publish($message, $topic);
echo &quot;Message is sent: &quot; . $message . &quot;\n&quot;;
$connection-&gt;disconnect();
</code></pre>
<p><code>receive_logs_topic.php</code></p>
<pre><code class="language-php">&lt;?php
/**
 * 接收消息
 */

$exchangeName = 'topic_logs';
$topic = $argv[1];

// 建立TCP连接
$connection = new AMQPConnection([
    'host' =&gt; 'localhost',
    'port' =&gt; '5672',
    'vhost' =&gt; '/',
    'login' =&gt; 'guest',
    'password' =&gt; 'guest'
]);
$connection-&gt;connect() or die(&quot;Cannot connect to broker!\n&quot;);

$channel = new AMQPChannel($connection);

$exchange = new AMQPExchange($channel);
$exchange-&gt;setName($exchangeName);
$exchange-&gt;setType(AMQP_EX_TYPE_TOPIC);
$exchange-&gt;declareExchange();

$queue = new AMQPQueue($channel);
$queue-&gt;setFlags(AMQP_EXCLUSIVE);
$queue-&gt;declareQueue();
$queue-&gt;bind($exchangeName, $topic);

echo &quot;Waiting for logs...\n&quot;;
while (TRUE) {
    $queue-&gt;consume('processLogs');
}

$connection-&gt;disconnect();

function processLogs($envelope, $queue) {
    $logs = $envelope-&gt;getBody();
    var_dump(&quot;Received: &quot; . $logs);
    $queue-&gt;ack($envelope-&gt;getDeliveryTag()); // 手动发送ACK应答
}
</code></pre>
<h1 id="php-php-amqplib-库操作-rabbitmq">PHP php-amqplib 库操作 RabbitMQ</h1>
<h2 id="使用-composer-进行-rabbitmq-依赖安装">使用 composer 进行 rabbitmq 依赖安装</h2>
<pre><code class="language-shell">composer require php-amqplib/php-amqplib
</code></pre>
<h2 id="php-操作-rabbitmq-的简单示例">PHP 操作 RabbitMQ 的简单示例</h2>
<h3 id="生产者">生产者</h3>
<pre><code class="language-php">&lt;?php
require '../vendor/autoload.php';

$conf = [
    'host' =&gt; '127.0.0.1',
    'port' =&gt; 5672,
    'user' =&gt; 'guest',
    'pwd'  =&gt; 'guest',
    'vhost' =&gt; '/',
];

$exchangeName = 'kd_sms_send_ex'; // 交换机名
$queueName = 'kd_sms_send_q'; // 队列名称
$routingKey = 'sms_send'; // 路由关键字(也可以省略) 一般都带上方便交换机对消息进行不同队列的推送 如果绑定的时候使用了 $routingKey,那么在 bashic_publish 的时候也要指定 $routingKey，不然交换机无法路由到指定队列，默认就推送到不使用关键字的队列了

// 建立生产者与 mq 之间的连接
$conn = new \PhpAmqpLib\Connection\AMQPStreamConnection($conf['host'], $conf['port'], $conf['user'], $conf['pwd'], $conf['vhost']);
// 在已连接基础上建立生产者与 mq 之间的通道
$channel = $conn-&gt;channel();
/*
声明初始化交换机
参数说明：
exchange：交换机名称
type：交换机类型，常见的如fanout、direct、topic =》directirect 精准推送 fanout 广播 推送到绑定到此交换机下的所有队列 topic 组播 比如上面我绑定的关键字是sms_send，那么他可以推送到*.sms_send的所有队列
passive：只查询不创建.如果为true,如果存在这个队列,则会返回队列的信息.如果不存在这个队列..则会抛异常(与交换机不同的是,如果交换机判断存在,则返回NULL,否则异常)
durable：设置是否持久化。durable设置true表示持久化，反之是持久化。持久化可以将将换机存盘，在服务器重启时不会丢失相关信息
autoDelete：设置是否自动删除。autoDelete设置为true则表示自动删除。自动删除的前提是至少有一个队列或者交换机与这个交换器绑定的队列或者交换器都与之解绑
internal：设置是否内置的。如果设置为true，则表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式
argument：其他一些结构化参数，比如alternate-exchange
*/
$channel-&gt;exchange_declare($exchangeName, AMQP_EX_TYPE_DIRECT, false, false, false);
/*
声明初始化一条队列
参数说明：
queue：队列的名称
durable：设置是否持久化。为true则设置队列为持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息
exclusive：设置是否排他。为true则设置对列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意的三点：排他队列是基于连接可见，同一个连接的不同信道是可以同时访问同一个连接创建的排他队列；”首次“是指如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；即使该队列是持久华东，一旦连接关闭或者客户端退出，该排他队列都会自动被删除，这种队列适用于一个客户端同事发送和读取消息的应用场景
autoDelete：设置是否自动删除。为true则设置队列为自动删除。自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为：”当连接到此队列的所有客户端断开时，这个队列自动删除“，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列
arguments：设置队列的其他一些参数，如x-message-ttl等
*/
$channel-&gt;queue_declare($queueName, false, true, false, false);
// 将队列与某个交换机进行绑定，并使用路由关键字
$channel-&gt;queue_bind($queueName, $exchangeName, $routingKey);

//生成消息
$msgBody = json_encode([&quot;name&quot; =&gt; &quot;xiaomi&quot;, &quot;age&quot; =&gt; 18]);
// DELIVERY_MODE_PERSISTENT 2 消息持久化
$msg = new \PhpAmqpLib\Message\AMQPMessage($msgBody, ['content_type' =&gt; 'text/plain', 'delivery_mode' =&gt; \PhpAmqpLib\Message\AMQPMessage::DELIVERY_MODE_PERSISTENT]);
// 推送消息到某个交换机
$r = $channel-&gt;basic_publish($msg, $exchangeName, $routingKey);

// 关闭通道
$channel-&gt;close();
// 关闭连接
$conn-&gt;close();
</code></pre>
<h3 id="消费者">消费者</h3>
<pre><code class="language-php">&lt;?php
require '../vendor/autoload.php';

$conf = [
    'host' =&gt; '127.0.0.1',
    'port' =&gt; 5672,
    'user' =&gt; 'guest',
    'pwd' =&gt; 'guest',
    'vhost' =&gt; '/',
];

$exchangeName = 'kd_sms_send_ex'; // 交换机名
$queueName = 'kd_sms_send_q'; // 队列名称
$routingKey = 'sms_send'; // 路由关键字(也可以省略) 一般都带上方便交换机对消息进行不同队列的推送 如果绑定的时候使用了 $routingKey,那么在 bashic_publish 的时候也要指定 $routingKey，不然交换机无法路由到指定队列，默认就推送到不使用关键字的队列了

// 建立生产者与 mq 之间的连接
$conn = new \PhpAmqpLib\Connection\AMQPStreamConnection($conf['host'], $conf['port'], $conf['user'], $conf['pwd'], $conf['vhost']);
// 在已连接基础上建立生产者与 mq 之间的通道
$channel = $conn-&gt;channel();
// 对于正在繁忙的客户端，没有得到回应之前，不向其发送消息
$channel-&gt;basic_qos(null, 1, null);
/*
声明初始化交换机
参数说明：
exchange：交换机名称
type：交换机类型，常见的如fanout、direct、topic =》directirect 精准推送 fanout 广播 推送到绑定到此交换机下的所有队列 topic 组播 比如上面我绑定的关键字是sms_send，那么他可以推送到*.sms_send的所有队列
passive：只查询不创建.如果为true,如果存在这个队列,则会返回队列的信息.如果不存在这个队列..则会抛异常(与交换机不同的是,如果交换机判断存在,则返回NULL,否则异常)
durable：设置是否持久化。durable设置true表示持久化，反之是持久化。持久化可以将将换机存盘，在服务器重启时不会丢失相关信息
autoDelete：设置是否自动删除。autoDelete设置为true则表示自动删除。自动删除的前提是至少有一个队列或者交换机与这个交换器绑定的队列或者交换器都与之解绑
internal：设置是否内置的。如果设置为true，则表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式
argument：其他一些结构化参数，比如alternate-exchange
*/
$channel-&gt;exchange_declare($exchangeName, AMQP_EX_TYPE_DIRECT, false, false, false);
/*
声明初始化一条队列
参数说明：
queue：队列的名称
durable：设置是否持久化。为true则设置队列为持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息
exclusive：设置是否排他。为true则设置对列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意的三点：排他队列是基于连接可见，同一个连接的不同信道是可以同时访问同一个连接创建的排他队列；”首次“是指如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；即使该队列是持久华东，一旦连接关闭或者客户端退出，该排他队列都会自动被删除，这种队列适用于一个客户端同事发送和读取消息的应用场景
autoDelete：设置是否自动删除。为true则设置队列为自动删除。自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为：”当连接到此队列的所有客户端断开时，这个队列自动删除“，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列
arguments：设置队列的其他一些参数，如x-message-ttl等
*/
$channel-&gt;queue_declare($queueName, false, true, false, false);
// 将队列与某个交换机进行绑定，并使用路由关键字
$channel-&gt;queue_bind($queueName, $exchangeName, $routingKey);
echo '[*] Waiting for messages. To exit prss CTRL+C, ' . &quot;\n&quot;;
$callback = function ($msg) {
    echo date('Y-m-d H:i:s') . ' body is ' . $msg-&gt;body . &quot;\n&quot;;
    // 手动确认ack，确保消息已经处理 no_ack 为 false 需求手动确认
    $msg-&gt;getChannel()-&gt;basic_ack($msg-&gt;getDeliveryTag());
};
//
/*
开始队列消费，第四个参数表示服务端消费情况
参数说明：
queue：队列的名称
consumer_tag：消费者标签，用来区分多个消费者
no_local：这个功能属于AMQP的标准,但是rabbitMQ并没有做实现
no_ack：false 收到消息后,是否不需要回复确认即被认为被消费，如果未 true 这种情况表示生产者不关心数据是否处理完毕。如果A挂了
   A 当时的数据就丢掉
exclusive：是否排他
nowait：false 不返回执行结果,但是如果排他开启的话,则必须需要等待结果的,如果两个一起开就会报错
callback 回调函数
*/
$channel-&gt;basic_consume($queueName, '', false, false, false, false, $callback);

while (count($channel-&gt;callbacks)) {
    $channel-&gt;wait();
}

// 关闭通道
$channel-&gt;close();
// 关闭连接
$conn-&gt;close();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel 速查表]]></title>
        <id>http://weakcc.github.io/post/laravel-su-cha-biao/</id>
        <link href="http://weakcc.github.io/post/laravel-su-cha-biao/">
        </link>
        <updated>2021-11-11T06:09:21.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://learnku.com/docs/laravel-cheatsheet/8.x">Laravel速查表</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP 速查表]]></title>
        <id>http://weakcc.github.io/post/php-su-cha-biao/</id>
        <link href="http://weakcc.github.io/post/php-su-cha-biao/">
        </link>
        <updated>2021-11-10T10:03:53.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.p2hp.com/phpfuncs.html">PHP 速查表</a></p>
<h1 id="本地服务器">本地服务器</h1>
<pre><code class="language-php">php -S localhost:3000
</code></pre>
<h1 id="注释">注释</h1>
<pre><code class="language-php">// 单行注释

/*
这是一个多行注释块
跨越多行
*/
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.p2hp.com/phpfuncs.html">PHP 速查表</a></p>
<h1 id="本地服务器">本地服务器</h1>
<pre><code class="language-php">php -S localhost:3000
</code></pre>
<h1 id="注释">注释</h1>
<pre><code class="language-php">// 单行注释

/*
这是一个多行注释块
跨越多行
*/
</code></pre>
<!-- more -->
<h1 id="命名约定">命名约定</h1>
<h2 id="开始结束-标记">开始/结束 标记</h2>
<pre><code class="language-php">&lt;?php
  echo &quot;Hello World&quot;;
?&gt;
</code></pre>
<h2 id="如果没有结束标记文件的其余部分将被视为-php-代码">如果没有结束标记，文件的其余部分将被视为 PHP 代码</h2>
<pre><code class="language-php">&lt;?php
  echo &quot;Hello World&quot;;
</code></pre>
<h2 id="简短的-php-语法输出">简短的 PHP 语法输出</h2>
<pre><code class="language-php">&lt;?= &quot;Hello World&quot; ?&gt;
</code></pre>
<h2 id="启用严格模式-它必须在-php-文件的第一行">启用严格模式 (它必须在 PHP 文件的第一行)</h2>
<pre><code class="language-php">&lt;? declare(strict_types=1);
</code></pre>
<h2 id="包括一个-php-文件">包括一个 PHP 文件</h2>
<pre><code class="language-php">require 'app/Product.php'
</code></pre>
<h2 id="创建命名空间">创建命名空间</h2>
<pre><code class="language-php">namespace App;
</code></pre>
<h2 id="使用命名空间">使用命名空间</h2>
<pre><code class="language-php">use App\Product;
</code></pre>
<h2 id="小驼峰命名">小驼峰命名</h2>
<pre><code class="language-php">$firstName = 'Mike'

function updateProduct()
</code></pre>
<h2 id="大驼峰命名">大驼峰命名</h2>
<pre><code class="language-php">class ProductItem
</code></pre>
<h2 id="所有大写字母用下划线分隔">所有大写字母用下划线分隔</h2>
<pre><code class="language-php">const ACCESS_KEY = '123abc';
</code></pre>
<h1 id="输出-输入">输出 &amp; 输入</h1>
<h2 id="输出">输出</h2>
<pre><code class="language-php">echo 'Hello World';
</code></pre>
<h2 id="调式输出">调式输出</h2>
<pre><code class="language-php">var_dump($names);
print_r($products);
</code></pre>
<h2 id="从控制台输入">从控制台输入</h2>
<pre><code class="language-php">$name = readline('What is your name : ');
</code></pre>
<h1 id="变量声明">变量声明</h1>
<h2 id="字符串">字符串</h2>
<pre><code class="language-php">$name = 'Mike';
</code></pre>
<h2 id="布尔型">布尔型</h2>
<pre><code class="language-php">$isActive = true;
</code></pre>
<h2 id="整型">整型</h2>
<pre><code class="language-php">$number = 25;
</code></pre>
<h2 id="浮点型">浮点型</h2>
<pre><code class="language-php">$amount = 99.95;
</code></pre>
<h2 id="数组">数组</h2>
<pre><code class="language-php">$fruits = ['orange', 'apple', 'banana'];
</code></pre>
<h2 id="常量">常量</h2>
<pre><code class="language-php">const MAX_USERS = 50;

define('MAX_USERS', 50);
</code></pre>
<h2 id="赋值-引用-是通过-关键字">赋值 '引用' 是通过 &amp; 关键字</h2>
<pre><code class="language-php">$name_2 = &amp;$name_1;
</code></pre>
<h2 id="类型转换">类型转换</h2>
<pre><code class="language-php">$age = (int)readline('Your age: ');

echo 'Your age is' . (string)$age;
</code></pre>
<h2 id="获取变量类型">获取变量类型</h2>
<pre><code class="language-php">echo gettype($age); // int
</code></pre>
<h2 id="判断是否整形">判断是否整形</h2>
<pre><code class="language-php">echo is_int($age)
</code></pre>
<h2 id="判断是否浮点型">判断是否浮点型</h2>
<pre><code class="language-php">echo is_float($age)
</code></pre>
<h2 id="判断是否字符串">判断是否字符串</h2>
<pre><code class="language-php">echo is_string($age)
</code></pre>
<h1 id="字符串-2">字符串</h1>
<h2 id="单引号">单引号</h2>
<pre><code class="language-php">$name = 'Mike';
</code></pre>
<h2 id="双引号">双引号</h2>
<pre><code class="language-php">$name = &quot;Mike&quot;;
</code></pre>
<h2 id="双引号字符串能够使用转义字符-n-new-line-t-tab-backslash">双引号字符串能够使用转义字符 \n = new line  \t = tab  \ = backslash</h2>
<pre><code class="language-php">echo &quot;Hello Mike\nHello David&quot;;
</code></pre>
<h2 id="双引号字符串能够插入变量">双引号字符串能够插入变量</h2>
<pre><code class="language-php">echo &quot;Hello $name&quot;;
</code></pre>
<h2 id="字符串拼接">字符串拼接</h2>
<pre><code class="language-php">echo 'Hello ' . $name;
</code></pre>
<h2 id="字符串长度">字符串长度</h2>
<pre><code class="language-php">echo strlen($name);
</code></pre>
<h2 id="删除首部和尾部的空格">删除首部和尾部的空格</h2>
<pre><code class="language-php">echo trim($text);
</code></pre>
<h2 id="转换为小写">转换为小写</h2>
<pre><code class="language-php">echo strtolower($email);
</code></pre>
<h2 id="转换为大写">转换为大写</h2>
<pre><code class="language-php">echo strtoupper($email);
</code></pre>
<h2 id="将首字符转换为大写">将首字符转换为大写</h2>
<pre><code class="language-php">echo ucfirst($name);  // 'Mike' 
</code></pre>
<h2 id="替换-将-text-中的文本-a-替换成文本-b">替换 将 $text 中的文本 a 替换成文本 b</h2>
<pre><code class="language-php">echo str_replace('a', 'b', $text);
</code></pre>
<h2 id="字符串包含-php-8">字符串包含 (PHP 8)</h2>
<pre><code class="language-php">echo str_contains($name, 'ke')  # true
</code></pre>
<h2 id="查找-k-在字符串中第一次出现的位置">查找 &quot;k&quot; 在字符串中第一次出现的位置</h2>
<pre><code class="language-php">$pos = strpos($name, 'k');
</code></pre>
<h2 id="返回字符串的一部分-偏移量-长度">返回字符串的一部分 (偏移量 / 长度)</h2>
<pre><code class="language-php">echo substr($name, 0, $pos); # Mi
</code></pre>
<h1 id="数字">数字</h1>
<h2 id="快捷增加并赋值">快捷增加并赋值</h2>
<pre><code class="language-php">$value = 10;
$value++;
// or 
$value += 1;
</code></pre>
<h2 id="快捷减少并赋值">快捷减少并赋值</h2>
<pre><code class="language-php">$value = 10;
$value--;
// or 
$value -= 1;
</code></pre>
<h2 id="检查是否是数字">检查是否是数字</h2>
<pre><code class="language-php">echo is_numeric('59.99'); # true
</code></pre>
<h2 id="四舍五入">四舍五入</h2>
<pre><code class="language-php">echo round(0.80);  // returns 1
</code></pre>
<h2 id="精确地对数字进行四舍五入">精确地对数字进行四舍五入</h2>
<pre><code class="language-php">echo round(1.49356, 2));  // returns 1.49
</code></pre>
<h2 id="随机数">随机数</h2>
<pre><code class="language-php">echo(rand(10, 100)); # 89
</code></pre>
<h1 id="条件语句">条件语句</h1>
<h2 id="if-elseif-else">If / elseif / else</h2>
<pre><code class="language-php">if ($condition == 10) {
    echo 'condition 10'
} elseif  ($condition == 5) {
    echo 'condition 5'
} else {
    echo 'all other conditions'
}
</code></pre>
<h2 id="and-等于">And 等于 &amp;&amp;</h2>
<pre><code class="language-php">if ($condition === 10 &amp;&amp; $condition2 === 5) {
    echo '10 and 5'
}
</code></pre>
<h2 id="or-等于">Or 等于 ||</h2>
<pre><code class="language-php">if ($condition === 10 || $condition2 === 5) {
    echo '10 or 5'
}
</code></pre>
<h2 id="单行">单行</h2>
<pre><code class="language-php">if ($isActive) return true;
</code></pre>
<h2 id="检查-null-值">检查 null 值</h2>
<pre><code class="language-php">if (is_null($name)) {
    
}
</code></pre>
<h2 id="比较操作符">比较操作符</h2>
<pre><code class="language-php">== // 松散比较
=== // 严格比较
!= // 不等于
|| // 或
&amp;&amp; // 且
&gt; // 大于
&lt; // 小于
</code></pre>
<h2 id="三元运算-true-false">三元运算 (true : false)</h2>
<pre><code class="language-php">echo $isValid ? 'user valid' : 'user not valid';
</code></pre>
<h2 id="null-合并运算">null 合并运算</h2>
<pre><code class="language-php">echo $name ?? 'Mike';  //output 'Mike' if $name is null
</code></pre>
<h2 id="null-合并赋值">null 合并赋值</h2>
<pre><code class="language-php">$name ??= 'Mike';
</code></pre>
<h2 id="null-安全运算符php-8如果有一个为-null将返回-null">null 安全运算符（PHP 8）如果有一个？为 null，将返回 null</h2>
<pre><code class="language-php">echo $user?-&gt;profile?-&gt;activate();
</code></pre>
<h2 id="null-安全-null-合并-如果为-null-将返回-no-user-profile">null 安全 + null 合并 (如果为 null 将返回 『No user profile』)</h2>
<pre><code class="language-php">echo $user?-&gt;profile?-&gt;activate() ?? 'Not applicable';
</code></pre>
<h2 id="飞船符号-返回-1-0-1">飞船符号 返回 -1 0 1</h2>
<pre><code class="language-php">$names = ['Mike', 'Paul', 'John']
usort($names, function($a, $b) {
    return $a &lt;=&gt; $b;
}
// ['John', 'Mike', 'Paul']
</code></pre>
<h2 id="转换为布尔值时返回-false">转换为布尔值时返回 false</h2>
<pre><code class="language-php">false, 0, 0.0, null, unset, '0', '', []
</code></pre>
<h2 id="将同一变量与多个值进行比较">将同一变量与多个值进行比较</h2>
<pre><code class="language-php">switch ($color) {
    case 'red':
        echo 'The color is red';
         break;
    case 'yellow':
        echo 'The color is yellow';
        break;
    case 'red':
        echo 'The color is red';
        break;
    default:
        echo 'The color is unknown';
}
</code></pre>
<h2 id="match-表达式php-8">Match 表达式（PHP 8）</h2>
<pre><code class="language-php">$type = match($color) {
    'red' =&gt; 'danger',
    'yellow', 'orange' =&gt; 'warning',
    'green' =&gt; 'success',
    default =&gt; 'Unknown'
};
</code></pre>
<h2 id="检查变量是否声明">检查变量是否声明</h2>
<pre><code class="language-php">isset($color['red']);  # true
</code></pre>
<h1 id="循环和迭代">循环和迭代</h1>
<h2 id="for-循环">for 循环</h2>
<pre><code class="language-php">for ($i = 0; $i &lt; 20; $i++) {
    echo &quot;i value = &quot; . i;
}
</code></pre>
<h2 id="while-循环">while 循环</h2>
<pre><code class="language-php">$number = 1;
while ($number &lt; 10) {
    echo 'value : ' . $number ;
    $number += 1;
}
</code></pre>
<h2 id="do-while">do while</h2>
<pre><code class="language-php">$number = 1;
do {
    echo 'value : ' . $number ;
    $number += 1;
} while ($number &lt; 10);
</code></pre>
<h2 id="foreach-带有-break-continue-的示例">foreach 带有 break / continue 的示例</h2>
<pre><code class="language-php">$values = ['one', 'two', 'three'];
foreach ($values as $value) {
    if ($value === 'two') {
        break; // 退出循环
    } elseif ($value === 'three') {
        continue; // 下一个循环迭代
    }
}
</code></pre>
<h1 id="数组-2">数组</h1>
<h2 id="数组声明可以包含任何类型">数组声明可以包含任何类型</h2>
<pre><code class="language-php">$example = ['Mike', 50.2, true, ['10', '20'];
</code></pre>
<h2 id="数组声明">数组声明</h2>
<pre><code class="language-php">$names = ['Mike', 'Peter', 'Shawn', 'John'];
</code></pre>
<h2 id="直接访问特定元素">直接访问特定元素</h2>
<pre><code class="language-php">$name[1]
</code></pre>
<h2 id="如何访问数组中的数组元素">如何访问数组中的数组元素</h2>
<pre><code class="language-php">$example[3][1]
</code></pre>
<h2 id="将元素添加到数组">将元素添加到数组</h2>
<pre><code class="language-php">$names[] = 'Micheal';
</code></pre>
<h2 id="数组合并">数组合并</h2>
<pre><code class="language-php">$array3 = array_merge($array1, $array2);
</code></pre>
<h2 id="使用扩展运算符来进行数组合并">使用扩展运算符来进行数组合并</h2>
<pre><code class="language-php">$names = ['Mike', 'Peter', 'Paul'];
$people = ['John', ...$names]; // ['John', 'Mike', 'Peter', 'Paul']
</code></pre>
<h2 id="删除数组元素">删除数组元素</h2>
<pre><code class="language-php">unset($names['Peter']);
</code></pre>
<h2 id="数组转字符串">数组转字符串</h2>
<pre><code class="language-php">echo implode(', ', $names); // 输出 Mike, Shawn, John, Micheal
</code></pre>
<h2 id="字符串转数组">字符串转数组</h2>
<pre><code class="language-php">echo explode(',', $text); // ['Mike', 'Shawn', 'John']
</code></pre>
<h2 id="遍历数组元素">遍历数组元素</h2>
<pre><code class="language-php">foreach($names as $name) { 
   echo 'Hello ' . $name;
}
</code></pre>
<h2 id="数组中元素的个数">数组中元素的个数</h2>
<pre><code class="language-php">echo count($names);
</code></pre>
<h2 id="关联数组声明-key-value">关联数组声明 (key =&gt; value):</h2>
<pre><code class="language-php">$person = ['age' =&gt; 45, 'genre' =&gt; 'men'];
</code></pre>
<h2 id="添加到末尾-数组">添加到末尾. 数组:</h2>
<pre><code class="language-php">$person['name'] = 'Mike';
</code></pre>
<h2 id="循环数组-key-value">循环数组 key =&gt; value:</h2>
<pre><code class="language-php">foreach($names as $key =&gt; $value) { 
   echo $key . ' : ' . $value
}
</code></pre>
<h2 id="检查是否存在某个特定键">检查是否存在某个特定键</h2>
<pre><code class="language-php">echo array_key_exists('age', $person);
</code></pre>
<h2 id="返回键">返回键</h2>
<pre><code class="language-php">echo array_keys($person); // ['age', 'genre']
</code></pre>
<h2 id="返回值">返回值</h2>
<pre><code class="language-php">echo array_values($person) // [45, 'men']
</code></pre>
<h2 id="数组过滤器-返回过滤后的数组">数组过滤器 (返回过滤后的数组)</h2>
<pre><code class="language-php">$filteredPeople = array_filter($people, function ($person) {
    return $names-&gt;active;
})
</code></pre>
<h2 id="数组映射-返回变换后的数组">数组映射 (返回变换后的数组)</h2>
<pre><code class="language-php">$onlyNames = array_map(function($person) {
    return ['name' =&gt; $person-&gt;name];
}, $people)
</code></pre>
<h2 id="搜索关联数组">搜索关联数组</h2>
<pre><code class="language-php">$items = [
        ['id' =&gt; '100', 'name' =&gt; 'product 1'],
        ['id' =&gt; '200', 'name' =&gt; 'product 2'],
        ['id' =&gt; '300', 'name' =&gt; 'product 3'],
        ['id' =&gt; '400', 'name' =&gt; 'product 4'],
    ];
</code></pre>
<h2 id="在-name-列中搜索所有值">在 'name' 列中搜索所有值</h2>
<pre><code class="language-php">$found_key = array_search('product 3', array_column($items, 'name'));
</code></pre>
<h1 id="函数">函数</h1>
<h2 id="函数声明">函数声明</h2>
<pre><code class="language-php">function name($firstName, $lastName = 'defaultvalue') {
    return &quot;$firstName $lastName&quot;
}
</code></pre>
<h2 id="函数调用">函数调用</h2>
<pre><code class="language-php">name('Mike', 'Taylor');
</code></pre>
<h2 id="带命名参数的函数调用-php-8">带命名参数的函数调用 (PHP 8)</h2>
<pre><code class="language-php">name(firstName: 'Mike', lastName: 'Taylor'); // 排序能够改变
</code></pre>
<h2 id="函数可变数量参数">函数可变数量参数</h2>
<pre><code class="language-php">function name(...$params) {
    return $params[0] . “ “ . params[1];
}
</code></pre>
<h2 id="闭包函数">闭包函数</h2>
<pre><code class="language-php">Route::get('/', function () {
     return view('welcome');
});
</code></pre>
<h2 id="箭头函数">箭头函数</h2>
<pre><code class="language-php">Route::get('/', fn () =&gt; view('welcome');
</code></pre>
<h2 id="参数类型和返回类型">参数类型和返回类型</h2>
<pre><code class="language-php">function display(string $first, string $last) : string {
    return &quot;$first $last&quot;;
}
</code></pre>
<h2 id="类型或空值">类型或空值</h2>
<pre><code class="language-php">function display(?string $name) {
   
}
</code></pre>
<h1 id="文件">文件</h1>
<h2 id="获取当前目录">获取当前目录</h2>
<pre><code class="language-php">$current_dir = __DIR__;
</code></pre>
<h2 id="检查文件是否存在">检查文件是否存在</h2>
<pre><code class="language-php">if (file_exists('/posts/first.txt')) {
 
}
</code></pre>
<h2 id="读取文件内容到一个变量中">读取文件内容到一个变量中</h2>
<pre><code class="language-php">$post = file_get_contents($file);
</code></pre>
<h2 id="文件读取">文件读取</h2>
<pre><code class="language-php">$file = fopen(&quot;test.txt&quot;, &quot;r&quot;);
</code></pre>
<h2 id="输出行-直到-eof-结束">输出行, 直到 EOF 结束</h2>
<pre><code class="language-php">while(! feof($file)) {
  $line = fgets($file);
  echo $line. &quot;&lt;br&gt;&quot;;
}
fclose($file);
</code></pre>
<h2 id="文件写入">文件写入</h2>
<pre><code class="language-php">$file = fopen('export.csv', 'a');
$array = ['name' =&gt; 'Mike', 'age' =&gt; 45];
</code></pre>
<h2 id="将键名写为-csv-标题">将键名写为 CSV 标题</h2>
<pre><code class="language-php">fputcsv($file, array_keys($array[0]));
</code></pre>
<h2 id="写入行-格式为-csv">写入行 (格式为 csv)</h2>
<pre><code class="language-php">foreach ($array as $row) {
    fputcsv($file, $row); 
}
fclose($file);
</code></pre>
<h1 id="errors">Errors</h1>
<h2 id="抛出错误">抛出错误</h2>
<pre><code class="language-php">if (someCondition) {
    throw new Exception('Data format error');
}
</code></pre>
<h2 id="捕获错误">捕获错误</h2>
<pre><code class="language-php">try {
  $db-&gt;checkData($data);
} catch (Exception $e) {
    echo $e-&gt;getMessage();
}
</code></pre>
<pre><code class="language-php">// 如果try catch都有return，按照正常执行，然后执行finally的逻辑，再返回对应的try 或者catch里执行return
// 如果try catch finally都有return，执行完finally的逻辑后，会调用finally的return
try {
  $db-&gt;checkData($data);
} catch (Exception $e) {
    echo $e-&gt;getMessage();
} finally {

}
</code></pre>
<h1 id="oop">OOP</h1>
<h2 id="类声明">类声明</h2>
<pre><code class="language-php">class Person 
{
}
</code></pre>
<h2 id="对象实例">对象实例</h2>
<pre><code class="language-php">$person = new Person
</code></pre>
<h2 id="类属性和构造方法">类属性和构造方法</h2>
<pre><code class="language-php">class Person 
{
   protected $firstName;
   protected $lastName;
   public function __construct($firstName, $lastName) {
        $this-&gt;firstName = $firstName;
        $this-&gt;lastName = $lastName
   }
}
</code></pre>
<h2 id="构造器属性提升php-8">构造器属性提升（PHP 8）</h2>
<pre><code class="language-php">class Person 
{
    public function __construct(protected $firstName, protected $lastName) 
    {

    }
}
</code></pre>
<h2 id="获取和设置">获取和设置</h2>
<pre><code class="language-php">class Person
{
    private $name;

    public function setName($name){
        if(!is_string($name)){
            throw new Exception('$name must be a string!');
        }
        $this-&gt;name = $name;
    }

    public function getName(){
        return $this-&gt;name;
    }
}
</code></pre>
<h2 id="静态构造方法">静态构造方法</h2>
<pre><code class="language-php">public static function create(...$params) {
    return new self($params)
}
$person = Person::create(‘Mike’, ‘Taylor’);
</code></pre>
<h2 id="静态方法">静态方法</h2>
<pre><code class="language-php">class greeting {
  public static function welcome() {
    echo &quot;Hello World!&quot;;
  }
}
</code></pre>
<h2 id="调用静态方法">调用静态方法</h2>
<pre><code class="language-php">greeting::welcome();
</code></pre>
<h2 id="静态方法调用">静态方法调用</h2>
<pre><code class="language-php">class greeting {
  public static function welcome() {
    echo &quot;Hello World!&quot;;
  }

  public function __construct() {
    static::welcome();
  }
}
new greeting();
</code></pre>
<h2 id="静态常量">静态常量</h2>
<pre><code class="language-php">class Connection
{
  const MAX_USER = 100;
}
echo Connection::MAX_USER # 100
</code></pre>
<h2 id="类继承">类继承</h2>
<pre><code class="language-php">class Customer extends Person
{
    public function name()
    {
        parent::name();
        echo 'Override method';  
    }
}
</code></pre>
<h2 id="self-关键字引用当前类不会像静态那样通过继承后期绑定修改">self 关键字引用当前类（不会像静态那样通过继承后期绑定修改）</h2>
<pre><code class="language-php">self::welcome();
</code></pre>
<h2 id="接口">接口</h2>
<pre><code class="language-php">interface Animal {
  public function makeSound();
}

class Cat implements Animal {
  public function makeSound() {
    echo &quot;Meow&quot;;
  }
}
$animal = new Cat();
$animal-&gt;makeSound();
</code></pre>
<h2 id="trait-mix-in">Trait (mix-in)</h2>
<pre><code class="language-php">trait HelloWorld {
    public function sayHello() {
        echo 'Hello World!';
    }
}
class Greetings {
    use HelloWorld;
}
$object = new Greetings();
$object-&gt;sayHello();
</code></pre>
<blockquote>
<p>https://learnku.com/php/t/62217</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go 操作MySQL]]></title>
        <id>http://weakcc.github.io/post/go-cao-zuo-mysql/</id>
        <link href="http://weakcc.github.io/post/go-cao-zuo-mysql/">
        </link>
        <updated>2021-11-03T08:44:38.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="下载依赖">下载依赖</h2>
<pre><code class="language-go">go get -u github.com/go-sql-driver/mysql
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="下载依赖">下载依赖</h2>
<pre><code class="language-go">go get -u github.com/go-sql-driver/mysql
</code></pre>
<!-- more -->
<h2 id="连接">连接</h2>
<pre><code class="language-go">package main

import (
	&quot;database/sql&quot;
	&quot;fmt&quot;

	_ &quot;github.com/go-sql-driver/mysql&quot;
)

var db *sql.DB

func initDB() (err error) {
	// 用户名:密码@tcp(ip:端口)/数据库名
	dsn := &quot;root:123456@tcp(127.0.0.1:3306)/go_test&quot;
	// Open 不会校验账号密码是否正确
	db, err = sql.Open(&quot;mysql&quot;, dsn)
	if err != nil {
		return
	}
	// 尝试与数据库建立连接（校验dsn是否正确）
	err = db.Ping()
	if err != nil {
		return
    }
	return nil
}

func main()  {
	err:= initDB()
	if err!= nil {
		fmt.Println(err)
		return
	}
	fmt.Println(&quot;连接成功！&quot;)
}
</code></pre>
<blockquote>
<p>其中 <code>sql.DB</code> 是表示连接的数据库对象（结构体实例），它保存了连接数据库相关的所有信息。它内部维护着一个具有零到多个底层连接的连接池，它可以安全地被多个 goroutine 同时使用</p>
</blockquote>
<h2 id="curd">CURD</h2>
<h3 id="插入">插入</h3>
<pre><code class="language-go">func insertRow()  {
	sqlStr := &quot;insert into user (name, age) values (?, ?)&quot;
	result, err := db.Exec(sqlStr, &quot;小晓&quot;, 11)
	if err != nil {
		fmt.Println(err)
		return
	}
	id, err := result.LastInsertId()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(id)
}
</code></pre>
<h3 id="查询">查询</h3>
<h4 id="单行查询">单行查询</h4>
<pre><code class="language-go">func queryRow()  {
	sqlStr := &quot;select id, name, age from user where id = ?&quot;
    var u user
    // 确保 QueryRow 之后调用 Scan 方法，否则持有的数据库链接不会被释放
	err := db.QueryRow(sqlStr, 1).Scan(&amp;u.id, &amp;u.name, &amp;u.age)
	if err != nil {
		fmt.Println(&quot;错误：&quot;, err)
		return
	}
	fmt.Println(u)
}
</code></pre>
<h4 id="多行查询">多行查询</h4>
<pre><code class="language-go">func queryRows()  {
	sqlStr := &quot;select id, name, age from user where id &gt;= ?&quot;
	rows, err := db.Query(sqlStr, 1)
	if err != nil {
		fmt.Println(err)
	}
	// 关闭 rows 释放持有的数据库链接
	defer rows.Close()

	// 循环读取结果集中的数据
	for rows.Next() {
		var u user
		err := rows.Scan(&amp;u.id, &amp;u.name, &amp;u.age)
		if err != nil {
			fmt.Println(&quot;错误：&quot;, err)
			return
		}
		fmt.Println(u)
	}
}
</code></pre>
<h3 id="更新">更新</h3>
<pre><code class="language-go">func updateRow()  {
	sqlStr := &quot;update user set age = ? where id &gt; ?&quot;
	result, err := db.Exec(sqlStr, 12, 2)
	if err != nil {
		fmt.Println(err)
		return
	}
	n, err := result.RowsAffected() // 操作受影响的行数
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(n)
}
</code></pre>
<h3 id="删除数据">删除数据</h3>
<pre><code class="language-go">func deleteRow()  {
	sqlStr := &quot;delete from user where id = ?&quot;
	result, err := db.Exec(sqlStr, 4)
	if err != nil {
		fmt.Println(err)
		return
	}
	n, err := result.RowsAffected()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(n)
}
</code></pre>
<h2 id="预处理">预处理</h2>
<p>防止 <code>SQL 注入</code></p>
<h3 id="查询-2">查询</h3>
<pre><code class="language-go">func prepareQuery()  {
	sqlStr := &quot;select id, name, age from user where id &gt;= ?&quot;
	stmt, err := db.Prepare(sqlStr)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer stmt.Close()
	rows, err := stmt.Query(1)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer rows.Close()
	for rows.Next() {
		var u user
		err := rows.Scan(&amp;u.id, &amp;u.name, &amp;u.age)
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Println(u)
	}
}
</code></pre>
<h3 id="插入更新删除类似">插入，更新，删除类似</h3>
<pre><code class="language-go">func prepareInsert() {
	sqlStr := &quot;insert into user(name, age) values (?, ?)&quot;
	stmt, err := db.Prepare(sqlStr)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer stmt.Close()
	_, err = stmt.Exec(&quot;小爱&quot;, 5)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(&quot;success&quot;)
}
</code></pre>
<h2 id="事务">事务</h2>
<pre><code class="language-go">func transactionDemo()  {
	tx, err := db.Begin() // 开启事务
	if err != nil {
		if tx != nil {
			tx.Rollback() // 回滚
		}
		fmt.Println(err)
		return
	}
	sqlStr1 := &quot;update user set age = 18 where id = ?&quot;
	result1, err := tx.Exec(sqlStr1, 2)
	if err != nil {
		tx.Rollback()
		fmt.Println(err)
		return
	}
	n1, err := result1.RowsAffected()
	if err != nil {
		tx.Rollback()
		fmt.Println(err)
		return
	}
	sqlStr2 := &quot;update user set age = 18 where id = ?&quot;
	result2, err := tx.Exec(sqlStr2, 1)
	if err != nil {
		tx.Rollback()
		fmt.Println(err)
		return
	}
	n2, err := result2.RowsAffected()
	if err != nil {
		tx.Rollback()
		fmt.Println(err)
		return
	}
	fmt.Println(n1, n2)
	if 1 == n1 &amp;&amp; 1 == n2 {
		tx.Commit() // 提交
	} else {
		tx.Rollback()
	}
}
</code></pre>
]]></content>
    </entry>
</feed>