<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2021-05-14T09:43:32.406Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[jupyter 基本使用]]></title>
        <id>http://weakcc.github.io/post/jupyter-ji-ben-shi-yong/</id>
        <link href="http://weakcc.github.io/post/jupyter-ji-ben-shi-yong/">
        </link>
        <updated>2021-05-14T08:58:12.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="服务启动与停止-cmd">服务启动与停止（ CMD ）</h3>
<pre><code>- 启动 jupyter notebook
- 停止 Control + C</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h3 id="服务启动与停止-cmd">服务启动与停止（ CMD ）</h3>
<pre><code>- 启动 jupyter notebook
- 停止 Control + C
</code></pre>
<!-- more -->
<h3 id="cell-两种模式">cell 两种模式</h3>
<pre><code>- code     : 编写代码 ( y 修改为 code 模式 )
- markdown : 编写笔记 ( m 修改为 markdown 模式 )
</code></pre>
<h3 id="模式切换">模式切换</h3>
<pre><code>- 当前 cell 侧边为蓝色时，表示此时为命令模式，按 Enter 切换为编辑模式
- 当前 cell 侧边为绿色时，表示此时为编辑模式，按 Esc 切换为命令模式
</code></pre>
<h3 id="快捷键">快捷键</h3>
<pre><code>- a 在上方新建 cell
- b 在下方新建 cell
- x 删除
- y 修改为 code 模式
- m 修改为 markdown 模式
- shift + enter 运行当前 cell 并跳转到下一个 cell
- command + enter 运行当前 cell 
- tab 自动补全
- shift + tab 打开帮助文档
- dd 删除当前 cell
- z 撤销删除</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 8.0 安装与配置]]></title>
        <id>http://weakcc.github.io/post/mysql-80-bi-zhi-bi-hui/</id>
        <link href="http://weakcc.github.io/post/mysql-80-bi-zhi-bi-hui/">
        </link>
        <updated>2021-05-14T01:17:17.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="安装与配置">安装与配置</h1>
<p>MySQL 8.0 下载地址</p>
<pre><code>https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="安装与配置">安装与配置</h1>
<p>MySQL 8.0 下载地址</p>
<pre><code>https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz
</code></pre>
<!-- more -->
<h2 id="下载">下载</h2>
<pre><code>wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz
</code></pre>
<h2 id="解压">解压</h2>
<pre><code># 将文件改为tar格式
xz -d mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz
# 解压tar文件
tar xf mysql-8.0.15-linux-glibc2.12-x86_64.tar
</code></pre>
<h2 id="移动">移动</h2>
<p>移动到 <code>/usr/local/mysql</code></p>
<pre><code>mv mysql-8.0.15-linux-glibc2.12-x86_64 /usr/local/mysql
</code></pre>
<p>安全保障新建一个账户 <code>mysql</code></p>
<pre><code># 名字自取，配置文件别忘记同步更新
adduser mysql
</code></pre>
<h2 id="配置">配置</h2>
<p>更新配置文件信息</p>
<pre><code>vim /etc/my.cnf
</code></pre>
<p>配置内容如下</p>
<pre><code>[client]
port            = 3306
socket          = /usr/local/mysql/data/mysql.sock
[mysqld]
# Skip #
skip_name_resolve              = 1
skip_external_locking          = 1 
skip_symbolic_links     = 1
# GENERAL #
user = mysql
default_storage_engine = InnoDB
character-set-server = utf8
socket  = /usr/local/mysql/data/mysql.sock
pid_file = /usr/local/mysql/data/mysqld.pid
basedir = /usr/local/mysql
port = 3306
bind-address = 0.0.0.0
explicit_defaults_for_timestamp = off
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
#read_only=on
# MyISAM #
key_buffer_size                = 32M
#myisam_recover                 = FORCE,BACKUP

# undo log #
innodb_undo_directory = /usr/local/mysql/undo
innodb_undo_tablespaces = 8

# SAFETY #
max_allowed_packet             = 100M
max_connect_errors             = 1000000
sysdate_is_now                 = 1
#innodb = FORCE
#innodb_strict_mode = 1
secure-file-priv='/tmp'
default_authentication_plugin='mysql_native_password'
# Replice #
 server-id = 1001
 relay_log = mysqld-relay-bin
 gtid_mode = on
 enforce-gtid-consistency
 log-slave-updates = on
 master_info_repository =TABLE
 relay_log_info_repository =TABLE


# DATA STORAGE #
 datadir = /usr/local/mysql/data/
 tmpdir = /tmp
 
# BINARY LOGGING #
 log_bin = /usr/local/mysql/sql_log/mysql-bin
 max_binlog_size = 1000M
 binlog_format = row
 binlog_expire_logs_seconds=86400
# sync_binlog = 1

 # CACHES AND LIMITS #
 tmp_table_size                 = 32M
 max_heap_table_size            = 32M
 max_connections                = 4000
 thread_cache_size              = 2048
 open_files_limit               = 65535
 table_definition_cache         = 4096
 table_open_cache               = 4096
 sort_buffer_size               = 2M
 read_buffer_size               = 2M
 read_rnd_buffer_size           = 2M
# thread_concurrency             = 24
 join_buffer_size = 1M
# table_cache = 32768
 thread_stack = 512k
 max_length_for_sort_data = 16k


 # INNODB #
 innodb_flush_method            = O_DIRECT
 innodb_log_buffer_size = 16M
 innodb_flush_log_at_trx_commit = 2
 innodb_file_per_table          = 1
 innodb_buffer_pool_size        = 256M
 #innodb_buffer_pool_instances = 8
 innodb_stats_on_metadata = off
 innodb_open_files = 8192
 innodb_read_io_threads = 16
 innodb_write_io_threads = 16
 innodb_io_capacity = 20000
 innodb_thread_concurrency = 0
 innodb_lock_wait_timeout = 60
 innodb_old_blocks_time=1000
 innodb_use_native_aio = 1
 innodb_purge_threads=1
 innodb_change_buffering=all
 innodb_log_file_size = 64M
 innodb_log_files_in_group = 2
 innodb_data_file_path  = ibdata1:256M:autoextend
 
 innodb_rollback_on_timeout=on
 # LOGGING #
 log_error                      = /usr/local/mysql/sql_log/mysql-error.log
 # log_queries_not_using_indexes  = 1
 # slow_query_log                 = 1
  slow_query_log_file            = /usr/local/mysql/sql_log/slowlog.log

 # TimeOut #
 #interactive_timeout = 30
 #wait_timeout        = 30
 #net_read_timeout = 60

[mysqldump]
quick
max_allowed_packet = 100M

[mysql]
no-auto-rehash
# Remove the next comment character if you are not familiar with SQL
#safe-updates

[myisamchk]
key_buffer_size = 256M
sort_buffer_size = 256M
read_buffer = 2M
write_buffer = 2M

[mysqlhotcopy]
interactive-timeout
</code></pre>
<p>建立各种文件存储文件同时赋予 <code>mysql</code> 权限</p>
<pre><code>cd /usr/local/mysql/

mkdir data undo sql_log

# 赋予 mysql 属主
chown mysql:mysql data/ undo/ sql_log/
</code></pre>
<p>配置环境 <code>/ect/profile</code> 变量方便 <code>mysql</code> 启动</p>
<pre><code># 末尾添加
export PATH=$PATH:/usr/local/mysql/bin
# 更新配置source /etc/profile
</code></pre>
<h2 id="初始化">初始化</h2>
<pre><code>mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
</code></pre>
<p>把启动 <code>mysql.sever</code> 移动到 <code>/etc/init.d</code> 中</p>
<pre><code>cp support-files/mysql.server /etc/init.d/mysqld
</code></pre>
<h2 id="启动">启动</h2>
<pre><code>/etc/init.d/mysqld start
# 查看进程状态
ps -ef | grep mysql
</code></pre>
<h2 id="登录">登录</h2>
<p>登录 <code>mysql</code></p>
<pre><code>cat sql_log/mysql-error.log | grep password
# [Note] [MY-010454] [Server] A temporary password is generated for root@localhost:Py1Olku2-u8v
# Py1Olku2-u8v 就为初始的临时密码# 连接 mysqlmysql -uroot -pPy1Olku2-u8v
</code></pre>
<p>重置密码</p>
<pre><code>alter user user() identified by '123456';
# 密码线上需要复杂些，这本地测试
# 退出，重新登录
mysql -uroot -p123456
# 成功登录，结束
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[消息队列]]></title>
        <id>http://weakcc.github.io/post/xiao-xi-dui-lie/</id>
        <link href="http://weakcc.github.io/post/xiao-xi-dui-lie/">
        </link>
        <updated>2021-03-16T00:48:30.000Z</updated>
        <content type="html"><![CDATA[<p><code>消息（Message）</code>：传输的数据。<br>
<code>队列（Queue）</code>：队列是一种先进先出的数据结构。<br>
<code>消息队列</code>是消息的传输过程中保存消息的容器，也可以简单理解为：<b>把要传输的数据放在队列中</b>。</p>
<p>一般来说，<b>消息队列是一种异步的服务间通信方式，是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构</b>。使用较多的消息队列有<code>RocketMQ</code>、<code>RabbitMQ</code>、<code>Kafka</code>等。</p>
<blockquote>
<p>生产者：把数据放到消息队列叫做生产者<br>
消费者：从消息队列里边取数据叫做消费者</p>
</blockquote>
<h1 id="为什么要用消息队列消息队列的应用场景">为什么要用消息队列（消息队列的应用场景）</h1>
<p>常用应用场景：解耦、异步、削峰</p>
<h2 id="解耦">解耦</h2>
<p>应用耦合：<b>多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败</b></p>
<p>系统未解耦：以电商应用为例，用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障或者因为升级等原因暂时不可用，都会造成下单异常，影响用户体验。（图1-1）</p>
<p>系统解耦：使用消息队列解耦合，比如物流系统发生故障，需要几分钟才能修复，在这段时间内，物流系统要处理的数据被缓存到消息队列中，用户的下单操作正常完成。当物流系统恢复后，补充处理被缓存到消息队列中的订单数据，终端系统感知不到物流系统发生的故障。（图1-2）<br>
<img src="http://weakcc.github.io/post-images/1615859297884.png" alt="" loading="lazy"><br>
当订单系统不需要物流系统时，不用消息队列需要来回修改耦合的代码，用 MQ 后只需在物流系统消费者处不在接收订单队列信息即可。降低了人工成本，代码便于维护。</p>
<h2 id="异步">异步</h2>
<p>异步处理：<b>多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间</b></p>
<p>系统未异步：A 系统接收一个请求，需要在自己本地写库，还需要在B、C、D三个系统写库，自己本地写库要 3ms，B、C、D三个系统写库分别要 300ms、450ms、200ms。最终请求总延迟是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户体验很差，一般的互联网企业，对于用户的直接操作，容忍必须要 200ms 以内，对用户是无感知的，用户通过浏览器发起请求，等待 1s，这个几乎是无法接受的。（图1-1）</p>
<p>系统异步：如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假设耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长为 5 + 3 = 8ms，响应速度大大提升，改善了用户的体验。（图1-2）<br>
<img src="http://weakcc.github.io/post-images/1615860664817.png" alt="" loading="lazy"></p>
<h2 id="削峰">削峰</h2>
<p>限流削峰：<b>广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况</b></p>
<p>应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮（图1-1）。有了消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以大大提升系统的稳定性和用户体验（图1-2）。</p>
<p>一般情况，为了保证系统的稳定性，如果系统负载超过阈值，就会阻止用户请求，这会影响用户体验，而如果使用消息队列将请求缓存起来，等待系统处理完毕后通知用户下单完成，这样下单体验也好点。</p>
<p>业务系统正常时段的 QPS 如果是1K，流量最高峰是10K，为了应对流量高峰配置高性能的服务器显然不划算，这时可以使用消息队列对峰值流量进行削峰。<br>
<img src="http://weakcc.github.io/post-images/1615870854381.png" alt="" loading="lazy"></p>
<h1 id="各种消息队列产品的比较">各种消息队列产品的比较</h1>
<h1 id="消息队列的优点和缺点">消息队列的优点和缺点</h1>
<h1 id="如何保证消息队列的高可用">如何保证消息队列的高可用</h1>
<h1 id="如何保证消息不丢失">如何保证消息不丢失</h1>
<h1 id="如何保证消息不被重复消费如何保证消息消费的幂等性">如何保证消息不被重复消费（如何保证消息消费的幂等性）</h1>
<h1 id="如何保证消息消费的顺序性">如何保证消息消费的顺序性</h1>
<h1 id="基于-mq-的分布式事务实现">基于 MQ 的分布式事务实现</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Laradock 搭建基于 Docker 的 PHP 开发环境]]></title>
        <id>http://weakcc.github.io/post/shi-yong-laradock-da-jian-ji-yu-docker-de-php-kai-fa-huan-jing/</id>
        <link href="http://weakcc.github.io/post/shi-yong-laradock-da-jian-ji-yu-docker-de-php-kai-fa-huan-jing/">
        </link>
        <updated>2021-03-15T07:31:19.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="首先将-laradock-项目代码克隆到本地">首先将 Laradock 项目代码克隆到本地</h1>
<pre><code class="language-shell">git clone https://github.com/Laradock/laradock.git
</code></pre>
<h1 id="进入-laradock-目录将-env-example-重命名为-env">进入 laradock 目录将 env-example 重命名为 .env</h1>
<pre><code class="language-shell">cp env-example .env
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="首先将-laradock-项目代码克隆到本地">首先将 Laradock 项目代码克隆到本地</h1>
<pre><code class="language-shell">git clone https://github.com/Laradock/laradock.git
</code></pre>
<h1 id="进入-laradock-目录将-env-example-重命名为-env">进入 laradock 目录将 env-example 重命名为 .env</h1>
<pre><code class="language-shell">cp env-example .env
</code></pre>
<!-- more -->
<p>编辑<code>.env</code>文件</p>
<pre><code># 编辑
APP_CODE_PATH_HOST=../ # 项目路径
CHANGE_SOURCE=true # 切换源
WORKSPACE_TIMEZONE=PRC # 时区
PHP_VERSION=7.3
MYSQL_VERSION=8.0
# 新增
DB_HOST=mysql
REDIS_HOST=redis
QUEUE_HOST=beanstalkd
</code></pre>
<h1 id="运行容器">运行容器</h1>
<pre><code class="language-shell">docker-compose up -d nginx mysql redis beanstalkd
</code></pre>
<h1 id="创建项目">创建项目</h1>
<pre><code class="language-shell">composer create-project --prefer-dist laravel/laravel test
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1615796925712.png" alt="" loading="lazy"></figure>
<h1 id="做-nginx-配置">做 nginx 配置</h1>
<p><img src="http://weakcc.github.io/post-images/1615797075338.png" alt="" loading="lazy"><br>
<img src="http://weakcc.github.io/post-images/1615797081492.png" alt="" loading="lazy"><br>
重启 nginx</p>
<pre><code class="language-shell">docker-compose up -d nginx
</code></pre>
<p>就可以通过浏览器访问了。</p>
<h1 id="错误">错误</h1>
<p>问题：<br>
ERROR: for nginx  Cannot start service nginx: Ports are not available: port is already allocated.<br>
<img src="http://weakcc.github.io/post-images/1615794973501.png" alt="" loading="lazy"><br>
解决：<br>
指定80端口已经被占用，关闭相应的服务再重新运行上述命令即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker 安装并配置 Redis]]></title>
        <id>http://weakcc.github.io/post/docker-an-zhuang-bing-pei-zhi-redis/</id>
        <link href="http://weakcc.github.io/post/docker-an-zhuang-bing-pei-zhi-redis/">
        </link>
        <updated>2021-03-15T04:35:01.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="选择一个合适的-docker-版本">选择一个合适的 docker 版本</h1>
<p><a href="https://hub.docker.com/_/redis?tab=tags&amp;page=1&amp;ordering=last_updated">https://hub.docker.com/_/redis?tab=tags&amp;page=1&amp;ordering=last_updated</a></p>
<!-- more -->
<h1 id="使用-docker-安装-redis">使用 docker 安装 redis</h1>
<pre><code class="language-shell">sudo docker pull redis
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1615783536958.png" alt="" loading="lazy"></figure>
<h1 id="准备-redis-的配置文件">准备 redis 的配置文件</h1>
<p>redis 中文官方网站：<a href="http://www.redis.cn/download.html">http://www.redis.cn/download.html</a><br>
<img src="http://weakcc.github.io/post-images/1615783307536.png" alt="" loading="lazy"><br>
解压<br>
<img src="http://weakcc.github.io/post-images/1615783445135.png" alt="" loading="lazy"></p>
<h1 id="修改-redisconf-配置文件">修改 redis.conf 配置文件</h1>
<ul>
<li>bind 127.0.0.1 # 注释掉，使 redis 可以外部访问</li>
<li>daemonize no # 用守护线程的方式启动</li>
<li>requirepass 你的密码 # 给 redis 设置密码</li>
<li>appendonly yes # redis 持久化开启</li>
</ul>
# 创建本地与 docker 映射的目录
```shell
sudo mkdir /data/redis
sudo mkdir /data/redis/data
```
<p>把配置文件<code>redis.conf</code>拷贝到刚才创建好的<code>/data/redis</code>目录下</p>
<h1 id="启动-docker">启动 docker</h1>
<pre><code class="language-shell">sudo docker run -p 6379:6379 --name redis -v /data/redis/redis.conf:/etc/redis/redis.conf  -v /data/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes
</code></pre>
<p>参数解释：</p>
<blockquote>
<p>-p 6379:6379:把容器内的6379端口映射到宿主机6379端口<br>
-v /data/redis/redis.conf:/etc/redis/redis.conf：把宿主机配置好的 redis.conf 放到容器内的这个位置中<br>
-v /data/redis/data:/data：把 redis 持久化的数据在宿主机内显示，做数据备份<br>
redis-server /etc/redis/redis.conf：这个是关键配置，让 redis 不是无配置启动，而是按照这个 redis.conf 的配置启动<br>
-appendonly yes：redis 启动后数据持久化</p>
</blockquote>
<h1 id="查看是否启动成功">查看是否启动成功</h1>
<p>是否启动成功</p>
<pre><code class="language-shell">sudo docker ps
</code></pre>
<p>查看一下日志（没有启动成功也可以通过日志查看原因）</p>
<pre><code>sudo docker logs redis
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://weakcc.github.io/post-images/1615784431566.png" alt="" loading="lazy"></figure>
<blockquote>
<p>https://blog.csdn.net/qq_17623363/article/details/106418353</p>
</blockquote>
]]></content>
    </entry>
</feed>