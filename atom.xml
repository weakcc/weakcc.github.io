<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2021-10-30T09:47:30.707Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[Selenium 从入门到放弃]]></title>
        <id>http://weakcc.github.io/post/selenium-cong-ru-men-dao-fang-qi/</id>
        <link href="http://weakcc.github.io/post/selenium-cong-ru-men-dao-fang-qi/">
        </link>
        <updated>2021-10-30T08:14:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装浏览器驱动">安装浏览器驱动</h1>
<p><a href="https://chromedriver.storage.googleapis.com/index.html">Chrome 浏览器驱动</a><br>
<a href="https://github.com/mozilla/geckodriver/releases">Firefox 浏览器驱动</a><br>
<a href="http://selenium-release.storage.googleapis.com/index.html">IE 浏览器驱动</a><br>
<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">Edge 浏览器驱动</a><br>
<a href="https://phantomjs.org/">PhantomJS 浏览器驱动</a><br>
<a href="https://github.com/operasoftware/operachromiumdriver/releases">Opera 浏览器驱动</a></p>
<p>测试</p>
<pre><code class="language-python">from selenium import webdriver

# Chrome浏览器
driver = webdriver.Chrome()
driver.get('https://www.baidu.com/')
</code></pre>
<h1 id="定位页面元素">定位页面元素</h1>
<h2 id="id-定位">id 定位</h2>
<pre><code class="language-html">&lt;input id=&quot;toolbar-search-input&quot; autocomplete=&quot;off&quot; type=&quot;text&quot; value=&quot;&quot; placeholder=&quot;C++难在哪里？&quot;&gt;
</code></pre>
<pre><code class="language-python">driver.find_element_by_id('toolbar-search-input')
</code></pre>
<h2 id="name-定位">name 定位</h2>
<pre><code class="language-html">&lt;meta name=&quot;keywords&quot; content=&quot;CSDN博客,CSDN学院,CSDN论坛,CSDN直播&quot;&gt;
</code></pre>
<pre><code class="language-python">driver.find_element_by_name(&quot;keywords&quot;)
</code></pre>
<h2 id="class-定位">class 定位</h2>
<pre><code class="language-html">&lt;div class=&quot;toolbar-search-container&quot;&gt;
</code></pre>
<pre><code class="language-python">driver.find_element_by_class_name(&quot;toolbar-search-container&quot;)
</code></pre>
<h2 id="tag-定位">tag 定位</h2>
<pre><code class="language-html">&lt;div class=&quot;toolbar-search-container&quot;&gt;
</code></pre>
<pre><code class="language-python">driver.find_element_by_tag_name(&quot;div&quot;)
</code></pre>
<h2 id="xpath-定位">xpath 定位</h2>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;...&lt;head/&gt;
  &lt;body&gt;
    &lt;div id=&quot;csdn-toolbar&quot;&gt;
      &lt;div class=&quot;toolbar-inside&quot;&gt;
        &lt;div class=&quot;toolbar-container&quot;&gt;
          &lt;div class=&quot;toolbar-container-left&quot;&gt;...&lt;/div&gt;
          &lt;div class=&quot;toolbar-container-middle&quot;&gt;
            &lt;div class=&quot;toolbar-search onlySearch&quot;&gt;
			&lt;div class=&quot;toolbar-search-container&quot;&gt;
				&lt;input id=&quot;toolbar-search-input&quot; autocomplete=&quot;off&quot; type=&quot;text&quot; value=&quot;&quot; placeholder=&quot;C++难在哪里？&quot;&gt;
</code></pre>
<pre><code class="language-python"># 绝对路径（层级关系）定位
driver.find_element_by_xpath(
	&quot;/html/body/div/div/div/div[2]/div/div/input[1]&quot;)

# 利用元素属性定位
driver.find_element_by_xpath(
	&quot;//*[@id='toolbar-search-input']&quot;))

# 层级+元素属性定位
driver.find_element_by_xpath(
	&quot;//div[@id='csdn-toolbar']/div/div/div[2]/div/div/input[1]&quot;)

# 逻辑运算符定位
driver.find_element_by_xpath(
	&quot;//*[@id='toolbar-search-input' and @autocomplete='off']&quot;)
</code></pre>
<h2 id="css-定位">css 定位</h2>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.class</td>
<td style="text-align:center">.toolbar-search-container</td>
<td style="text-align:center">选择 class = 'toolbar-search-container' 的所有元素</td>
</tr>
<tr>
<td style="text-align:center">#id</td>
<td style="text-align:center">#toolbar-search-input</td>
<td style="text-align:center">选择 id = 'toolbar-search-input' 的元素</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">选择所有元素</td>
</tr>
<tr>
<td style="text-align:center">element</td>
<td style="text-align:center">input</td>
<td style="text-align:center">选择所有 &lt;input&gt; 元素</td>
</tr>
<tr>
<td style="text-align:center">element&gt;element</td>
<td style="text-align:center">div&gt;input</td>
<td style="text-align:center">选择父元素为 &lt;div&gt; 的所有 &lt;input&gt; 元素</td>
</tr>
<tr>
<td style="text-align:center">element+element</td>
<td style="text-align:center">div+input</td>
<td style="text-align:center">选择同一级中在 &lt;div&gt; 之后的所有 &lt;input&gt; 元素</td>
</tr>
<tr>
<td style="text-align:center">[attribute=value]</td>
<td style="text-align:center">type='text'</td>
<td style="text-align:center">选择 type = 'text' 的所有元素</td>
</tr>
</tbody>
</table>
<pre><code class="language-python">driver.find_element_by_css_selector('#toolbar-search-input')
driver.find_element_by_css_selector('html&gt;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&gt;input')
</code></pre>
<h2 id="link-定位">link 定位</h2>
<p><code>link</code> 专门用来定位文本链接，假如要定位下面这一标签。</p>
<pre><code class="language-html">&lt;div class=&quot;practice-box&quot; data-v-04f46969=&quot;&quot;&gt;加入！每日一练&lt;/div&gt;
</code></pre>
<pre><code class="language-python">driver.find_element_by_link_text(&quot;加入！每日一练&quot;)
</code></pre>
<h2 id="partial_link-定位">partial_link 定位</h2>
<p><code>partial_link</code> 翻译过来就是“部分链接”，对于有些文本很长，这时候就可以只指定部分文本即可定位，同样使用刚才的例子。</p>
<pre><code class="language-html">&lt;div class=&quot;practice-box&quot; data-v-04f46969=&quot;&quot;&gt;加入！每日一练&lt;/div&gt;
</code></pre>
<pre><code class="language-python">driver.find_element_by_partial_link_text(&quot;加入&quot;)
</code></pre>
<h1 id="浏览器控制">浏览器控制</h1>
<h2 id="修改浏览器窗口大小">修改浏览器窗口大小</h2>
<p><code>webdriver</code> 提供 <code>set_window_size()</code> 方法来修改浏览器窗口的大小。</p>
<pre><code class="language-python">from selenium import webdriver

# Chrome浏览器
driver = webdriver.Chrome()
driver.get('https://www.csdn.net/')
# 设置浏览器浏览器的宽高为：600x800
driver.set_window_size(600, 800)
</code></pre>
<p>也可以使用 <code>maximize_window()</code> 方法可以实现浏览器全屏显示<br>
from selenium import webdriver</p>
<pre><code class="language-python"># Chrome浏览器
driver = webdriver.Chrome()
driver.get('https://www.csdn.net/')
# 设置浏览器浏览器的宽高为全屏
driver.maximize_window()
</code></pre>
<h2 id="浏览器前进后退">浏览器前进&amp;后退</h2>
<p><code>webdriver</code> 提供 <code>back</code> 和 <code>forward</code> 方法来实现页面的后退与前进</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()

# 访问CSDN首页
driver.get('https://www.csdn.net/')
sleep(2)
#访问CSDN个人主页
driver.get('https://blog.csdn.net/qq_43965708')
sleep(2)
#返回（后退）到CSDN首页
driver.back()
sleep(2)
#前进到个人主页
driver.forward()
</code></pre>
<h2 id="新的标签页打开">新的标签页打开</h2>
<p>如果想的话也可以在新的标签页中打开新的链接，但需要更改一下代码，执行 js 语句来打开新的标签。</p>
<pre><code class="language-python"># 在原页面打开
driver.get('https://blog.csdn.net/qq_43965708')

# 新标签中打开
js = &quot;window.open('https://blog.csdn.net/qq_43965708')&quot;
driver.execute_script(js)
</code></pre>
<h2 id="浏览器刷新">浏览器刷新</h2>
<p>可以使用 <code>refresh()</code> 来刷新当前页面。</p>
<pre><code class="language-python"># 刷新页面
driver.refresh()
</code></pre>
<h2 id="浏览器窗口切换">浏览器窗口切换</h2>
<p>在很多时候我们都需要用到窗口切换，比如：当我们点击注册按钮时，它一般会打开一个新的标签页，但实际上代码并没有切换到最新页面中，这时你如果要定位注册页面的标签就会发现定位不到，这时就需要将实际窗口切换到最新打开的那个窗口。我们先获取当前各个窗口的句柄，这些信息的保存顺序是按照时间来的，最新打开的窗口放在数组的末尾，这时我们就可以定位到最新打开的那个窗口了。</p>
<pre><code class="language-python"># 获取打开的多个窗口句柄
windows = driver.window_handles
# 切换到当前最新打开的窗口
driver.switch_to.window(windows[-1])
</code></pre>
<h2 id="常见操作">常见操作</h2>
<p>webdriver中的常见操作有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">send_keys()</td>
<td style="text-align:center">模拟输入指定内容</td>
</tr>
<tr>
<td style="text-align:center">clear()</td>
<td style="text-align:center">清除文本内容</td>
</tr>
<tr>
<td style="text-align:center">is_displayed()</td>
<td style="text-align:center">判断该元素是否可见</td>
</tr>
<tr>
<td style="text-align:center">get_attribute()</td>
<td style="text-align:center">获取标签属性值</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:center">返回元素的尺寸</td>
</tr>
<tr>
<td style="text-align:center">text</td>
<td style="text-align:center">返回元素文本</td>
</tr>
</tbody>
</table>
<p>🌰</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()

driver.get('https://www.csdn.net/')
sleep(2)
# 定位搜索输入框
text_label = driver.find_element_by_xpath('//*[@id=&quot;toolbar-search-input&quot;]')

# 在搜索框中输入 Dream丶Killer
text_label.send_keys('Dream丶Killer')

sleep(2)
# 清除搜索框中的内容
text_label.clear()

# 输出搜索框元素是否可见
print(text_label.is_displayed())
# 输出placeholder的值
print(text_label.get_attribute('placeholder'))

# 定位搜索按钮
button = driver.find_element_by_xpath('//*[@id=&quot;toolbar-search-button&quot;]/span')
# 输出按钮的大小
print(button.size)
# 输出按钮上的文本
print(button.text)

'''输出内容
True
python面试100问
{'height': 32, 'width': 28}
搜索
'''
</code></pre>
<h1 id="鼠标控制">鼠标控制</h1>
<p>在webdriver 中，鼠标操作都封装在ActionChains类中，常见方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">click()</td>
<td style="text-align:center">单击左键</td>
</tr>
<tr>
<td style="text-align:center">context_click()</td>
<td style="text-align:center">单击右键</td>
</tr>
<tr>
<td style="text-align:center">double_click()</td>
<td style="text-align:center">双击</td>
</tr>
<tr>
<td style="text-align:center">drag_and_drop()</td>
<td style="text-align:center">拖动</td>
</tr>
<tr>
<td style="text-align:center">move_to_element()</td>
<td style="text-align:center">鼠标悬停</td>
</tr>
<tr>
<td style="text-align:center">perform()</td>
<td style="text-align:center">执行所有ActionChains中存储的动作</td>
</tr>
</tbody>
</table>
<h2 id="单击左键">单击左键</h2>
<p>模拟完成单击鼠标左键的操作，一般点击进入子页面等会用到，左键不需要用到 <code>ActionChains</code> 。</p>
<pre><code class="language-python"># 定位搜索按钮
button = driver.find_element_by_xpath('//*[@id=&quot;toolbar-search-button&quot;]/span')
# 执行单击操作
button.click()
</code></pre>
<h2 id="单击右键">单击右键</h2>
<p>鼠标右击的操作与左击有很大不同，需要使用 <code>ActionChains</code> 。</p>
<pre><code class="language-python">from selenium.webdriver.common.action_chains import ActionChains

# 定位搜索按钮
button = driver.find_element_by_xpath('//*[@id=&quot;toolbar-search-button&quot;]/span')
# 右键搜索按钮
ActionChains(driver).context_click(button).perform()
</code></pre>
<h2 id="双击">双击</h2>
<p>模拟鼠标双击操作</p>
<pre><code class="language-python"># 定位搜索按钮
button = driver.find_element_by_xpath('//*[@id=&quot;toolbar-search-button&quot;]/span')
# 执行双击动作
ActionChains(driver).double_click(button).perform()
</code></pre>
<h2 id="拖动">拖动</h2>
<p>模拟鼠标拖动操作，该操作有两个必要参数</p>
<ul>
<li><strong>source</strong>：鼠标拖动的元素</li>
<li><strong>target</strong>：鼠标拖至并释放的目标元素</li>
</ul>
<pre><code class="language-python"># 定位要拖动的元素
source = driver.find_element_by_xpath('xxx')
# 定位目标元素
target = driver.find_element_by_xpath('xxx')
# 执行拖动动作
ActionChains(driver).drag_and_drop(source, target).perform()
</code></pre>
<h2 id="鼠标悬停">鼠标悬停</h2>
<p>模拟悬停的作用一般是为了显示隐藏的下拉框。</p>
<pre><code class="language-python"># 定位收藏栏
collect  = driver.find_element_by_xpath('//*[@id=&quot;csdn-toolbar&quot;]/div/div/div[3]/div/div[3]/a')

# 悬停至收藏标签处
ActionChains(driver).move_to_element(collect).perform()
</code></pre>
<h1 id="键盘控制">键盘控制</h1>
<p><code>webdriver</code> 中 <code>Keys</code> 类几乎提供了键盘上的所有按键方法，我们可以使用 <code>send_keys + Keys</code> 实现输出键盘上的组合按键如 “<strong>Ctrl + C</strong>”、“<strong>Ctrl + V</strong>” 等。</p>
<pre><code class="language-python">from selenium.webdriver.common.keys import Keys

# 定位输入框并输入文本
driver.find_element_by_id('xxx').send_keys('Dream丶killer')

# 模拟回车键进行跳转（输入内容后） 
driver.find_element_by_id('xxx').send_keys(Keys.ENTER)

# 使用 Backspace 来删除一个字符
driver.find_element_by_id('xxx').send_keys(Keys.BACK_SPACE)

# Ctrl + A 全选输入框中内容
driver.find_element_by_id('xxx').send_keys(Keys.CONTROL, 'a')

# Ctrl + C 复制输入框中内容
driver.find_element_by_id('xxx').send_keys(Keys.CONTROL, 'c')

# Ctrl + V 粘贴输入框中内容
driver.find_element_by_id('xxx').send_keys(Keys.CONTROL, 'v')
</code></pre>
<p>其他常见键盘操作：</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Keys.F1</td>
<td style="text-align:center">F1键</td>
</tr>
<tr>
<td style="text-align:center">Keys.SPACE</td>
<td style="text-align:center">空格</td>
</tr>
<tr>
<td style="text-align:center">Keys.TAB</td>
<td style="text-align:center">Tab键</td>
</tr>
<tr>
<td style="text-align:center">Keys.ESCAPE</td>
<td style="text-align:center">ESC键</td>
</tr>
<tr>
<td style="text-align:center">Keys.ALT</td>
<td style="text-align:center">Alt键</td>
</tr>
<tr>
<td style="text-align:center">Keys.SHIFT</td>
<td style="text-align:center">Shift键</td>
</tr>
<tr>
<td style="text-align:center">Keys.ARROW_DOWN</td>
<td style="text-align:center">向下箭头</td>
</tr>
<tr>
<td style="text-align:center">Keys.ARROW_LEFT</td>
<td style="text-align:center">向左箭头</td>
</tr>
<tr>
<td style="text-align:center">Keys.ARROW_RIGHT</td>
<td style="text-align:center">向右箭头</td>
</tr>
<tr>
<td style="text-align:center">Keys.ARROW_UP</td>
<td style="text-align:center">向上箭头</td>
</tr>
</tbody>
</table>
<blockquote>
<p>https://juejin.cn/post/7022925905395875847</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 safari 浏览器导出 Excel 文件后缀会加一个 .html]]></title>
        <id>http://weakcc.github.io/post/shi-yong-safari-liu-lan-qi-dao-chu-excel-wen-jian-hou-zhui-hui-jia-yi-ge-html/</id>
        <link href="http://weakcc.github.io/post/shi-yong-safari-liu-lan-qi-dao-chu-excel-wen-jian-hou-zhui-hui-jia-yi-ge-html/">
        </link>
        <updated>2021-10-28T02:45:52.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1635389216714.png" alt="" loading="lazy"></figure>
<p>解决办法</p>
<pre><code class="language-php">header(&quot;Pragma: public&quot;);  
header(&quot;Expires: 0&quot;);  
header(&quot;Cache-Control:must-revalidate, post-check=0, pre-check=0&quot;);  
header(&quot;Content-Type:application/force-download&quot;);  
header(&quot;Content-Type:application/vnd.ms-excel&quot;);  
header(&quot;Content-Type:application/octet-stream&quot;);  
header(&quot;Content-Type:application/download&quot;);;  
header('Content-Disposition:attachment;filename=&quot;'.$filename.'.xls&quot;');
header(&quot;Content-Transfer-Encoding:binary&quot;);
$objWriter-&gt;save('php://output');
exit;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP 动态语言静态化]]></title>
        <id>http://weakcc.github.io/post/php-dong-tai-yu-yan-jing-tai-hua/</id>
        <link href="http://weakcc.github.io/post/php-dong-tai-yu-yan-jing-tai-hua/">
        </link>
        <updated>2021-10-26T02:26:40.000Z</updated>
        <summary type="html"><![CDATA[<p>新建文件 <code>demo.php</code><br>
正常输出</p>
<pre><code class="language-php">&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
</code></pre>
<p>开启输出控制缓冲 <code>ob_start</code></p>
<pre><code class="language-php">&lt;?php
    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲
    var_dump($content);
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>新建文件 <code>demo.php</code><br>
正常输出</p>
<pre><code class="language-php">&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
</code></pre>
<p>开启输出控制缓冲 <code>ob_start</code></p>
<pre><code class="language-php">&lt;?php
    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲
    var_dump($content);
</code></pre>
<!--more-->
<p>把缓存写入文件</p>
<pre><code class="language-php">&lt;?php
    $cache_name = md5(__FILE__) . '.html';

    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲

    $handle = fopen($cache_name, 'w');
    fwrite($handle, $content);
    fclose($handle);
</code></pre>
<pre><code>var_dump($cache_name);
</code></pre>
<p>运行后生成临时文件 <code>xxxx.html</code> 缓存</p>
<p>关键缓存判断</p>
<pre><code class="language-php">&lt;?php
    $cache_name = md5(__FILE__) . '.html';
    $cache_lifetime = 3600;
    // filectime() 函数返回指定文件的上次修改时间
    if (file_exists($cache_name)
        &amp;&amp; filectime(__FILE__) &lt;= filectime($cache_name)
        &amp;&amp; filectime($cache_name) + $cache_lifetime &gt; time()) {
        // 缓存文件存在
        // 当前文件是否有修改（文件的修改时间小于缓存文件的修改问）
        // 缓存文件是否已经过期
        include $cache_name;
        exit;
    }

    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲

    $handle = fopen($cache_name, 'w');
    fwrite($handle, $content);
    fclose($handle);
</code></pre>
<p>根据不同的用户 <code>id</code> 做不同的缓存</p>
<pre><code class="language-php">&lt;?php
    $id = intval($_GET['id']);
    if (empty($id)) {
        $id = '';
    }

    $cache_name = md5(__FILE__) . '-' . $id .'.html';
    $cache_lifetime = 3600;
    // filectime() 函数返回指定文件的上次修改时间
    if (file_exists($cache_name)
        &amp;&amp; filectime(__FILE__) &lt;= filectime($cache_name)
        &amp;&amp; filectime($cache_name) + $cache_lifetime &gt; time()) {
        // 缓存文件存在
        // 当前文件是否有修改（文件的修改时间小于缓存文件的修改问）
        // 缓存文件是否已经过期
        include $cache_name;
        exit;
    }

    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本. &lt;?php echo $id?&gt;&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲

    $handle = fopen($cache_name, 'w');
    fwrite($handle, $content);
    fclose($handle);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[API 防篡改和防重放]]></title>
        <id>http://weakcc.github.io/post/api-fang-cuan-gai-he-fang-chong-fang/</id>
        <link href="http://weakcc.github.io/post/api-fang-cuan-gai-he-fang-chong-fang/">
        </link>
        <updated>2021-10-26T01:00:36.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="防篡改">防篡改</h1>
<p>签名校验</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="防篡改">防篡改</h1>
<p>签名校验</p>
<!-- more -->
<h1 id="防重防">防重防</h1>
<h2 id="timestampnonce">timestamp+nonce</h2>
<p>我们常用的防止重放的机制是使用 timestamp 和 nonce 来做的重放机制。</p>
<!-- more -->
<p>timestamp 用来表示请求的当前时间戳，这个时间戳当然要和服务器时间戳进行校正过的。我们预期正常请求带的 timestamp 参数会是不同的（预期是正常的人每秒至多只会做一个操作）。每个请求带的时间戳不能和当前时间超过一定规定的时间。比如 60s。这样，这个请求即使被截取了，你也只能在 60s 内进行重放攻击。过期失效。</p>
<p>但是这样也是不够的，还有给攻击者 60s 的时间。所以我们就需要使用一个 nonce，随机数。</p>
<p>nonce 是由客户端根据足够随机的情况生成的，比如 md5 (timestamp+rand (0, 1000)); 它就有一个要求，正常情况下，在短时间内（比如 60s）连续生成两个相同 nonce 的情况几乎为 0。</p>
<h2 id="服务端">服务端</h2>
<p>服务端第一次在接收到这个 nonce 的时候做下面行为：<br>
1 去 redis 中查找是否有 key 为 nonce:{nonce} 的 string<br>
2 如果没有，则创建这个 key，把这个 key 失效的时间和验证 timestamp 失效的时间一致，比如是 60s。<br>
3 如果有，说明这个 key 在 60s 内已经被使用了，那么这个请求就可以判断为重放请求。</p>
<blockquote>
<p>https://www.jianshu.com/p/de9295087560<br>
https://learnku.com/articles/4196/talk-about-the-anti-replay-mechanism-of-api</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP cURL]]></title>
        <id>http://weakcc.github.io/post/php-curl/</id>
        <link href="http://weakcc.github.io/post/php-curl/">
        </link>
        <updated>2021-10-26T00:54:38.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="curl">cURL</h1>
<h2 id="get">GET</h2>
<pre><code class="language-php">/**
 * @param string $url 请求 url
 * @param int $httpCode 状态码
 * @return mixed
 */
function curl_get($url, &amp;$httpCode = 404)
{
    // 初始化一个curl会话
    $ch = curl_init();

    // 需要获取的url地址
    curl_setopt($ch, CURLOPT_URL, $url);
    // 启用 返回原生的(raw)输出
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

    //不做证书校验,部署在linux环境下请改为true
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    // 在发起连接前等待的时间，如果设置为0，则无限等待
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);

    // 	执行一个curl会话
    $fileContents = curl_exec($ch);
    // 获取一个curl连接资源句柄的信息
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

    // 关闭一个curl会话
    curl_close($ch);
    return $fileContents;
}

$statusCode = 0;
var_dump(curl_get('http://www.baidu.com/', $statusCode));
var_dump($statusCode);
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="curl">cURL</h1>
<h2 id="get">GET</h2>
<pre><code class="language-php">/**
 * @param string $url 请求 url
 * @param int $httpCode 状态码
 * @return mixed
 */
function curl_get($url, &amp;$httpCode = 404)
{
    // 初始化一个curl会话
    $ch = curl_init();

    // 需要获取的url地址
    curl_setopt($ch, CURLOPT_URL, $url);
    // 启用 返回原生的(raw)输出
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

    //不做证书校验,部署在linux环境下请改为true
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    // 在发起连接前等待的时间，如果设置为0，则无限等待
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);

    // 	执行一个curl会话
    $fileContents = curl_exec($ch);
    // 获取一个curl连接资源句柄的信息
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

    // 关闭一个curl会话
    curl_close($ch);
    return $fileContents;
}

$statusCode = 0;
var_dump(curl_get('http://www.baidu.com/', $statusCode));
var_dump($statusCode);
</code></pre>
<!-- more -->
<h2 id="post">POST</h2>
<pre><code class="language-php">/**
 * @param string $url 请求 url
 * @param array $params 参数
 * @return mixed
 */
function curl_post(string $url, array $params = [])
{
    // 初始化一个curl会话
    $ch = curl_init();

    // 需要获取的url地址
    curl_setopt($ch, CURLOPT_URL, $url);
    // 启用时会将头文件的信息作为数据流输出
    curl_setopt($ch, CURLOPT_HEADER, 0);
    // 启用 返回原生的(raw)输出
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    //不做证书校验,部署在linux环境下请改为true
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    // 在发起连接前等待的时间，如果设置为0，则无限等待
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);
    // 启用时会发送一个常规的POST请求，类型为：application/x-www-form-urlencoded，就像表单提交的一样
    curl_setopt($ch, CURLOPT_POST, 1);
    // 全部数据使用HTTP协议中的&quot;POST&quot;操作来发送。要发送文件，在文件名前面加上@前缀并使用完整路径。这个参数可以通过urlencoded后的字符串类似'para1=val1&amp;para2=val2&amp;...'或使用一个以字段名为键值，字段数据为值的数组。如果value是一个数组，Content-Type头将会被设置成multipart/form-data
    // 传递一个数组到CURLOPT_POSTFIELDS，cURL会把数据编码成 multipart/form-data，而然传递一个URL-encoded字符串时，数据会被编码成 application/x-www-form-urlencoded
    curl_setopt($ch, CURLOPT_POSTFIELDS, $params);

    /*
    // 或者传递一个 json 类型 $params 要 json_encode() 转义
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Content-Type: application/json' // 一个用来设置HTTP头字段的数组
    ]);
    */
    // 	执行一个curl会话
    $contents = curl_exec($ch);
    // 关闭一个curl会话
    curl_close($ch);
    return $contents;
}

$url = 'xxxxx'; // 提交的 url
$data = array('name' =&gt; 'Foo', 'file' =&gt; '@/home/user/test.png');
var_dump(curl_post($url, $data));
</code></pre>
<h2 id="raw">Raw</h2>
<pre><code class="language-php">/**
 * @param string $url 请求 url
 * @param string $data 参数
 * @return mixed
 */
function curl_post_raw(string $url, string $data)
{
    // 初始化一个curl会话
    $ch = curl_init();

    // 需要获取的url地址
    curl_setopt($ch, CURLOPT_URL, $url);
    // 启用时会将头文件的信息作为数据流输出
    curl_setopt($ch, CURLOPT_HEADER, 0);
    // 启用 返回原生的(raw)输出
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    //不做证书校验,部署在linux环境下请改为true
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    // 在发起连接前等待的时间，如果设置为0，则无限等待
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);
    // 启用时会发送一个常规的POST请求，类型为：application/x-www-form-urlencoded，就像表单提交的一样
    curl_setopt($ch, CURLOPT_POST, 1);

    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
    // // 一个用来设置HTTP头字段的数组
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Content-Type: text'
    ]);
    // 	执行一个curl会话
    $contents = curl_exec($ch);
    // 关闭一个curl会话
    curl_close($ch);
    return $contents;
}
</code></pre>
<h2 id="可以访问请求的原始数据的只读流">可以访问请求的原始数据的只读流</h2>
<pre><code class="language-php">file_get_contents(&quot;php://input&quot;)
</code></pre>
]]></content>
    </entry>
</feed>