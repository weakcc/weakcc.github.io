<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2021-04-28T09:43:00.923Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[消息队列]]></title>
        <id>http://weakcc.github.io/post/xiao-xi-dui-lie/</id>
        <link href="http://weakcc.github.io/post/xiao-xi-dui-lie/">
        </link>
        <updated>2021-03-16T00:48:30.000Z</updated>
        <content type="html"><![CDATA[<p><code>消息（Message）</code>：传输的数据。<br>
<code>队列（Queue）</code>：队列是一种先进先出的数据结构。<br>
<code>消息队列</code>是消息的传输过程中保存消息的容器，也可以简单理解为：<b>把要传输的数据放在队列中</b>。</p>
<p>一般来说，<b>消息队列是一种异步的服务间通信方式，是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构</b>。使用较多的消息队列有<code>RocketMQ</code>、<code>RabbitMQ</code>、<code>Kafka</code>等。</p>
<blockquote>
<p>生产者：把数据放到消息队列叫做生产者<br>
消费者：从消息队列里边取数据叫做消费者</p>
</blockquote>
<h1 id="为什么要用消息队列消息队列的应用场景">为什么要用消息队列（消息队列的应用场景）</h1>
<p>常用应用场景：解耦、异步、削峰</p>
<h2 id="解耦">解耦</h2>
<p>应用耦合：<b>多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败</b></p>
<p>系统未解耦：以电商应用为例，用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障或者因为升级等原因暂时不可用，都会造成下单异常，影响用户体验。（图1-1）</p>
<p>系统解耦：使用消息队列解耦合，比如物流系统发生故障，需要几分钟才能修复，在这段时间内，物流系统要处理的数据被缓存到消息队列中，用户的下单操作正常完成。当物流系统恢复后，补充处理被缓存到消息队列中的订单数据，终端系统感知不到物流系统发生的故障。（图1-2）<br>
<img src="http://weakcc.github.io/post-images/1615859297884.png" alt="" loading="lazy"><br>
当订单系统不需要物流系统时，不用消息队列需要来回修改耦合的代码，用 MQ 后只需在物流系统消费者处不在接收订单队列信息即可。降低了人工成本，代码便于维护。</p>
<h2 id="异步">异步</h2>
<p>异步处理：<b>多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间</b></p>
<p>系统未异步：A 系统接收一个请求，需要在自己本地写库，还需要在B、C、D三个系统写库，自己本地写库要 3ms，B、C、D三个系统写库分别要 300ms、450ms、200ms。最终请求总延迟是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户体验很差，一般的互联网企业，对于用户的直接操作，容忍必须要 200ms 以内，对用户是无感知的，用户通过浏览器发起请求，等待 1s，这个几乎是无法接受的。（图1-1）</p>
<p>系统异步：如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假设耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长为 5 + 3 = 8ms，响应速度大大提升，改善了用户的体验。（图1-2）<br>
<img src="http://weakcc.github.io/post-images/1615860664817.png" alt="" loading="lazy"></p>
<h2 id="削峰">削峰</h2>
<p>限流削峰：<b>广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况</b></p>
<p>应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮（图1-1）。有了消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以大大提升系统的稳定性和用户体验（图1-2）。</p>
<p>一般情况，为了保证系统的稳定性，如果系统负载超过阈值，就会阻止用户请求，这会影响用户体验，而如果使用消息队列将请求缓存起来，等待系统处理完毕后通知用户下单完成，这样下单体验也好点。</p>
<p>业务系统正常时段的 QPS 如果是1K，流量最高峰是10K，为了应对流量高峰配置高性能的服务器显然不划算，这时可以使用消息队列对峰值流量进行削峰。<br>
<img src="http://weakcc.github.io/post-images/1615870854381.png" alt="" loading="lazy"></p>
<h1 id="各种消息队列产品的比较">各种消息队列产品的比较</h1>
<h1 id="消息队列的优点和缺点">消息队列的优点和缺点</h1>
<h1 id="如何保证消息队列的高可用">如何保证消息队列的高可用</h1>
<h1 id="如何保证消息不丢失">如何保证消息不丢失</h1>
<h1 id="如何保证消息不被重复消费如何保证消息消费的幂等性">如何保证消息不被重复消费（如何保证消息消费的幂等性）</h1>
<h1 id="如何保证消息消费的顺序性">如何保证消息消费的顺序性</h1>
<h1 id="基于-mq-的分布式事务实现">基于 MQ 的分布式事务实现</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Laradock 搭建基于 Docker 的 PHP 开发环境]]></title>
        <id>http://weakcc.github.io/post/shi-yong-laradock-da-jian-ji-yu-docker-de-php-kai-fa-huan-jing/</id>
        <link href="http://weakcc.github.io/post/shi-yong-laradock-da-jian-ji-yu-docker-de-php-kai-fa-huan-jing/">
        </link>
        <updated>2021-03-15T07:31:19.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="首先将-laradock-项目代码克隆到本地">首先将 Laradock 项目代码克隆到本地</h1>
<pre><code class="language-shell">git clone https://github.com/Laradock/laradock.git
</code></pre>
<h1 id="进入-laradock-目录将-env-example-重命名为-env">进入 laradock 目录将 env-example 重命名为 .env</h1>
<pre><code class="language-shell">cp env-example .env
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="首先将-laradock-项目代码克隆到本地">首先将 Laradock 项目代码克隆到本地</h1>
<pre><code class="language-shell">git clone https://github.com/Laradock/laradock.git
</code></pre>
<h1 id="进入-laradock-目录将-env-example-重命名为-env">进入 laradock 目录将 env-example 重命名为 .env</h1>
<pre><code class="language-shell">cp env-example .env
</code></pre>
<!-- more -->
<p>编辑<code>.env</code>文件</p>
<pre><code># 编辑
APP_CODE_PATH_HOST=../ # 项目路径
CHANGE_SOURCE=true # 切换源
WORKSPACE_TIMEZONE=PRC # 时区
PHP_VERSION=7.3
MYSQL_VERSION=8.0
# 新增
DB_HOST=mysql
REDIS_HOST=redis
QUEUE_HOST=beanstalkd
</code></pre>
<h1 id="运行容器">运行容器</h1>
<pre><code class="language-shell">docker-compose up -d nginx mysql redis beanstalkd
</code></pre>
<h1 id="创建项目">创建项目</h1>
<pre><code class="language-shell">composer create-project --prefer-dist laravel/laravel test
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1615796925712.png" alt="" loading="lazy"></figure>
<h1 id="做-nginx-配置">做 nginx 配置</h1>
<p><img src="http://weakcc.github.io/post-images/1615797075338.png" alt="" loading="lazy"><br>
<img src="http://weakcc.github.io/post-images/1615797081492.png" alt="" loading="lazy"><br>
重启 nginx</p>
<pre><code class="language-shell">docker-compose up -d nginx
</code></pre>
<p>就可以通过浏览器访问了。</p>
<h1 id="错误">错误</h1>
<p>问题：<br>
ERROR: for nginx  Cannot start service nginx: Ports are not available: port is already allocated.<br>
<img src="http://weakcc.github.io/post-images/1615794973501.png" alt="" loading="lazy"><br>
解决：<br>
指定80端口已经被占用，关闭相应的服务再重新运行上述命令即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker 安装并配置 Redis]]></title>
        <id>http://weakcc.github.io/post/docker-an-zhuang-bing-pei-zhi-redis/</id>
        <link href="http://weakcc.github.io/post/docker-an-zhuang-bing-pei-zhi-redis/">
        </link>
        <updated>2021-03-15T04:35:01.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="选择一个合适的-docker-版本">选择一个合适的 docker 版本</h1>
<p><a href="https://hub.docker.com/_/redis?tab=tags&amp;page=1&amp;ordering=last_updated">https://hub.docker.com/_/redis?tab=tags&amp;page=1&amp;ordering=last_updated</a></p>
<!-- more -->
<h1 id="使用-docker-安装-redis">使用 docker 安装 redis</h1>
<pre><code class="language-shell">sudo docker pull redis
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1615783536958.png" alt="" loading="lazy"></figure>
<h1 id="准备-redis-的配置文件">准备 redis 的配置文件</h1>
<p>redis 中文官方网站：<a href="http://www.redis.cn/download.html">http://www.redis.cn/download.html</a><br>
<img src="http://weakcc.github.io/post-images/1615783307536.png" alt="" loading="lazy"><br>
解压<br>
<img src="http://weakcc.github.io/post-images/1615783445135.png" alt="" loading="lazy"></p>
<h1 id="修改-redisconf-配置文件">修改 redis.conf 配置文件</h1>
<ul>
<li>bind 127.0.0.1 # 注释掉，使 redis 可以外部访问</li>
<li>daemonize no # 用守护线程的方式启动</li>
<li>requirepass 你的密码 # 给 redis 设置密码</li>
<li>appendonly yes # redis 持久化开启</li>
</ul>
# 创建本地与 docker 映射的目录
```shell
sudo mkdir /data/redis
sudo mkdir /data/redis/data
```
<p>把配置文件<code>redis.conf</code>拷贝到刚才创建好的<code>/data/redis</code>目录下</p>
<h1 id="启动-docker">启动 docker</h1>
<pre><code class="language-shell">sudo docker run -p 6379:6379 --name redis -v /data/redis/redis.conf:/etc/redis/redis.conf  -v /data/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes
</code></pre>
<p>参数解释：</p>
<blockquote>
<p>-p 6379:6379:把容器内的6379端口映射到宿主机6379端口<br>
-v /data/redis/redis.conf:/etc/redis/redis.conf：把宿主机配置好的 redis.conf 放到容器内的这个位置中<br>
-v /data/redis/data:/data：把 redis 持久化的数据在宿主机内显示，做数据备份<br>
redis-server /etc/redis/redis.conf：这个是关键配置，让 redis 不是无配置启动，而是按照这个 redis.conf 的配置启动<br>
-appendonly yes：redis 启动后数据持久化</p>
</blockquote>
<h1 id="查看是否启动成功">查看是否启动成功</h1>
<p>是否启动成功</p>
<pre><code class="language-shell">sudo docker ps
</code></pre>
<p>查看一下日志（没有启动成功也可以通过日志查看原因）</p>
<pre><code>sudo docker logs redis
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://weakcc.github.io/post-images/1615784431566.png" alt="" loading="lazy"></figure>
<blockquote>
<p>https://blog.csdn.net/qq_17623363/article/details/106418353</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[悲观锁和乐观锁]]></title>
        <id>http://weakcc.github.io/post/bei-guan-suo-he-le-guan-suo/</id>
        <link href="http://weakcc.github.io/post/bei-guan-suo-he-le-guan-suo/">
        </link>
        <updated>2021-03-15T00:18:20.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="悲观锁">悲观锁</h1>
<p>在关系数据库管理系统里，悲观并发控制（又名<code>悲观锁</code>，Pessimistic Concurrency Control，缩写<code>PCC</code>）是一种并发控制的方法。</p>
<p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<b>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</b>）。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="悲观锁">悲观锁</h1>
<p>在关系数据库管理系统里，悲观并发控制（又名<code>悲观锁</code>，Pessimistic Concurrency Control，缩写<code>PCC</code>）是一种并发控制的方法。</p>
<p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<b>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</b>）。</p>
<!-- more -->
<pre><code class="language-mysql">
//0.开始事务            
begin;/begin work;/start transaction; (三者选一就可以)              
//1.查询出商品信息               
select status from t_goods where id=1 for update;              
//2.根据商品信息生成订单                
insert into t_orders (id,goods_id) values (null,1);              
//3.修改商品 status 为2               
update t_goods set status=2;              
//4.提交事务             
commit;

</code></pre>
<p>悲观并发控制实际上是<code>先取锁再访问</code>的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。<br>
需要注意的是，<code>FOR UPDATE</code> 生效需要同时满足两个条件时才生效：</p>
<ul>
    <li>数据库的引擎为 innoDB</li>
    <li>操作位于事务块中（BEGIN/COMMIT）</li>
</ul>
<h1 id="乐观锁">乐观锁</h1>
<p>在关系数据库管理系统里，乐观并发控制（又名<code>乐观锁</code>，Optimistic Concurrency Control，缩写<code>OCC</code>）是一种并发控制的方法。</p>
<p>乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制<code>version</code>和 CAS（Compare And Swap 比较与交换）算法实现（<b>乐观锁适用于多读的应用类型，这样可以提高吞吐量</b>）。</p>
<p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<pre><code class="language-mysql">
1.查询出商品信息
select (status,status,version) from t_goods where id=#{id}
2.根据商品信息生成订单
3.修改商品 status 为2
update t_goods set status=2,version=version+1 where id=#{id} and version=#{version};

</code></pre>
<p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。<br>
需要注意的是，如果运用的不是版本号而是商品库存等其他字段可能会出现<code>ABA</code>问题：</p>
<p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <code>ABA</code> 问题。</p>
<p>使用场景：</p>
<ul>
    <li>响应速度：如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁</li>
    <li>冲突频率：如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大</li>
    <li>重试代价：如果重试代价大，建议采用悲观锁</li>
</ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP 在操作断点续传时文件如何分割合并]]></title>
        <id>http://weakcc.github.io/post/php-zai-cao-zuo-duan-dian-xu-chuan-shi-wen-jian-ru-he-fen-ge-he-bing/</id>
        <link href="http://weakcc.github.io/post/php-zai-cao-zuo-duan-dian-xu-chuan-shi-wen-jian-ru-he-fen-ge-he-bing/">
        </link>
        <updated>2021-03-02T02:17:45.000Z</updated>
        <summary type="html"><![CDATA[<p>php 实现断点续传，就需要把大文件分割成多个小文件，然后单个上传。传完后在合并。</p>
]]></summary>
        <content type="html"><![CDATA[<p>php 实现断点续传，就需要把大文件分割成多个小文件，然后单个上传。传完后在合并。</p>
<!-- more -->
<pre><code class="language-php">&lt;?php

/**
 * 分隔文件
 */
function file_split($filePath, $tmpDir = &quot;tmp&quot;, $fileSize = 1024)
{
    $fp = fopen($filePath, 'rb');
    $i = 0;
    $no = 1;
    while (!feof($fp)) {
        $file = fread($fp, $fileSize);
        $fileName = pathinfo($filePath, PATHINFO_FILENAME);
        $tmpFp = fopen('./' . $tmpDir . '/' . $fileName . sprintf('%04d', $no) . '.' . $i . '-' . ($i + $fileSize) . '.tmp', 'wb');
        fwrite($tmpFp, $file, $fileSize);
        fclose($tmpFp);
        $i += $fileSize + 1;
        $no++;
    }
    fclose($fp);
}

/**
 * 合并文件
 */
function file_merge($tmpDir, $mergeFileName = 'merge.zip', $fileSize = 1024)
{
    $tmpFilePaths = glob($tmpDir . '/*.tmp');
    @unlink($mergeFileName);
    $fp = fopen($mergeFileName, 'w+');
    foreach ($tmpFilePaths as $v) {
        $tmpFp = fopen($v, 'rb');
        $content = fread($tmpFp, $fileSize);
        fwrite($fp, $content, $fileSize);
        unset($content);
        unlink($v);
        fclose($tmpFp);
    }
    fclose($fp);
}

$dir = 'tmp';
// 切割文件
file_split('./1.zip', $dir);
// 合并文件
file_merge($dir);
</code></pre>
]]></content>
    </entry>
</feed>