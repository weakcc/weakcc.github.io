<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2021-10-26T00:54:34.642Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[死锁]]></title>
        <id>http://weakcc.github.io/post/si-suo/</id>
        <link href="http://weakcc.github.io/post/si-suo/">
        </link>
        <updated>2021-10-21T02:50:25.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="什么是死锁">什么是死锁</h1>
<p>多线程以及多进程改善了系统资源的利用率并提高了系统的处理能力，然而并发执行也带来了新的问题 一一 <strong>死锁</strong>。</p>
<p>死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace) ) ，若无外力作用，这些进程（线程）都将无法向前推进。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="什么是死锁">什么是死锁</h1>
<p>多线程以及多进程改善了系统资源的利用率并提高了系统的处理能力，然而并发执行也带来了新的问题 一一 <strong>死锁</strong>。</p>
<p>死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace) ) ，若无外力作用，这些进程（线程）都将无法向前推进。</p>
<!-- more -->
<p>怎么理解死锁呢？</p>
<p>先看生活中的一个实例，2个人一起吃饭但是只有一双筷子，2人轮流吃（当每个人同时拥有2只筷子才能吃，甲吃完，已在吃）。<br>
某一个时候，甲拿了左筷子，已拿了右筷子，2个人都同时占用一个资源，等待另一个资源，这个时候甲在等待乙吃完并释放它占有的筷子，同理，乙也在等待甲吃完并释放它占有的筷子，这样就陷入了一个死循环，谁也无法继续吃饭。</p>
<p>计算机中也是如此，如计算机系统中只有一台打印机和一台输入设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。<br>
这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</p>
<p>关于死锁的一些结论：</p>
<ol>
    <li>参与死锁的进程数至少为两个</li>
    <li>参与死锁的所有进程均等待资源</li>
    <li>参与死锁的进程至少有两个已经占有资源</li>
    <li>死锁进程是系统中当前进程集合的一个子集</li>
    <li>死锁会浪费大量系统资源，甚至导致系统崩溃</li>
</ol>
<h1 id="死锁与饥饿">死锁与饥饿</h1>
<p>饥饿（Starvation）指一个进程一直得不到资源。<br>
死锁和饥饿都是由于进程竞争资源而引起的。饥饿一般不占有资源，死锁进程一定占有资源。</p>
<h1 id="资源的类型">资源的类型</h1>
<blockquote>
<p>https://zhuanlan.zhihu.com/p/308300980</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP生成随机头像]]></title>
        <id>http://weakcc.github.io/post/php-sheng-cheng-sui-ji-tou-xiang/</id>
        <link href="http://weakcc.github.io/post/php-sheng-cheng-sui-ji-tou-xiang/">
        </link>
        <updated>2021-10-21T02:26:41.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-php">&lt;?php

if (!function_exists('make_avatar')) {
    function make_avatar($email)
    {
        $md5_email = md5($email);
        return &quot;https://api.multiavatar.com/{$md5_email}.png&quot;;
    }
}

$src  = make_avatar('111111@qq.com');
var_dump($src);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的遍历及代码实现]]></title>
        <id>http://weakcc.github.io/post/er-cha-shu-de-bian-li-ji-dai-ma-shi-xian/</id>
        <link href="http://weakcc.github.io/post/er-cha-shu-de-bian-li-ji-dai-ma-shi-xian/">
        </link>
        <updated>2021-10-07T00:54:03.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="遍历">遍历</h1>
<h2 id="前序遍历">前序遍历</h2>
<p>如果二叉树为空，则返回空，否则从根节点开始，先遍历左子树，再遍历右子树<br>
<img src="http://weakcc.github.io/post-images/1633568114149.jpeg" alt="" loading="lazy"></p>
<h2 id="中序遍历">中序遍历</h2>
<p>如果是空树，返回空，否则从左子树最左侧的节点开始，然后从左到右依次遍历左子树，真正的根节点，最后是右子树（依然是从最左侧节点开始从左到右的顺序遍历）<br>
<img src="http://weakcc.github.io/post-images/1633568152256.jpeg" alt="" loading="lazy"></p>
<h2 id="后序遍历">后序遍历</h2>
<p>如果是空树，返回空，否则还是从左子树最左侧的节点开始，先遍历完叶子节点，再遍历父节点，遍历完左子树后，直接从右子树最左侧节点开始，按照和左子树同样的顺序遍历完右子树，最后访问根节点<br>
<img src="http://weakcc.github.io/post-images/1633568168107.jpeg" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="遍历">遍历</h1>
<h2 id="前序遍历">前序遍历</h2>
<p>如果二叉树为空，则返回空，否则从根节点开始，先遍历左子树，再遍历右子树<br>
<img src="http://weakcc.github.io/post-images/1633568114149.jpeg" alt="" loading="lazy"></p>
<h2 id="中序遍历">中序遍历</h2>
<p>如果是空树，返回空，否则从左子树最左侧的节点开始，然后从左到右依次遍历左子树，真正的根节点，最后是右子树（依然是从最左侧节点开始从左到右的顺序遍历）<br>
<img src="http://weakcc.github.io/post-images/1633568152256.jpeg" alt="" loading="lazy"></p>
<h2 id="后序遍历">后序遍历</h2>
<p>如果是空树，返回空，否则还是从左子树最左侧的节点开始，先遍历完叶子节点，再遍历父节点，遍历完左子树后，直接从右子树最左侧节点开始，按照和左子树同样的顺序遍历完右子树，最后访问根节点<br>
<img src="http://weakcc.github.io/post-images/1633568168107.jpeg" alt="" loading="lazy"></p>
<!-- more -->
<p>不同的遍历方式从不同维度将二叉树这种非线性的结构变成了某种意义上的线性序列，从而方便计算机操作。</p>
<h1 id="代码">代码</h1>
<p>二叉树的遍历其实就是个递归的过程，所以对应算法也采用递归来实现。</p>
<p>我们以二叉链表的方式来存储数组，对应的前序、中序、后序实现代码如下</p>
<pre><code class="language-php">&lt;?php

// 二叉链表节点
class Node
{
    public $data;
    public $left = null;
    public $right = null;

    public function __construct($data)
    {
        $this-&gt;data = $data;
    }
}

/**
 * 前序遍历
 * 如果二叉树为空，则返回空，否则从根节点开始，先遍历左子树，再遍历右子树
 * @param Node $tree
 */
function preOrderTraverse($tree)
{
    if ($tree === null) {
        return;
    }
    printf(&quot;%s\n&quot;, $tree-&gt;data);
    preOrderTraverse($tree-&gt;left);
    preOrderTraverse($tree-&gt;right);
}

/**
 * 中序遍历
 * 如果二叉树为空，则返回空，否则从左子树最左侧的节点开始，然后从左到右依次遍历左子树，真正的根节点，最后是右子树（依然是从最左侧节点开始从左到右的顺序遍历）
 * @param Node $tree
 */
function midOrderTraverse($tree)
{
    if ($tree === null) {
        return;
    }
    midOrderTraverse($tree-&gt;left);
    printf(&quot;%s\n&quot;, $tree-&gt;data);
    midOrderTraverse($tree-&gt;right);
}

/**
 * 后序遍历
 * 如果二叉树为空，则返回空，否则从左子树最左侧的节点开始，先遍历完叶子节点，再遍历父节点，遍历完左子树后，直接从右子树最左侧节点开始，按照和左子树同样的顺序遍历完右子树，最后访问根节点
 * @param Node $tree
 */
function postOrderTraverse($tree)
{
    if ($tree === null) {
        return;
    }
    postOrderTraverse($tree-&gt;left);
    postOrderTraverse($tree-&gt;right);
    printf(&quot;%s\n&quot;, $tree-&gt;data);
}

// 节点树
$node1 = new Node('A');
$node2 = new Node('B');
$node3 = new Node('C');
$node1-&gt;left = $node2;
$node1-&gt;right = $node3;
// 前序遍历
preOrderTraverse($node1);
print(&quot;========\n&quot;);
// 中序遍历
midOrderTraverse($node1);
print(&quot;========\n&quot;);
// 后序遍历
postOrderTraverse($node1);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel 搭建自己的 WebSocket 服务器]]></title>
        <id>http://weakcc.github.io/post/laravel-da-jian-zi-ji-de-websocket-fu-wu-qi/</id>
        <link href="http://weakcc.github.io/post/laravel-da-jian-zi-ji-de-websocket-fu-wu-qi/">
        </link>
        <updated>2021-10-06T09:51:25.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="准备">准备</h4>
<pre><code>laravel new weakcc
cd weakcc/
valet link weakcc
composer require laravel/ui
php artisan ui vue --auth
npm install &amp;&amp; npm run dev
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h4 id="准备">准备</h4>
<pre><code>laravel new weakcc
cd weakcc/
valet link weakcc
composer require laravel/ui
php artisan ui vue --auth
npm install &amp;&amp; npm run dev
</code></pre>
<!-- more -->
<p>更新.env</p>
<pre><code>APP_NAME=weakcc
APP_URL=http://weakcc.test/
DB_DATABASE=weakcc
DB_USERNAME=root
DB_PASSWORD=123456

BROADCAST_DRIVER=pusher

// 因为自己搭建的随意添加，唯一注意的就是 APP_KEY 前后端要保持一致 
PUSHER_APP_ID=123456789
PUSHER_APP_KEY=123
PUSHER_APP_SECRET=123456
</code></pre>
<p>数据迁移</p>
<pre><code>php artisan migrate
</code></pre>
<blockquote>
<p>如果需要使用 <code>PrivateChannel</code> 或 <code>PresenceChannel</code> ，需要解除 <code>config/app.php</code> 下 <code>App\Providers\BroadcastServiceProvider::class</code> 注释</p>
</blockquote>
<p>安装扩展</p>
<pre><code>composer require beyondcode/laravel-websockets
</code></pre>
<p>加载配置</p>
<pre><code>php artisan vendor:publish --provider=&quot;BeyondCode\LaravelWebSockets\WebSocketsServiceProvider&quot; --tag=&quot;migrations&quot;
php artisan migrate
php artisan vendor:publish --provider=&quot;BeyondCode\LaravelWebSockets\WebSocketsServiceProvider&quot; --tag=&quot;config&quot;
</code></pre>
<p>调试仪表板，浏览器打开 <code>http://weakcc.test/laravel-websockets</code><br>
更新 <code>config/broadcasting.php</code> 下 <code>pusher</code> 配置</p>
<pre><code>'options' =&gt; [
    'cluster' =&gt; env('PUSHER_APP_CLUSTER'),
    'host' =&gt; '127.0.0.1',
    'port' =&gt; 6001,
    'scheme' =&gt; 'http'
],
</code></pre>
<p>解除 <code>resources/js/bootstrap.js</code> 注释并更新如下</p>
<pre><code>import Echo from 'laravel-echo';

window.Pusher = require('pusher-js');

window.Echo = new Echo({
    broadcaster: 'pusher',
    key: '123', // 要跟后台保持一致
    wsHost: window.location.hostname,
    wsPort: 6001,
    disableStats: true,
});
</code></pre>
<p>安装前端依赖包</p>
<pre><code>npm install --save laravel-echo pusher-js
</code></pre>
<p>运行服务</p>
<pre><code>php artisan websockets:serve
</code></pre>
<blockquote>
<p>.env 里的 APP_URL 一定要修改，不然寻址会出现问题</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel 跨站登录]]></title>
        <id>http://weakcc.github.io/post/laravel-kua-zhan-deng-lu/</id>
        <link href="http://weakcc.github.io/post/laravel-kua-zhan-deng-lu/">
        </link>
        <updated>2021-10-06T09:48:13.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="原理">原理</h4>
<p>两个项目要共用一套验证体系，一般都是先做完主站，共用的用户系统就是主站的用户系统</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="原理">原理</h4>
<p>两个项目要共用一套验证体系，一般都是先做完主站，共用的用户系统就是主站的用户系统</p>
<!-- more -->
<h4 id="准备">准备</h4>
<p>创建主站项目</p>
<pre><code>laravel new weakcc
cd weakcc/
valet link weakcc
composer require laravel/ui
php artisan ui vue --auth
npm install &amp;&amp; npm run dev
</code></pre>
<p>更新.env</p>
<pre><code>APP_NAME=weakcc
APP_URL=http://weakcc.test/
DB_DATABASE=weakcc
DB_USERNAME=root
DB_PASSWORD=123456
</code></pre>
<p>数据迁移</p>
<pre><code>php artisan migrate
</code></pre>
<p>创建子站项目</p>
<pre><code>laravel new weakcc2
cd weakcc2/
valet link zoo.weakcc
composer require laravel/ui
php artisan ui vue --auth
npm install &amp;&amp; npm run dev
</code></pre>
<p>更新.env</p>
<pre><code>APP_NAME=weakcc2
APP_URL=http://zoo.weakcc.test/
DB_DATABASE=weakcc2
DB_USERNAME=root
DB_PASSWORD=123456
</code></pre>
<p>数据迁移</p>
<pre><code>php artisan migrate
</code></pre>
<h4 id="实现">实现</h4>
<p>子站需要新建一个能够关联到主站的数据库连接，打开子站的项目配置文件 <code>database.php</code> 复制一遍 <code>mysql</code> 信息并重名为 <code>cc_mysql</code></p>
<pre><code>// 本地测试，其他记录一样，只是更新数据库，其他环境，请自行更新
'cc_mysql' =&gt; [
    'driver' =&gt; 'mysql',
    'url' =&gt; env('DATABASE_URL'),
    'host' =&gt; env('DB_HOST', '127.0.0.1'),
    'port' =&gt; env('DB_PORT', '3306'),
    'database' =&gt; 'weakcc', // 主项目的数据库
    'username' =&gt; env('DB_USERNAME', 'forge'),
    'password' =&gt; env('DB_PASSWORD', ''),
    'unix_socket' =&gt; env('DB_SOCKET', ''),
    'charset' =&gt; 'utf8mb4',
    'collation' =&gt; 'utf8mb4_unicode_ci',
    'prefix' =&gt; '',
    'prefix_indexes' =&gt; true,
    'strict' =&gt; true,
    'engine' =&gt; null,
    'options' =&gt; extension_loaded('pdo_mysql') ? array_filter([
        PDO::MYSQL_ATTR_SSL_CA =&gt; env('MYSQL_ATTR_SSL_CA'),
    ]) : [],
],
</code></pre>
<p>子站更新 <code>User</code> 模型数据库连接为新设置的 <code>cc_mysql</code></p>
<pre><code>// 主站对应的用户表
protected $table = 'users';
// 这样的话用户验证将去主项目的用户逻辑
protected $connection = 'cc_mysql'; 
</code></pre>
<p>主项目和子项目同时更新 <code>.env</code> 同时执行 <code>session</code> 表生成</p>
<pre><code>// 此处使用数据库驱动（跨站登录可以使用 redis 和 database 驱动）
SESSION_DRIVER=database
// 执行 session 表格生成
php artisan session:table
php artisan migrate
</code></pre>
<p>关键步骤，是两个网站能够使用相同的域</p>
<p>主项目更新 <code>.env</code></p>
<pre><code>SESSION_DOMAIN=.weakcc.test
</code></pre>
<p>子项目更新 <code>.env</code></p>
<pre><code>SESSION_DOMAIN=.weakcc.test
// 子项目的 session 连接信息必须为子站用来连接主站的那个 mysql 信息
SESSION_CONNECTION=cc_mysql
</code></pre>
<p>最后一步，两个项目的的 <code>APP_KEY</code> 必须相同，可以复制主站的 <code>APP_KEY</code> 到子站，更新 <code>.env</code></p>
<pre><code>// 为主站的 APP_KEY
APP_KEY=base64:mkmoK3/Y84EkxihfiqZZM9ooHoD2GHRbaMNH79CrD0Q=
</code></pre>
<p>好了，现在可以在主站注册用户登录，在子站访问了</p>
<blockquote>
<p>页面显示 <code>419</code> 需要清除下浏览器缓存的 <code>cookie</code> 信息</p>
</blockquote>
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
]]></content>
    </entry>
</feed>