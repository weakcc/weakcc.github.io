<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2021-10-18T01:50:38.919Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[二叉树的遍历及代码实现]]></title>
        <id>http://weakcc.github.io/post/er-cha-shu-de-bian-li-ji-dai-ma-shi-xian/</id>
        <link href="http://weakcc.github.io/post/er-cha-shu-de-bian-li-ji-dai-ma-shi-xian/">
        </link>
        <updated>2021-10-07T00:54:03.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="遍历">遍历</h1>
<h2 id="前序遍历">前序遍历</h2>
<p>如果二叉树为空，则返回空，否则从根节点开始，先遍历左子树，再遍历右子树<br>
<img src="http://weakcc.github.io/post-images/1633568114149.jpeg" alt="" loading="lazy"></p>
<h2 id="中序遍历">中序遍历</h2>
<p>如果是空树，返回空，否则从左子树最左侧的节点开始，然后从左到右依次遍历左子树，真正的根节点，最后是右子树（依然是从最左侧节点开始从左到右的顺序遍历）<br>
<img src="http://weakcc.github.io/post-images/1633568152256.jpeg" alt="" loading="lazy"></p>
<h2 id="后序遍历">后序遍历</h2>
<p>如果是空树，返回空，否则还是从左子树最左侧的节点开始，先遍历完叶子节点，再遍历父节点，遍历完左子树后，直接从右子树最左侧节点开始，按照和左子树同样的顺序遍历完右子树，最后访问根节点<br>
<img src="http://weakcc.github.io/post-images/1633568168107.jpeg" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="遍历">遍历</h1>
<h2 id="前序遍历">前序遍历</h2>
<p>如果二叉树为空，则返回空，否则从根节点开始，先遍历左子树，再遍历右子树<br>
<img src="http://weakcc.github.io/post-images/1633568114149.jpeg" alt="" loading="lazy"></p>
<h2 id="中序遍历">中序遍历</h2>
<p>如果是空树，返回空，否则从左子树最左侧的节点开始，然后从左到右依次遍历左子树，真正的根节点，最后是右子树（依然是从最左侧节点开始从左到右的顺序遍历）<br>
<img src="http://weakcc.github.io/post-images/1633568152256.jpeg" alt="" loading="lazy"></p>
<h2 id="后序遍历">后序遍历</h2>
<p>如果是空树，返回空，否则还是从左子树最左侧的节点开始，先遍历完叶子节点，再遍历父节点，遍历完左子树后，直接从右子树最左侧节点开始，按照和左子树同样的顺序遍历完右子树，最后访问根节点<br>
<img src="http://weakcc.github.io/post-images/1633568168107.jpeg" alt="" loading="lazy"></p>
<!-- more -->
<p>不同的遍历方式从不同维度将二叉树这种非线性的结构变成了某种意义上的线性序列，从而方便计算机操作。</p>
<h1 id="代码">代码</h1>
<p>二叉树的遍历其实就是个递归的过程，所以对应算法也采用递归来实现。</p>
<p>我们以二叉链表的方式来存储数组，对应的前序、中序、后序实现代码如下</p>
<pre><code class="language-php">&lt;?php

// 二叉链表节点
class Node
{
    public $data;
    public $left = null;
    public $right = null;

    public function __construct($data)
    {
        $this-&gt;data = $data;
    }
}

/**
 * 前序遍历
 * 如果二叉树为空，则返回空，否则从根节点开始，先遍历左子树，再遍历右子树
 * @param Node $tree
 */
function preOrderTraverse($tree)
{
    if ($tree === null) {
        return;
    }
    printf(&quot;%s\n&quot;, $tree-&gt;data);
    preOrderTraverse($tree-&gt;left);
    preOrderTraverse($tree-&gt;right);
}

/**
 * 中序遍历
 * 如果二叉树为空，则返回空，否则从左子树最左侧的节点开始，然后从左到右依次遍历左子树，真正的根节点，最后是右子树（依然是从最左侧节点开始从左到右的顺序遍历）
 * @param Node $tree
 */
function midOrderTraverse($tree)
{
    if ($tree === null) {
        return;
    }
    midOrderTraverse($tree-&gt;left);
    printf(&quot;%s\n&quot;, $tree-&gt;data);
    midOrderTraverse($tree-&gt;right);
}

/**
 * 后序遍历
 * 如果二叉树为空，则返回空，否则从左子树最左侧的节点开始，先遍历完叶子节点，再遍历父节点，遍历完左子树后，直接从右子树最左侧节点开始，按照和左子树同样的顺序遍历完右子树，最后访问根节点
 * @param Node $tree
 */
function postOrderTraverse($tree)
{
    if ($tree === null) {
        return;
    }
    postOrderTraverse($tree-&gt;left);
    postOrderTraverse($tree-&gt;right);
    printf(&quot;%s\n&quot;, $tree-&gt;data);
}

// 节点树
$node1 = new Node('A');
$node2 = new Node('B');
$node3 = new Node('C');
$node1-&gt;left = $node2;
$node1-&gt;right = $node3;
// 前序遍历
preOrderTraverse($node1);
print(&quot;========\n&quot;);
// 中序遍历
midOrderTraverse($node1);
print(&quot;========\n&quot;);
// 后序遍历
postOrderTraverse($node1);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel 搭建自己的 WebSocket 服务器]]></title>
        <id>http://weakcc.github.io/post/laravel-da-jian-zi-ji-de-websocket-fu-wu-qi/</id>
        <link href="http://weakcc.github.io/post/laravel-da-jian-zi-ji-de-websocket-fu-wu-qi/">
        </link>
        <updated>2021-10-06T09:51:25.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="准备">准备</h4>
<pre><code>laravel new weakcc
cd weakcc/
valet link weakcc
composer require laravel/ui
php artisan ui vue --auth
npm install &amp;&amp; npm run dev
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h4 id="准备">准备</h4>
<pre><code>laravel new weakcc
cd weakcc/
valet link weakcc
composer require laravel/ui
php artisan ui vue --auth
npm install &amp;&amp; npm run dev
</code></pre>
<!-- more -->
<p>更新.env</p>
<pre><code>APP_NAME=weakcc
APP_URL=http://weakcc.test/
DB_DATABASE=weakcc
DB_USERNAME=root
DB_PASSWORD=123456

BROADCAST_DRIVER=pusher

// 因为自己搭建的随意添加，唯一注意的就是 APP_KEY 前后端要保持一致 
PUSHER_APP_ID=123456789
PUSHER_APP_KEY=123
PUSHER_APP_SECRET=123456
</code></pre>
<p>数据迁移</p>
<pre><code>php artisan migrate
</code></pre>
<blockquote>
<p>如果需要使用 <code>PrivateChannel</code> 或 <code>PresenceChannel</code> ，需要解除 <code>config/app.php</code> 下 <code>App\Providers\BroadcastServiceProvider::class</code> 注释</p>
</blockquote>
<p>安装扩展</p>
<pre><code>composer require beyondcode/laravel-websockets
</code></pre>
<p>加载配置</p>
<pre><code>php artisan vendor:publish --provider=&quot;BeyondCode\LaravelWebSockets\WebSocketsServiceProvider&quot; --tag=&quot;migrations&quot;
php artisan migrate
php artisan vendor:publish --provider=&quot;BeyondCode\LaravelWebSockets\WebSocketsServiceProvider&quot; --tag=&quot;config&quot;
</code></pre>
<p>调试仪表板，浏览器打开 <code>http://weakcc.test/laravel-websockets</code><br>
更新 <code>config/broadcasting.php</code> 下 <code>pusher</code> 配置</p>
<pre><code>'options' =&gt; [
    'cluster' =&gt; env('PUSHER_APP_CLUSTER'),
    'host' =&gt; '127.0.0.1',
    'port' =&gt; 6001,
    'scheme' =&gt; 'http'
],
</code></pre>
<p>解除 <code>resources/js/bootstrap.js</code> 注释并更新如下</p>
<pre><code>import Echo from 'laravel-echo';

window.Pusher = require('pusher-js');

window.Echo = new Echo({
    broadcaster: 'pusher',
    key: '123', // 要跟后台保持一致
    wsHost: window.location.hostname,
    wsPort: 6001,
    disableStats: true,
});
</code></pre>
<p>安装前端依赖包</p>
<pre><code>npm install --save laravel-echo pusher-js
</code></pre>
<p>运行服务</p>
<pre><code>php artisan websockets:serve
</code></pre>
<blockquote>
<p>.env 里的 APP_URL 一定要修改，不然寻址会出现问题</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel 跨站登录]]></title>
        <id>http://weakcc.github.io/post/laravel-kua-zhan-deng-lu/</id>
        <link href="http://weakcc.github.io/post/laravel-kua-zhan-deng-lu/">
        </link>
        <updated>2021-10-06T09:48:13.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="原理">原理</h4>
<p>两个项目要共用一套验证体系，一般都是先做完主站，共用的用户系统就是主站的用户系统</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="原理">原理</h4>
<p>两个项目要共用一套验证体系，一般都是先做完主站，共用的用户系统就是主站的用户系统</p>
<!-- more -->
<h4 id="准备">准备</h4>
<p>创建主站项目</p>
<pre><code>laravel new weakcc
cd weakcc/
valet link weakcc
composer require laravel/ui
php artisan ui vue --auth
npm install &amp;&amp; npm run dev
</code></pre>
<p>更新.env</p>
<pre><code>APP_NAME=weakcc
APP_URL=http://weakcc.test/
DB_DATABASE=weakcc
DB_USERNAME=root
DB_PASSWORD=123456
</code></pre>
<p>数据迁移</p>
<pre><code>php artisan migrate
</code></pre>
<p>创建子站项目</p>
<pre><code>laravel new weakcc2
cd weakcc2/
valet link zoo.weakcc
composer require laravel/ui
php artisan ui vue --auth
npm install &amp;&amp; npm run dev
</code></pre>
<p>更新.env</p>
<pre><code>APP_NAME=weakcc2
APP_URL=http://zoo.weakcc.test/
DB_DATABASE=weakcc2
DB_USERNAME=root
DB_PASSWORD=123456
</code></pre>
<p>数据迁移</p>
<pre><code>php artisan migrate
</code></pre>
<h4 id="实现">实现</h4>
<p>子站需要新建一个能够关联到主站的数据库连接，打开子站的项目配置文件 <code>database.php</code> 复制一遍 <code>mysql</code> 信息并重名为 <code>cc_mysql</code></p>
<pre><code>// 本地测试，其他记录一样，只是更新数据库，其他环境，请自行更新
'cc_mysql' =&gt; [
    'driver' =&gt; 'mysql',
    'url' =&gt; env('DATABASE_URL'),
    'host' =&gt; env('DB_HOST', '127.0.0.1'),
    'port' =&gt; env('DB_PORT', '3306'),
    'database' =&gt; 'weakcc', // 主项目的数据库
    'username' =&gt; env('DB_USERNAME', 'forge'),
    'password' =&gt; env('DB_PASSWORD', ''),
    'unix_socket' =&gt; env('DB_SOCKET', ''),
    'charset' =&gt; 'utf8mb4',
    'collation' =&gt; 'utf8mb4_unicode_ci',
    'prefix' =&gt; '',
    'prefix_indexes' =&gt; true,
    'strict' =&gt; true,
    'engine' =&gt; null,
    'options' =&gt; extension_loaded('pdo_mysql') ? array_filter([
        PDO::MYSQL_ATTR_SSL_CA =&gt; env('MYSQL_ATTR_SSL_CA'),
    ]) : [],
],
</code></pre>
<p>子站更新 <code>User</code> 模型数据库连接为新设置的 <code>cc_mysql</code></p>
<pre><code>// 主站对应的用户表
protected $table = 'users';
// 这样的话用户验证将去主项目的用户逻辑
protected $connection = 'cc_mysql'; 
</code></pre>
<p>主项目和子项目同时更新 <code>.env</code> 同时执行 <code>session</code> 表生成</p>
<pre><code>// 此处使用数据库驱动（跨站登录可以使用 redis 和 database 驱动）
SESSION_DRIVER=database
// 执行 session 表格生成
php artisan session:table
php artisan migrate
</code></pre>
<p>关键步骤，是两个网站能够使用相同的域</p>
<p>主项目更新 <code>.env</code></p>
<pre><code>SESSION_DOMAIN=.weakcc.test
</code></pre>
<p>子项目更新 <code>.env</code></p>
<pre><code>SESSION_DOMAIN=.weakcc.test
// 子项目的 session 连接信息必须为子站用来连接主站的那个 mysql 信息
SESSION_CONNECTION=cc_mysql
</code></pre>
<p>最后一步，两个项目的的 <code>APP_KEY</code> 必须相同，可以复制主站的 <code>APP_KEY</code> 到子站，更新 <code>.env</code></p>
<pre><code>// 为主站的 APP_KEY
APP_KEY=base64:mkmoK3/Y84EkxihfiqZZM9ooHoD2GHRbaMNH79CrD0Q=
</code></pre>
<p>好了，现在可以在主站注册用户登录，在子站访问了</p>
<blockquote>
<p>页面显示 <code>419</code> 需要清除下浏览器缓存的 <code>cookie</code> 信息</p>
</blockquote>
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel 单人登录]]></title>
        <id>http://weakcc.github.io/post/laravel-dan-ren-deng-lu/</id>
        <link href="http://weakcc.github.io/post/laravel-dan-ren-deng-lu/">
        </link>
        <updated>2021-10-06T09:47:50.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="原理">原理</h4>
<p>一个账户只能在一个地方登录（用户登录网站会创建一个 <code>session</code> 信息，实现单人登录的原理就是把以前已经生成的 <code>session</code> 信息弃用掉，要么删除之前的 <code>session</code> 信息，要么修改之前的 <code>session</code> 信息，使浏览器提交 <code>cookie</code> 信息匹配 <code>session</code> 找不到就可以了）</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="原理">原理</h4>
<p>一个账户只能在一个地方登录（用户登录网站会创建一个 <code>session</code> 信息，实现单人登录的原理就是把以前已经生成的 <code>session</code> 信息弃用掉，要么删除之前的 <code>session</code> 信息，要么修改之前的 <code>session</code> 信息，使浏览器提交 <code>cookie</code> 信息匹配 <code>session</code> 找不到就可以了）</p>
<!-- more -->
<h4 id="准备">准备</h4>
<p>创建主站项目</p>
<pre><code>laravel new weakcc
cd weakcc/
valet link weakcc
composer require laravel/ui
php artisan ui vue --auth
npm install &amp;&amp; npm run dev
</code></pre>
<p>更新.env</p>
<pre><code>APP_NAME=weakcc
APP_URL=http://weakcc.test/
DB_DATABASE=weakcc
DB_USERNAME=root
DB_PASSWORD=123456
SESSION_DRIVER=database
</code></pre>
<p>数据迁移</p>
<pre><code>php artisan migrate
php artisan session:table
</code></pre>
<h4 id="实现">实现</h4>
<p><code>session</code> 以 <code>database</code> 为数据库驱动为例<br>
覆写 <code>App\Http\Controllers\Auth\LoginController</code> 文件下的 <code>authenticated</code> 方法（当登录时，session 信息还没有生成，就是在这里把已经有的 <code>session</code> 修改下）</p>
<p>方法1：</p>
<p>简单粗暴法，有登录就删除已有的 <code>session</code> 信息</p>
<pre><code>protected function authenticated(Request $request, $user)
{
    DB::table('sessions')-&gt;where('user_id', $user-&gt;id)-&gt;delete();
}
</code></pre>
<p>方法2：</p>
<p>保留用户登录 <code>session</code> 历史信息，方便后续做信息排查，修改已有的 <code>session</code> 信息，变为无效的 <code>session</code> 信息，确认不是恶意的登录信息，这时就可以对无效的信息进行删除</p>
<pre><code>// 'OUTMAN-' 可以自己随意设置
protected function authenticated(Request $request, $user)
{
    DB::table('sessions')-&gt;where('user_id', $user-&gt;id)-&gt;orderBy('last_activity')-&gt;each(function ($session) {
        DB::table('sessions')-&gt;where('id', $session-&gt;id)-&gt;update(['id' =&gt; 'OUTMAN-' . $session-&gt;id]);
    });
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel 超时登录]]></title>
        <id>http://weakcc.github.io/post/laravel-chao-shi-deng-lu/</id>
        <link href="http://weakcc.github.io/post/laravel-chao-shi-deng-lu/">
        </link>
        <updated>2021-10-06T09:47:08.000Z</updated>
        <content type="html"><![CDATA[<p>设置 <code>.env</code> 默认为120分钟</p>
<pre><code>SESSION_LIFETIME=120
</code></pre>
]]></content>
    </entry>
</feed>