<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2021-10-26T02:29:57.336Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[PHP 动态语言静态化]]></title>
        <id>http://weakcc.github.io/post/php-dong-tai-yu-yan-jing-tai-hua/</id>
        <link href="http://weakcc.github.io/post/php-dong-tai-yu-yan-jing-tai-hua/">
        </link>
        <updated>2021-10-26T02:26:40.000Z</updated>
        <summary type="html"><![CDATA[<p>新建文件 <code>demo.php</code><br>
正常输出</p>
<pre><code class="language-php">&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
</code></pre>
<p>开启输出控制缓冲 <code>ob_start</code></p>
<pre><code class="language-php">&lt;?php
    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲
    var_dump($content);
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>新建文件 <code>demo.php</code><br>
正常输出</p>
<pre><code class="language-php">&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
</code></pre>
<p>开启输出控制缓冲 <code>ob_start</code></p>
<pre><code class="language-php">&lt;?php
    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲
    var_dump($content);
</code></pre>
<!--more-->
<p>把缓存写入文件</p>
<pre><code class="language-php">&lt;?php
    $cache_name = md5(__FILE__) . '.html';

    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲

    $handle = fopen($cache_name, 'w');
    fwrite($handle, $content);
    fclose($handle);
</code></pre>
<pre><code>var_dump($cache_name);
</code></pre>
<p>运行后生成临时文件 <code>xxxx.html</code> 缓存</p>
<p>关键缓存判断</p>
<pre><code class="language-php">&lt;?php
    $cache_name = md5(__FILE__) . '.html';
    $cache_lifetime = 3600;
    // filectime() 函数返回指定文件的上次修改时间
    if (file_exists($cache_name)
        &amp;&amp; filectime(__FILE__) &lt;= filectime($cache_name)
        &amp;&amp; filectime($cache_name) + $cache_lifetime &gt; time()) {
        // 缓存文件存在
        // 当前文件是否有修改（文件的修改时间小于缓存文件的修改问）
        // 缓存文件是否已经过期
        include $cache_name;
        exit;
    }

    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲

    $handle = fopen($cache_name, 'w');
    fwrite($handle, $content);
    fclose($handle);
</code></pre>
<p>根据不同的用户 <code>id</code> 做不同的缓存</p>
<pre><code class="language-php">&lt;?php
    $id = intval($_GET['id']);
    if (empty($id)) {
        $id = '';
    }

    $cache_name = md5(__FILE__) . '-' . $id .'.html';
    $cache_lifetime = 3600;
    // filectime() 函数返回指定文件的上次修改时间
    if (file_exists($cache_name)
        &amp;&amp; filectime(__FILE__) &lt;= filectime($cache_name)
        &amp;&amp; filectime($cache_name) + $cache_lifetime &gt; time()) {
        // 缓存文件存在
        // 当前文件是否有修改（文件的修改时间小于缓存文件的修改问）
        // 缓存文件是否已经过期
        include $cache_name;
        exit;
    }

    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本. &lt;?php echo $id?&gt;&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲

    $handle = fopen($cache_name, 'w');
    fwrite($handle, $content);
    fclose($handle);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[API 防篡改和防重放]]></title>
        <id>http://weakcc.github.io/post/api-fang-cuan-gai-he-fang-chong-fang/</id>
        <link href="http://weakcc.github.io/post/api-fang-cuan-gai-he-fang-chong-fang/">
        </link>
        <updated>2021-10-26T01:00:36.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="防篡改">防篡改</h1>
<p>签名校验</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="防篡改">防篡改</h1>
<p>签名校验</p>
<!-- more -->
<h1 id="防重防">防重防</h1>
<h2 id="timestampnonce">timestamp+nonce</h2>
<p>我们常用的防止重放的机制是使用 timestamp 和 nonce 来做的重放机制。</p>
<!-- more -->
<p>timestamp 用来表示请求的当前时间戳，这个时间戳当然要和服务器时间戳进行校正过的。我们预期正常请求带的 timestamp 参数会是不同的（预期是正常的人每秒至多只会做一个操作）。每个请求带的时间戳不能和当前时间超过一定规定的时间。比如 60s。这样，这个请求即使被截取了，你也只能在 60s 内进行重放攻击。过期失效。</p>
<p>但是这样也是不够的，还有给攻击者 60s 的时间。所以我们就需要使用一个 nonce，随机数。</p>
<p>nonce 是由客户端根据足够随机的情况生成的，比如 md5 (timestamp+rand (0, 1000)); 它就有一个要求，正常情况下，在短时间内（比如 60s）连续生成两个相同 nonce 的情况几乎为 0。</p>
<h2 id="服务端">服务端</h2>
<p>服务端第一次在接收到这个 nonce 的时候做下面行为：<br>
1 去 redis 中查找是否有 key 为 nonce:{nonce} 的 string<br>
2 如果没有，则创建这个 key，把这个 key 失效的时间和验证 timestamp 失效的时间一致，比如是 60s。<br>
3 如果有，说明这个 key 在 60s 内已经被使用了，那么这个请求就可以判断为重放请求。</p>
<blockquote>
<p>https://www.jianshu.com/p/de9295087560<br>
https://learnku.com/articles/4196/talk-about-the-anti-replay-mechanism-of-api</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP cURL]]></title>
        <id>http://weakcc.github.io/post/php-curl/</id>
        <link href="http://weakcc.github.io/post/php-curl/">
        </link>
        <updated>2021-10-26T00:54:38.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="curl">cURL</h1>
<h2 id="get">GET</h2>
<pre><code class="language-php">/**
 * @param string $url 请求 url
 * @param int $httpCode 状态码
 * @return mixed
 */
function curl_get($url, &amp;$httpCode = 404)
{
    // 初始化一个curl会话
    $ch = curl_init();

    // 需要获取的url地址
    curl_setopt($ch, CURLOPT_URL, $url);
    // 启用 返回原生的(raw)输出
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

    //不做证书校验,部署在linux环境下请改为true
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    // 在发起连接前等待的时间，如果设置为0，则无限等待
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);

    // 	执行一个curl会话
    $fileContents = curl_exec($ch);
    // 获取一个curl连接资源句柄的信息
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

    // 关闭一个curl会话
    curl_close($ch);
    return $fileContents;
}

$statusCode = 0;
var_dump(curl_get('http://www.baidu.com/', $statusCode));
var_dump($statusCode);
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="curl">cURL</h1>
<h2 id="get">GET</h2>
<pre><code class="language-php">/**
 * @param string $url 请求 url
 * @param int $httpCode 状态码
 * @return mixed
 */
function curl_get($url, &amp;$httpCode = 404)
{
    // 初始化一个curl会话
    $ch = curl_init();

    // 需要获取的url地址
    curl_setopt($ch, CURLOPT_URL, $url);
    // 启用 返回原生的(raw)输出
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

    //不做证书校验,部署在linux环境下请改为true
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    // 在发起连接前等待的时间，如果设置为0，则无限等待
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);

    // 	执行一个curl会话
    $fileContents = curl_exec($ch);
    // 获取一个curl连接资源句柄的信息
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

    // 关闭一个curl会话
    curl_close($ch);
    return $fileContents;
}

$statusCode = 0;
var_dump(curl_get('http://www.baidu.com/', $statusCode));
var_dump($statusCode);
</code></pre>
<!-- more -->
<h2 id="post">POST</h2>
<pre><code class="language-php">/**
 * @param string $url 请求 url
 * @param array $params 参数
 * @return mixed
 */
function curl_post(string $url, array $params = [])
{
    // 初始化一个curl会话
    $ch = curl_init();

    // 需要获取的url地址
    curl_setopt($ch, CURLOPT_URL, $url);
    // 启用时会将头文件的信息作为数据流输出
    curl_setopt($ch, CURLOPT_HEADER, 0);
    // 启用 返回原生的(raw)输出
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    //不做证书校验,部署在linux环境下请改为true
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    // 在发起连接前等待的时间，如果设置为0，则无限等待
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);
    // 启用时会发送一个常规的POST请求，类型为：application/x-www-form-urlencoded，就像表单提交的一样
    curl_setopt($ch, CURLOPT_POST, 1);
    // 全部数据使用HTTP协议中的&quot;POST&quot;操作来发送。要发送文件，在文件名前面加上@前缀并使用完整路径。这个参数可以通过urlencoded后的字符串类似'para1=val1&amp;para2=val2&amp;...'或使用一个以字段名为键值，字段数据为值的数组。如果value是一个数组，Content-Type头将会被设置成multipart/form-data
    // 传递一个数组到CURLOPT_POSTFIELDS，cURL会把数据编码成 multipart/form-data，而然传递一个URL-encoded字符串时，数据会被编码成 application/x-www-form-urlencoded
    curl_setopt($ch, CURLOPT_POSTFIELDS, $params);

    /*
    // 或者传递一个 json 类型 $params 要 json_encode() 转义
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Content-Type: application/json' // 一个用来设置HTTP头字段的数组
    ]);
    */
    // 	执行一个curl会话
    $contents = curl_exec($ch);
    // 关闭一个curl会话
    curl_close($ch);
    return $contents;
}

$url = 'xxxxx'; // 提交的 url
$data = array('name' =&gt; 'Foo', 'file' =&gt; '@/home/user/test.png');
var_dump(curl_post($url, $data));
</code></pre>
<h2 id="raw">Raw</h2>
<pre><code class="language-php">/**
 * @param string $url 请求 url
 * @param string $data 参数
 * @return mixed
 */
function curl_post_raw(string $url, string $data)
{
    // 初始化一个curl会话
    $ch = curl_init();

    // 需要获取的url地址
    curl_setopt($ch, CURLOPT_URL, $url);
    // 启用时会将头文件的信息作为数据流输出
    curl_setopt($ch, CURLOPT_HEADER, 0);
    // 启用 返回原生的(raw)输出
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    //不做证书校验,部署在linux环境下请改为true
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    // 在发起连接前等待的时间，如果设置为0，则无限等待
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);
    // 启用时会发送一个常规的POST请求，类型为：application/x-www-form-urlencoded，就像表单提交的一样
    curl_setopt($ch, CURLOPT_POST, 1);

    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
    // // 一个用来设置HTTP头字段的数组
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Content-Type: text'
    ]);
    // 	执行一个curl会话
    $contents = curl_exec($ch);
    // 关闭一个curl会话
    curl_close($ch);
    return $contents;
}
</code></pre>
<h2 id="可以访问请求的原始数据的只读流">可以访问请求的原始数据的只读流</h2>
<pre><code class="language-php">file_get_contents(&quot;php://input&quot;)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[死锁]]></title>
        <id>http://weakcc.github.io/post/si-suo/</id>
        <link href="http://weakcc.github.io/post/si-suo/">
        </link>
        <updated>2021-10-21T02:50:25.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="什么是死锁">什么是死锁</h1>
<p>多线程以及多进程改善了系统资源的利用率并提高了系统的处理能力，然而并发执行也带来了新的问题 一一 <strong>死锁</strong>。</p>
<p>死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace) ) ，若无外力作用，这些进程（线程）都将无法向前推进。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="什么是死锁">什么是死锁</h1>
<p>多线程以及多进程改善了系统资源的利用率并提高了系统的处理能力，然而并发执行也带来了新的问题 一一 <strong>死锁</strong>。</p>
<p>死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace) ) ，若无外力作用，这些进程（线程）都将无法向前推进。</p>
<!-- more -->
<p>怎么理解死锁呢？</p>
<p>先看生活中的一个实例，2个人一起吃饭但是只有一双筷子，2人轮流吃（当每个人同时拥有2只筷子才能吃，甲吃完，已在吃）。<br>
某一个时候，甲拿了左筷子，已拿了右筷子，2个人都同时占用一个资源，等待另一个资源，这个时候甲在等待乙吃完并释放它占有的筷子，同理，乙也在等待甲吃完并释放它占有的筷子，这样就陷入了一个死循环，谁也无法继续吃饭。</p>
<p>计算机中也是如此，如计算机系统中只有一台打印机和一台输入设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。<br>
这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</p>
<p>关于死锁的一些结论：</p>
<ol>
    <li>参与死锁的进程数至少为两个</li>
    <li>参与死锁的所有进程均等待资源</li>
    <li>参与死锁的进程至少有两个已经占有资源</li>
    <li>死锁进程是系统中当前进程集合的一个子集</li>
    <li>死锁会浪费大量系统资源，甚至导致系统崩溃</li>
</ol>
<h1 id="死锁与饥饿">死锁与饥饿</h1>
<p>饥饿（Starvation）指一个进程一直得不到资源。<br>
死锁和饥饿都是由于进程竞争资源而引起的。饥饿一般不占有资源，死锁进程一定占有资源。</p>
<h1 id="资源的类型">资源的类型</h1>
<blockquote>
<p>https://zhuanlan.zhihu.com/p/308300980</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP生成随机头像]]></title>
        <id>http://weakcc.github.io/post/php-sheng-cheng-sui-ji-tou-xiang/</id>
        <link href="http://weakcc.github.io/post/php-sheng-cheng-sui-ji-tou-xiang/">
        </link>
        <updated>2021-10-21T02:26:41.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-php">&lt;?php

if (!function_exists('make_avatar')) {
    function make_avatar($email)
    {
        $md5_email = md5($email);
        return &quot;https://api.multiavatar.com/{$md5_email}.png&quot;;
    }
}

$src  = make_avatar('111111@qq.com');
var_dump($src);
</code></pre>
]]></content>
    </entry>
</feed>