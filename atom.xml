<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2021-10-26T00:59:30.957Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[PHP cURL]]></title>
        <id>http://weakcc.github.io/post/php-curl/</id>
        <link href="http://weakcc.github.io/post/php-curl/">
        </link>
        <updated>2021-10-26T00:54:38.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="curl">cURL</h1>
<h2 id="get">GET</h2>
<pre><code class="language-php">/**
 * @param string $url 请求 url
 * @param int $httpCode 状态码
 * @return mixed
 */
function curl_get($url, &amp;$httpCode = 404)
{
    // 初始化一个curl会话
    $ch = curl_init();

    // 需要获取的url地址
    curl_setopt($ch, CURLOPT_URL, $url);
    // 启用 返回原生的(raw)输出
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

    //不做证书校验,部署在linux环境下请改为true
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    // 在发起连接前等待的时间，如果设置为0，则无限等待
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);

    // 	执行一个curl会话
    $fileContents = curl_exec($ch);
    // 获取一个curl连接资源句柄的信息
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

    // 关闭一个curl会话
    curl_close($ch);
    return $fileContents;
}

$statusCode = 0;
var_dump(curl_get('http://www.baidu.com/', $statusCode));
var_dump($statusCode);
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="curl">cURL</h1>
<h2 id="get">GET</h2>
<pre><code class="language-php">/**
 * @param string $url 请求 url
 * @param int $httpCode 状态码
 * @return mixed
 */
function curl_get($url, &amp;$httpCode = 404)
{
    // 初始化一个curl会话
    $ch = curl_init();

    // 需要获取的url地址
    curl_setopt($ch, CURLOPT_URL, $url);
    // 启用 返回原生的(raw)输出
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

    //不做证书校验,部署在linux环境下请改为true
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    // 在发起连接前等待的时间，如果设置为0，则无限等待
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);

    // 	执行一个curl会话
    $fileContents = curl_exec($ch);
    // 获取一个curl连接资源句柄的信息
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

    // 关闭一个curl会话
    curl_close($ch);
    return $fileContents;
}

$statusCode = 0;
var_dump(curl_get('http://www.baidu.com/', $statusCode));
var_dump($statusCode);
</code></pre>
<!-- more -->
<h2 id="post">POST</h2>
<pre><code class="language-php">/**
 * @param string $url 请求 url
 * @param array $params 参数
 * @return mixed
 */
function curl_post(string $url, array $params = [])
{
    // 初始化一个curl会话
    $ch = curl_init();

    // 需要获取的url地址
    curl_setopt($ch, CURLOPT_URL, $url);
    // 启用时会将头文件的信息作为数据流输出
    curl_setopt($ch, CURLOPT_HEADER, 0);
    // 启用 返回原生的(raw)输出
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    //不做证书校验,部署在linux环境下请改为true
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    // 在发起连接前等待的时间，如果设置为0，则无限等待
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);
    // 启用时会发送一个常规的POST请求，类型为：application/x-www-form-urlencoded，就像表单提交的一样
    curl_setopt($ch, CURLOPT_POST, 1);
    // 全部数据使用HTTP协议中的&quot;POST&quot;操作来发送。要发送文件，在文件名前面加上@前缀并使用完整路径。这个参数可以通过urlencoded后的字符串类似'para1=val1&amp;para2=val2&amp;...'或使用一个以字段名为键值，字段数据为值的数组。如果value是一个数组，Content-Type头将会被设置成multipart/form-data
    // 传递一个数组到CURLOPT_POSTFIELDS，cURL会把数据编码成 multipart/form-data，而然传递一个URL-encoded字符串时，数据会被编码成 application/x-www-form-urlencoded
    curl_setopt($ch, CURLOPT_POSTFIELDS, $params);

    /*
    // 或者传递一个 json 类型 $params 要 json_encode() 转义
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Content-Type: application/json' // 一个用来设置HTTP头字段的数组
    ]);
    */
    // 	执行一个curl会话
    $contents = curl_exec($ch);
    // 关闭一个curl会话
    curl_close($ch);
    return $contents;
}

$url = 'xxxxx'; // 提交的 url
$data = array('name' =&gt; 'Foo', 'file' =&gt; '@/home/user/test.png');
var_dump(curl_post($url, $data));
</code></pre>
<h2 id="raw">Raw</h2>
<pre><code class="language-php">/**
 * @param string $url 请求 url
 * @param string $data 参数
 * @return mixed
 */
function curl_post_raw(string $url, string $data)
{
    // 初始化一个curl会话
    $ch = curl_init();

    // 需要获取的url地址
    curl_setopt($ch, CURLOPT_URL, $url);
    // 启用时会将头文件的信息作为数据流输出
    curl_setopt($ch, CURLOPT_HEADER, 0);
    // 启用 返回原生的(raw)输出
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    //不做证书校验,部署在linux环境下请改为true
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    // 在发起连接前等待的时间，如果设置为0，则无限等待
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);
    // 启用时会发送一个常规的POST请求，类型为：application/x-www-form-urlencoded，就像表单提交的一样
    curl_setopt($ch, CURLOPT_POST, 1);

    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
    // // 一个用来设置HTTP头字段的数组
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Content-Type: text'
    ]);
    // 	执行一个curl会话
    $contents = curl_exec($ch);
    // 关闭一个curl会话
    curl_close($ch);
    return $contents;
}
</code></pre>
<h2 id="可以访问请求的原始数据的只读流">可以访问请求的原始数据的只读流</h2>
<pre><code class="language-php">file_get_contents(&quot;php://input&quot;)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[死锁]]></title>
        <id>http://weakcc.github.io/post/si-suo/</id>
        <link href="http://weakcc.github.io/post/si-suo/">
        </link>
        <updated>2021-10-21T02:50:25.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="什么是死锁">什么是死锁</h1>
<p>多线程以及多进程改善了系统资源的利用率并提高了系统的处理能力，然而并发执行也带来了新的问题 一一 <strong>死锁</strong>。</p>
<p>死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace) ) ，若无外力作用，这些进程（线程）都将无法向前推进。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="什么是死锁">什么是死锁</h1>
<p>多线程以及多进程改善了系统资源的利用率并提高了系统的处理能力，然而并发执行也带来了新的问题 一一 <strong>死锁</strong>。</p>
<p>死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace) ) ，若无外力作用，这些进程（线程）都将无法向前推进。</p>
<!-- more -->
<p>怎么理解死锁呢？</p>
<p>先看生活中的一个实例，2个人一起吃饭但是只有一双筷子，2人轮流吃（当每个人同时拥有2只筷子才能吃，甲吃完，已在吃）。<br>
某一个时候，甲拿了左筷子，已拿了右筷子，2个人都同时占用一个资源，等待另一个资源，这个时候甲在等待乙吃完并释放它占有的筷子，同理，乙也在等待甲吃完并释放它占有的筷子，这样就陷入了一个死循环，谁也无法继续吃饭。</p>
<p>计算机中也是如此，如计算机系统中只有一台打印机和一台输入设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。<br>
这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</p>
<p>关于死锁的一些结论：</p>
<ol>
    <li>参与死锁的进程数至少为两个</li>
    <li>参与死锁的所有进程均等待资源</li>
    <li>参与死锁的进程至少有两个已经占有资源</li>
    <li>死锁进程是系统中当前进程集合的一个子集</li>
    <li>死锁会浪费大量系统资源，甚至导致系统崩溃</li>
</ol>
<h1 id="死锁与饥饿">死锁与饥饿</h1>
<p>饥饿（Starvation）指一个进程一直得不到资源。<br>
死锁和饥饿都是由于进程竞争资源而引起的。饥饿一般不占有资源，死锁进程一定占有资源。</p>
<h1 id="资源的类型">资源的类型</h1>
<blockquote>
<p>https://zhuanlan.zhihu.com/p/308300980</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP生成随机头像]]></title>
        <id>http://weakcc.github.io/post/php-sheng-cheng-sui-ji-tou-xiang/</id>
        <link href="http://weakcc.github.io/post/php-sheng-cheng-sui-ji-tou-xiang/">
        </link>
        <updated>2021-10-21T02:26:41.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-php">&lt;?php

if (!function_exists('make_avatar')) {
    function make_avatar($email)
    {
        $md5_email = md5($email);
        return &quot;https://api.multiavatar.com/{$md5_email}.png&quot;;
    }
}

$src  = make_avatar('111111@qq.com');
var_dump($src);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的遍历及代码实现]]></title>
        <id>http://weakcc.github.io/post/er-cha-shu-de-bian-li-ji-dai-ma-shi-xian/</id>
        <link href="http://weakcc.github.io/post/er-cha-shu-de-bian-li-ji-dai-ma-shi-xian/">
        </link>
        <updated>2021-10-07T00:54:03.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="遍历">遍历</h1>
<h2 id="前序遍历">前序遍历</h2>
<p>如果二叉树为空，则返回空，否则从根节点开始，先遍历左子树，再遍历右子树<br>
<img src="http://weakcc.github.io/post-images/1633568114149.jpeg" alt="" loading="lazy"></p>
<h2 id="中序遍历">中序遍历</h2>
<p>如果是空树，返回空，否则从左子树最左侧的节点开始，然后从左到右依次遍历左子树，真正的根节点，最后是右子树（依然是从最左侧节点开始从左到右的顺序遍历）<br>
<img src="http://weakcc.github.io/post-images/1633568152256.jpeg" alt="" loading="lazy"></p>
<h2 id="后序遍历">后序遍历</h2>
<p>如果是空树，返回空，否则还是从左子树最左侧的节点开始，先遍历完叶子节点，再遍历父节点，遍历完左子树后，直接从右子树最左侧节点开始，按照和左子树同样的顺序遍历完右子树，最后访问根节点<br>
<img src="http://weakcc.github.io/post-images/1633568168107.jpeg" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="遍历">遍历</h1>
<h2 id="前序遍历">前序遍历</h2>
<p>如果二叉树为空，则返回空，否则从根节点开始，先遍历左子树，再遍历右子树<br>
<img src="http://weakcc.github.io/post-images/1633568114149.jpeg" alt="" loading="lazy"></p>
<h2 id="中序遍历">中序遍历</h2>
<p>如果是空树，返回空，否则从左子树最左侧的节点开始，然后从左到右依次遍历左子树，真正的根节点，最后是右子树（依然是从最左侧节点开始从左到右的顺序遍历）<br>
<img src="http://weakcc.github.io/post-images/1633568152256.jpeg" alt="" loading="lazy"></p>
<h2 id="后序遍历">后序遍历</h2>
<p>如果是空树，返回空，否则还是从左子树最左侧的节点开始，先遍历完叶子节点，再遍历父节点，遍历完左子树后，直接从右子树最左侧节点开始，按照和左子树同样的顺序遍历完右子树，最后访问根节点<br>
<img src="http://weakcc.github.io/post-images/1633568168107.jpeg" alt="" loading="lazy"></p>
<!-- more -->
<p>不同的遍历方式从不同维度将二叉树这种非线性的结构变成了某种意义上的线性序列，从而方便计算机操作。</p>
<h1 id="代码">代码</h1>
<p>二叉树的遍历其实就是个递归的过程，所以对应算法也采用递归来实现。</p>
<p>我们以二叉链表的方式来存储数组，对应的前序、中序、后序实现代码如下</p>
<pre><code class="language-php">&lt;?php

// 二叉链表节点
class Node
{
    public $data;
    public $left = null;
    public $right = null;

    public function __construct($data)
    {
        $this-&gt;data = $data;
    }
}

/**
 * 前序遍历
 * 如果二叉树为空，则返回空，否则从根节点开始，先遍历左子树，再遍历右子树
 * @param Node $tree
 */
function preOrderTraverse($tree)
{
    if ($tree === null) {
        return;
    }
    printf(&quot;%s\n&quot;, $tree-&gt;data);
    preOrderTraverse($tree-&gt;left);
    preOrderTraverse($tree-&gt;right);
}

/**
 * 中序遍历
 * 如果二叉树为空，则返回空，否则从左子树最左侧的节点开始，然后从左到右依次遍历左子树，真正的根节点，最后是右子树（依然是从最左侧节点开始从左到右的顺序遍历）
 * @param Node $tree
 */
function midOrderTraverse($tree)
{
    if ($tree === null) {
        return;
    }
    midOrderTraverse($tree-&gt;left);
    printf(&quot;%s\n&quot;, $tree-&gt;data);
    midOrderTraverse($tree-&gt;right);
}

/**
 * 后序遍历
 * 如果二叉树为空，则返回空，否则从左子树最左侧的节点开始，先遍历完叶子节点，再遍历父节点，遍历完左子树后，直接从右子树最左侧节点开始，按照和左子树同样的顺序遍历完右子树，最后访问根节点
 * @param Node $tree
 */
function postOrderTraverse($tree)
{
    if ($tree === null) {
        return;
    }
    postOrderTraverse($tree-&gt;left);
    postOrderTraverse($tree-&gt;right);
    printf(&quot;%s\n&quot;, $tree-&gt;data);
}

// 节点树
$node1 = new Node('A');
$node2 = new Node('B');
$node3 = new Node('C');
$node1-&gt;left = $node2;
$node1-&gt;right = $node3;
// 前序遍历
preOrderTraverse($node1);
print(&quot;========\n&quot;);
// 中序遍历
midOrderTraverse($node1);
print(&quot;========\n&quot;);
// 后序遍历
postOrderTraverse($node1);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel 搭建自己的 WebSocket 服务器]]></title>
        <id>http://weakcc.github.io/post/laravel-da-jian-zi-ji-de-websocket-fu-wu-qi/</id>
        <link href="http://weakcc.github.io/post/laravel-da-jian-zi-ji-de-websocket-fu-wu-qi/">
        </link>
        <updated>2021-10-06T09:51:25.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="准备">准备</h4>
<pre><code>laravel new weakcc
cd weakcc/
valet link weakcc
composer require laravel/ui
php artisan ui vue --auth
npm install &amp;&amp; npm run dev
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h4 id="准备">准备</h4>
<pre><code>laravel new weakcc
cd weakcc/
valet link weakcc
composer require laravel/ui
php artisan ui vue --auth
npm install &amp;&amp; npm run dev
</code></pre>
<!-- more -->
<p>更新.env</p>
<pre><code>APP_NAME=weakcc
APP_URL=http://weakcc.test/
DB_DATABASE=weakcc
DB_USERNAME=root
DB_PASSWORD=123456

BROADCAST_DRIVER=pusher

// 因为自己搭建的随意添加，唯一注意的就是 APP_KEY 前后端要保持一致 
PUSHER_APP_ID=123456789
PUSHER_APP_KEY=123
PUSHER_APP_SECRET=123456
</code></pre>
<p>数据迁移</p>
<pre><code>php artisan migrate
</code></pre>
<blockquote>
<p>如果需要使用 <code>PrivateChannel</code> 或 <code>PresenceChannel</code> ，需要解除 <code>config/app.php</code> 下 <code>App\Providers\BroadcastServiceProvider::class</code> 注释</p>
</blockquote>
<p>安装扩展</p>
<pre><code>composer require beyondcode/laravel-websockets
</code></pre>
<p>加载配置</p>
<pre><code>php artisan vendor:publish --provider=&quot;BeyondCode\LaravelWebSockets\WebSocketsServiceProvider&quot; --tag=&quot;migrations&quot;
php artisan migrate
php artisan vendor:publish --provider=&quot;BeyondCode\LaravelWebSockets\WebSocketsServiceProvider&quot; --tag=&quot;config&quot;
</code></pre>
<p>调试仪表板，浏览器打开 <code>http://weakcc.test/laravel-websockets</code><br>
更新 <code>config/broadcasting.php</code> 下 <code>pusher</code> 配置</p>
<pre><code>'options' =&gt; [
    'cluster' =&gt; env('PUSHER_APP_CLUSTER'),
    'host' =&gt; '127.0.0.1',
    'port' =&gt; 6001,
    'scheme' =&gt; 'http'
],
</code></pre>
<p>解除 <code>resources/js/bootstrap.js</code> 注释并更新如下</p>
<pre><code>import Echo from 'laravel-echo';

window.Pusher = require('pusher-js');

window.Echo = new Echo({
    broadcaster: 'pusher',
    key: '123', // 要跟后台保持一致
    wsHost: window.location.hostname,
    wsPort: 6001,
    disableStats: true,
});
</code></pre>
<p>安装前端依赖包</p>
<pre><code>npm install --save laravel-echo pusher-js
</code></pre>
<p>运行服务</p>
<pre><code>php artisan websockets:serve
</code></pre>
<blockquote>
<p>.env 里的 APP_URL 一定要修改，不然寻址会出现问题</p>
</blockquote>
]]></content>
    </entry>
</feed>