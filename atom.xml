<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2021-03-16T00:42:19.328Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[使用 Laradock 搭建基于 Docker 的 PHP 开发环境]]></title>
        <id>http://weakcc.github.io/post/shi-yong-laradock-da-jian-ji-yu-docker-de-php-kai-fa-huan-jing/</id>
        <link href="http://weakcc.github.io/post/shi-yong-laradock-da-jian-ji-yu-docker-de-php-kai-fa-huan-jing/">
        </link>
        <updated>2021-03-15T07:31:19.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="首先将-laradock-项目代码克隆到本地">首先将 Laradock 项目代码克隆到本地</h1>
<pre><code class="language-shell">git clone https://github.com/Laradock/laradock.git
</code></pre>
<h1 id="进入-laradock-目录将-env-example-重命名为-env">进入 laradock 目录将 env-example 重命名为 .env</h1>
<pre><code class="language-shell">cp env-example .env
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="首先将-laradock-项目代码克隆到本地">首先将 Laradock 项目代码克隆到本地</h1>
<pre><code class="language-shell">git clone https://github.com/Laradock/laradock.git
</code></pre>
<h1 id="进入-laradock-目录将-env-example-重命名为-env">进入 laradock 目录将 env-example 重命名为 .env</h1>
<pre><code class="language-shell">cp env-example .env
</code></pre>
<!-- more -->
<p>编辑<code>.env</code>文件</p>
<pre><code># 编辑
APP_CODE_PATH_HOST=../ # 项目路径
CHANGE_SOURCE=true # 切换源
WORKSPACE_TIMEZONE=PRC # 时区
PHP_VERSION=7.3
MYSQL_VERSION=8.0
# 新增
DB_HOST=mysql
REDIS_HOST=redis
QUEUE_HOST=beanstalkd
</code></pre>
<h1 id="运行容器">运行容器</h1>
<pre><code class="language-shell">docker-compose up -d nginx mysql redis beanstalkd
</code></pre>
<h1 id="创建项目">创建项目</h1>
<pre><code class="language-shell">composer create-project --prefer-dist laravel/laravel test
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1615796925712.png" alt="" loading="lazy"></figure>
<h1 id="做-nginx-配置">做 nginx 配置</h1>
<p><img src="http://weakcc.github.io/post-images/1615797075338.png" alt="" loading="lazy"><br>
<img src="http://weakcc.github.io/post-images/1615797081492.png" alt="" loading="lazy"><br>
重启 nginx</p>
<pre><code class="language-shell">docker-compose up -d nginx
</code></pre>
<p>就可以通过浏览器访问了。</p>
<h1 id="错误">错误</h1>
<p>问题：<br>
ERROR: for nginx  Cannot start service nginx: Ports are not available: port is already allocated.<br>
<img src="http://weakcc.github.io/post-images/1615794973501.png" alt="" loading="lazy"><br>
解决：<br>
指定80端口已经被占用，关闭相应的服务再重新运行上述命令即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker 安装并配置 Redis]]></title>
        <id>http://weakcc.github.io/post/docker-an-zhuang-bing-pei-zhi-redis/</id>
        <link href="http://weakcc.github.io/post/docker-an-zhuang-bing-pei-zhi-redis/">
        </link>
        <updated>2021-03-15T04:35:01.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="选择一个合适的-docker-版本">选择一个合适的 docker 版本</h1>
<p><a href="https://hub.docker.com/_/redis?tab=tags&amp;page=1&amp;ordering=last_updated">https://hub.docker.com/_/redis?tab=tags&amp;page=1&amp;ordering=last_updated</a></p>
<!-- more -->
<h1 id="使用-docker-安装-redis">使用 docker 安装 redis</h1>
<pre><code class="language-shell">sudo docker pull redis
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1615783536958.png" alt="" loading="lazy"></figure>
<h1 id="准备-redis-的配置文件">准备 redis 的配置文件</h1>
<p>redis 中文官方网站：<a href="http://www.redis.cn/download.html">http://www.redis.cn/download.html</a><br>
<img src="http://weakcc.github.io/post-images/1615783307536.png" alt="" loading="lazy"><br>
解压<br>
<img src="http://weakcc.github.io/post-images/1615783445135.png" alt="" loading="lazy"></p>
<h1 id="修改-redisconf-配置文件">修改 redis.conf 配置文件</h1>
<ul>
<li>bind 127.0.0.1 # 注释掉，使 redis 可以外部访问</li>
<li>daemonize no # 用守护线程的方式启动</li>
<li>requirepass 你的密码 # 给 redis 设置密码</li>
<li>appendonly yes # redis 持久化开启</li>
</ul>
# 创建本地与 docker 映射的目录
```shell
sudo mkdir /data/redis
sudo mkdir /data/redis/data
```
<p>把配置文件<code>redis.conf</code>拷贝到刚才创建好的<code>/data/redis</code>目录下</p>
<h1 id="启动-docker">启动 docker</h1>
<pre><code class="language-shell">sudo docker run -p 6379:6379 --name redis -v /data/redis/redis.conf:/etc/redis/redis.conf  -v /data/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes
</code></pre>
<p>参数解释：</p>
<blockquote>
<p>-p 6379:6379:把容器内的6379端口映射到宿主机6379端口<br>
-v /data/redis/redis.conf:/etc/redis/redis.conf：把宿主机配置好的 redis.conf 放到容器内的这个位置中<br>
-v /data/redis/data:/data：把 redis 持久化的数据在宿主机内显示，做数据备份<br>
redis-server /etc/redis/redis.conf：这个是关键配置，让 redis 不是无配置启动，而是按照这个 redis.conf 的配置启动<br>
-appendonly yes：redis 启动后数据持久化</p>
</blockquote>
<h1 id="查看是否启动成功">查看是否启动成功</h1>
<p>是否启动成功</p>
<pre><code class="language-shell">sudo docker ps
</code></pre>
<p>查看一下日志（没有启动成功也可以通过日志查看原因）</p>
<pre><code>sudo docker logs redis
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://weakcc.github.io/post-images/1615784431566.png" alt="" loading="lazy"></figure>
<blockquote>
<p>https://blog.csdn.net/qq_17623363/article/details/106418353</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[悲观锁和乐观锁]]></title>
        <id>http://weakcc.github.io/post/bei-guan-suo-he-le-guan-suo/</id>
        <link href="http://weakcc.github.io/post/bei-guan-suo-he-le-guan-suo/">
        </link>
        <updated>2021-03-15T00:18:20.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="悲观锁">悲观锁</h1>
<p>在关系数据库管理系统里，悲观并发控制（又名<code>悲观锁</code>，Pessimistic Concurrency Control，缩写<code>PCC</code>）是一种并发控制的方法。</p>
<p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<b>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</b>）。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="悲观锁">悲观锁</h1>
<p>在关系数据库管理系统里，悲观并发控制（又名<code>悲观锁</code>，Pessimistic Concurrency Control，缩写<code>PCC</code>）是一种并发控制的方法。</p>
<p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<b>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</b>）。</p>
<!-- more -->
<pre><code class="language-mysql">
//0.开始事务            
begin;/begin work;/start transaction; (三者选一就可以)              
//1.查询出商品信息               
select status from t_goods where id=1 for update;              
//2.根据商品信息生成订单                
insert into t_orders (id,goods_id) values (null,1);              
//3.修改商品 status 为2               
update t_goods set status=2;              
//4.提交事务             
commit;

</code></pre>
<p>悲观并发控制实际上是<code>先取锁再访问</code>的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。<br>
需要注意的是，<code>FOR UPDATE</code> 生效需要同时满足两个条件时才生效：</p>
<ul>
    <li>数据库的引擎为 innoDB</li>
    <li>操作位于事务块中（BEGIN/COMMIT）</li>
</ul>
<h1 id="乐观锁">乐观锁</h1>
<p>在关系数据库管理系统里，乐观并发控制（又名<code>乐观锁</code>，Optimistic Concurrency Control，缩写<code>OCC</code>）是一种并发控制的方法。</p>
<p>乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制<code>version</code>和 CAS（Compare And Swap 比较与交换）算法实现（<b>乐观锁适用于多读的应用类型，这样可以提高吞吐量</b>）。</p>
<p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<pre><code class="language-mysql">
1.查询出商品信息
select (status,status,version) from t_goods where id=#{id}
2.根据商品信息生成订单
3.修改商品 status 为2
update t_goods set status=2,version=version+1 where id=#{id} and version=#{version};

</code></pre>
<p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。<br>
需要注意的是，如果运用的不是版本号而是商品库存等其他字段可能会出现<code>ABA</code>问题：</p>
<p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <code>ABA</code> 问题。</p>
<p>使用场景：</p>
<ul>
    <li>响应速度：如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁</li>
    <li>冲突频率：如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大</li>
    <li>重试代价：如果重试代价大，建议采用悲观锁</li>
</ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP 在操作断点续传时文件如何分割合并]]></title>
        <id>http://weakcc.github.io/post/php-zai-cao-zuo-duan-dian-xu-chuan-shi-wen-jian-ru-he-fen-ge-he-bing/</id>
        <link href="http://weakcc.github.io/post/php-zai-cao-zuo-duan-dian-xu-chuan-shi-wen-jian-ru-he-fen-ge-he-bing/">
        </link>
        <updated>2021-03-02T02:17:45.000Z</updated>
        <summary type="html"><![CDATA[<p>php 实现断点续传，就需要把大文件分割成多个小文件，然后单个上传。传完后在合并。</p>
]]></summary>
        <content type="html"><![CDATA[<p>php 实现断点续传，就需要把大文件分割成多个小文件，然后单个上传。传完后在合并。</p>
<!-- more -->
<pre><code class="language-php">&lt;?php

/**
 * 分隔文件
 */
function file_split($filePath, $tmpDir = &quot;tmp&quot;, $fileSize = 1024)
{
    $fp = fopen($filePath, 'rb');
    $i = 0;
    $no = 1;
    while (!feof($fp)) {
        $file = fread($fp, $fileSize);
        $fileName = pathinfo($filePath, PATHINFO_FILENAME);
        $tmpFp = fopen('./' . $tmpDir . '/' . $fileName . sprintf('%04d', $no) . '.' . $i . '-' . ($i + $fileSize) . '.tmp', 'wb');
        fwrite($tmpFp, $file, $fileSize);
        fclose($tmpFp);
        $i += $fileSize + 1;
        $no++;
    }
    fclose($fp);
}

/**
 * 合并文件
 */
function file_merge($tmpDir, $mergeFileName = 'merge.zip', $fileSize = 1024)
{
    $tmpFilePaths = glob($tmpDir . '/*.tmp');
    @unlink($mergeFileName);
    $fp = fopen($mergeFileName, 'w+');
    foreach ($tmpFilePaths as $v) {
        $tmpFp = fopen($v, 'rb');
        $content = fread($tmpFp, $fileSize);
        fwrite($fp, $content, $fileSize);
        unset($content);
        unlink($v);
        fclose($tmpFp);
    }
    fclose($fp);
}

$dir = 'tmp';
// 切割文件
file_split('./1.zip', $dir);
// 合并文件
file_merge($dir);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二维数组根据某个字段排序]]></title>
        <id>http://weakcc.github.io/post/er-wei-shu-zu-gen-ju-mou-ge-zi-duan-pai-xu/</id>
        <link href="http://weakcc.github.io/post/er-wei-shu-zu-gen-ju-mou-ge-zi-duan-pai-xu/">
        </link>
        <updated>2021-01-29T07:13:28.000Z</updated>
        <summary type="html"><![CDATA[<pre><code class="language-php">array_multisort(array_column($array, 'key'), SORT_DESC, $array);
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code class="language-php">array_multisort(array_column($array, 'key'), SORT_DESC, $array);
</code></pre>
<!-- more -->
<pre><code class="language-php">&lt;?php

$arr = [
    [
        'a' =&gt; '1',
        'b' =&gt; '你'
    ],
    [
        'a' =&gt; '3',
        'b' =&gt; '我'
    ],
    [
        'a' =&gt; '2',
        'b' =&gt; '他'
    ],
];

array_multisort(array_column($arr, 'a'), SORT_ASC, $arr);

print_r($arr);

//Array
//(
//    [0] =&gt; Array
//    (
//            [a] =&gt; 1
//            [b] =&gt; 你
//        )
//
//    [1] =&gt; Array
//(
//            [a] =&gt; 2
//            [b] =&gt; 他
//        )
//
//    [2] =&gt; Array
//(
//            [a] =&gt; 3
//            [b] =&gt; 我
//        )
//
//)
</code></pre>
<!-- more -->
]]></content>
    </entry>
</feed>