<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2020-11-28T08:39:15.901Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[优雅地实现在 Python 退出时强制运行一段代码]]></title>
        <id>http://weakcc.github.io/post/you-ya-di-shi-xian-zai-python-tui-chu-shi-qiang-zhi-yun-xing-yi-duan-dai-ma/</id>
        <link href="http://weakcc.github.io/post/you-ya-di-shi-xian-zai-python-tui-chu-shi-qiang-zhi-yun-xing-yi-duan-dai-ma/">
        </link>
        <updated>2020-11-28T08:30:15.000Z</updated>
        <summary type="html"><![CDATA[<p>如果有这样一个场景，你要给一个项目开发测试程序，程序开始运行的时候，会创建初始环境，测试完成以后，会清理环境。<br>
使用 Python 自带的 <code>atexit</code> 这个模块</p>
<pre><code class="language-python">import atexit

@atexit.register
def clean():
    print(&quot;清理环境相关的代码&quot;)

def test():
    print(&quot;这里先执行&quot;)
    example = {'a': 1, 'b': 2}
    print(example['c'])  # 显然这里会报错

test()

# 这里先执行
# Traceback (most recent call last):
# 清理环境相关的代码
#   File &quot;/Users/dupeng/m7/Python/Web/demo.py&quot;, line 15, in &lt;module&gt;
#     test()
#   File &quot;/Users/dupeng/m7/Python/Web/demo.py&quot;, line 12, in test
#     print(example['c'])  # 显然这里会报错
# KeyError: 'c'
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>如果有这样一个场景，你要给一个项目开发测试程序，程序开始运行的时候，会创建初始环境，测试完成以后，会清理环境。<br>
使用 Python 自带的 <code>atexit</code> 这个模块</p>
<pre><code class="language-python">import atexit

@atexit.register
def clean():
    print(&quot;清理环境相关的代码&quot;)

def test():
    print(&quot;这里先执行&quot;)
    example = {'a': 1, 'b': 2}
    print(example['c'])  # 显然这里会报错

test()

# 这里先执行
# Traceback (most recent call last):
# 清理环境相关的代码
#   File &quot;/Users/dupeng/m7/Python/Web/demo.py&quot;, line 15, in &lt;module&gt;
#     test()
#   File &quot;/Users/dupeng/m7/Python/Web/demo.py&quot;, line 12, in test
#     print(example['c'])  # 显然这里会报错
# KeyError: 'c'
</code></pre>
<!-- more -->
<p><code>atexit</code> 使用中有下面几个注意事项：</p>
<ul>
<li>你可以注册多个退出函数，他们会按照注册时间从晚到早以此执行。例如
<pre><code class="language-python">import atexit

@atexit.register
def clean_1():
    ...

@atexit.register
def clean_2():
    ...
</code></pre>
<p>会先运行 <code>clean_2()</code> 后运行 <code>clean_1()</code></li></p>
<li>如果 `clean()` 函数有参数，那么你可以不用装饰器，而是直接调用 `atexit.register(clean_1, 参数1, 参数2, 参数3='xxx')`</li>
<li>如果程序是被你没有处理过的系统信号杀死的，那么注册的函数无法正常执行</li>
<li>如果发生了严重的Python内部错误，你注册的函数无法正常执行</li>
<li>如果你手动调用了 `os._exit()`，你注册的函数无法正常执行</li>
</ul>
<blockquote>
<p>https://mp.weixin.qq.com/s/Q65F49ZhFV02mqVPyxILHg</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL写sql的21个好习惯，学习工作效率翻倍]]></title>
        <id>http://weakcc.github.io/post/mysql-xie-sql-de-21-ge-hao-xi-guan-xue-xi-gong-zuo-xiao-lu-fan-bei/</id>
        <link href="http://weakcc.github.io/post/mysql-xie-sql-de-21-ge-hao-xi-guan-xue-xi-gong-zuo-xiao-lu-fan-bei/">
        </link>
        <updated>2020-11-25T01:44:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>https://learnku.com/articles/51820</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python正则]]></title>
        <id>http://weakcc.github.io/post/python-zheng-ze/</id>
        <link href="http://weakcc.github.io/post/python-zheng-ze/">
        </link>
        <updated>2020-10-27T01:23:45.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1603761872681.jpeg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python装饰器]]></title>
        <id>http://weakcc.github.io/post/python-zhuang-shi-qi/</id>
        <link href="http://weakcc.github.io/post/python-zhuang-shi-qi/">
        </link>
        <updated>2020-10-27T01:06:05.000Z</updated>
        <summary type="html"><![CDATA[<p><code>装饰器(Decorator)</code>本质上就是个接受一个函数作为参数，并返回一个函数的高阶函数。</p>
<p><b>装饰器的作用</b>：可以在代码运行期间动态增加函数功能，即动态扩展函数功能的作用。</p>
]]></summary>
        <content type="html"><![CDATA[<p><code>装饰器(Decorator)</code>本质上就是个接受一个函数作为参数，并返回一个函数的高阶函数。</p>
<p><b>装饰器的作用</b>：可以在代码运行期间动态增加函数功能，即动态扩展函数功能的作用。</p>
<!-- more -->
<h3 id="第一步">第一步</h3>
<p>准备一个简单的函数，并知道函数也是一个对象，这个对象有一个 <code>_name_</code> 的属性。</p>
<pre><code class="language-python">def show(a, b):
    print(a, b)

show(1, 2)
print(show.__name__)

# 1 2
# show
</code></pre>
<h3 id="第二步">第二步</h3>
<p>装饰器简单语法的使用以及 <code>@</code> 语法的使用。</p>
<pre><code class="language-python">def log(func):
    def wrapper(*args, **kwargs):
        print(&quot;我在show之前打印&quot;)
        func(*args, **kwargs)
        print(&quot;我在show之后打印&quot;)
    return wrapper

@log
def show(a, b):
    print(a, b)

show(1, 2)
print(show.__name__)

# 我在show之前打印
# 1 2
# 我在show之后打印
# wrapper
</code></pre>
<blockquote>
<p>扩展了 <code>show</code> 函数本身的功能，调用函数对象 <code>__name__</code> 的属性得到不再是 <code>show</code> 而是 <code>wrapper</code>，显示是不合理的。</p>
</blockquote>
<h3 id="第三步">第三步</h3>
<p>一个完整的 <code>decorator</code> 的写法，<code>functools</code> 库的调用，<code>@functools.wrap()</code> 的使用。</p>
<pre><code class="language-python">import functools
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(&quot;我在show之前打印&quot;)
        func(*args, **kwargs)
        print(&quot;我在show之后打印&quot;)
    return wrapper

@log
def show(a, b):
    print(a, b)

show(1, 2)
print(show.__name__)

# 我在show之前打印
# 1 2
# 我在show之后打印
# show
</code></pre>
<h3 id="第四步">第四步</h3>
<p>学会当一个装饰器本身需要传入参数时，如何写装饰器。</p>
<pre><code class="language-python">import functools
def log(text):
    def decor(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            print(&quot;我在show之前打印&quot;)
            print(&quot;====&quot;, text, &quot;====&quot;)
            func(*args, **kwargs)
            print(&quot;我在show之后打印&quot;)
        return wrapper
    return decor

@log(&quot;我是传入的参数&quot;)
def show(a, b):
    print(a, b)

show(1, 2)
print(show.__name__)

# 我在show之前打印
# ==== 我是传入的参数 ====
# 1 2
# 我在show之后打印
# show
</code></pre>
<h3 id="第五步">第五步</h3>
<p>类装饰器</p>
<pre><code class="language-python">class A(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print(&quot;== before func ==&quot;)
        return self.func(*args, **kwargs)


@A
def test_func(name):
    return 'hello ' + name


if __name__ == '__main__':
    t = test_func(&quot;小小&quot;)
    print(t)

# == before func ==
# hello 小小
</code></pre>
<h3 id="第六步">第六步</h3>
<p>带参数的类装饰器</p>
<pre><code class="language-python">from functools import wraps


class A(object):
    def __init__(self, name):
        self.name = name

    def __call__(self, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            print(&quot;== before func ==&quot;)
            print(self.name)
            return func(*args, **kwargs)

        return wrapper


@A(&quot;小明&quot;)
def test_func(name):
    return 'hello ' + name


if __name__ == '__main__':
    t = test_func(&quot;小小&quot;)
    print(t)
    
# == before func ==
# 小明
# hello 小小
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python类多继承]]></title>
        <id>http://weakcc.github.io/post/python-lei-duo-ji-cheng/</id>
        <link href="http://weakcc.github.io/post/python-lei-duo-ji-cheng/">
        </link>
        <updated>2020-10-26T00:35:27.000Z</updated>
        <summary type="html"><![CDATA[<p>Python的类如果继承了多个类，那么其寻找方法的方式有两种，分别是：深度优先和广度优先。<br>
<img src="http://weakcc.github.io/post-images/1603672655150.jpg" alt="" loading="lazy"></p>
<ul>
<li>当类是经典类时，多继承情况下，会按照深度优先方式查找</li>
<li>当类是新式类时，多继承情况下，会按照广度优先方式查找</li>
</ul>]]></summary>
        <content type="html"><![CDATA[<p>Python的类如果继承了多个类，那么其寻找方法的方式有两种，分别是：深度优先和广度优先。<br>
<img src="http://weakcc.github.io/post-images/1603672655150.jpg" alt="" loading="lazy"></p>
<ul>
<li>当类是经典类时，多继承情况下，会按照深度优先方式查找</li>
<li>当类是新式类时，多继承情况下，会按照广度优先方式查找</li>
</ul>
<!-- more -->
<blockquote>
<p>经典类和新式类，从字面上可以看出一个老一个新，新的必然包含了跟多的功能，也是之后推荐的写法，从写法上区分的话，如果 当前类或者父类继承了 <code>object</code> 类，那么该类便是新式类，否则便是经典类。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1603672935665.jpg" alt="" loading="lazy"></figure>
<h3 id="经典类多继承">经典类多继承</h3>
<pre><code class="language-python">class D:

    def bar(self):
        print('D.bar')

class C(D):

    def bar(self):
        print('C.bar')

class B(D):

    def bar(self):
        print('B.bar')

class A(B, C):

    def bar(self):
        print('A.bar')

a = A()
# 执行bar方法时
# 首先去A类中查找，
# 如果A类中没有，则继续去B类中找，
# 如果B类中么有，则继续去D类中找，
# 如果D类中么有，则继续去C类中找，
# 如果还是未找到，则报错
# 所以，查找顺序：A --&gt; B --&gt; D --&gt; C
# 在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了
a.bar()
</code></pre>
<h3 id="新式类多继承">新式类多继承</h3>
<pre><code class="language-python">class D(object):

    def bar(self):
        print('D.bar')

class C(D):

    def bar(self):
        print('C.bar')

class B(D):

    def bar(self):
        print('B.bar')

class A(B, C):

    def bar(self):
        print('A.bar')

a = A()
# 执行bar方法时
# 首先去A类中查找，
# 如果A类中没有，则继续去B类中找，
# 如果B类中么有，则继续去C类中找，
# 如果C类中么有，则继续去D类中找，
# 如果还是未找到，则报错
# 所以，查找顺序：A --&gt; B --&gt; C --&gt; D
# 在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了
a.bar()
</code></pre>
<p>经典类：首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去D类中找，如果D类中么有，则继续去C类中找，如果还是未找到，则报错</p>
<p>新式类：首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去C类中找，如果C类中么有，则继续去D类中找，如果还是未找到，则报错</p>
<p>注意：在上述查找过程中，一旦找到，则寻找过程立即中断，便不会再继续找了。</p>
]]></content>
    </entry>
</feed>