<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2021-11-12T03:16:54.662Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[通过 MVCC（多版本并发控制）保证数据库事务的一致性]]></title>
        <id>http://weakcc.github.io/post/tong-guo-mvccduo-ban-ben-bing-fa-kong-zhi-bao-zheng-shu-ju-ku-shi-wu-de-yi-zhi-xing/</id>
        <link href="http://weakcc.github.io/post/tong-guo-mvccduo-ban-ben-bing-fa-kong-zhi-bao-zheng-shu-ju-ku-shi-wu-de-yi-zhi-xing/">
        </link>
        <updated>2021-11-12T00:18:09.000Z</updated>
        <summary type="html"><![CDATA[<p><code>MVCC</code> 的英文全称是 <strong>Multiversion Concurrency Control</strong>，中文意思是多版本并发控制技术。原理是，通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。</p>
]]></summary>
        <content type="html"><![CDATA[<p><code>MVCC</code> 的英文全称是 <strong>Multiversion Concurrency Control</strong>，中文意思是多版本并发控制技术。原理是，通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。</p>
<!-- more -->
<h2 id="undo-日志链表">undo 日志链表</h2>
<p>当 InnoDB 引擎底层开启一个新事务的时候，会分配一个全局唯一的事务 ID，该事务 ID 写入 undo 日志的同时也会存储到数据表记录簇拥索引的 <code>trx_id</code> 隐藏列中。<br>
<img src="http://weakcc.github.io/post-images/1636676416765.png" alt="" loading="lazy"><br>
另一个隐藏列 <code>roll_pointer</code> 指针会指向该记录上一个版本的 undo 日志，发生事务回滚时我们可以通过该指针找到这条记录要回滚到的版本。<br>
这样，每次记录更新后，上一个版本的值就会被存放到 undo 日志中，并且将当前最新记录的 <code>roll_pointer</code> 指针指向该 undo 日志，这样一来，所有的 <code>roll_pointer</code> 指针串成一个链表，该链表被称作版本链，版本链的头节点就是当前记录最新版本的值。<br>
🌰<br>
现在假设有一个<code>事务 A（id=50）</code>，插入了一条数据，那么此时这条数据的隐藏字段以及指向的 <code>undo log</code> 如下图所示，插入的这条数据的值是 A，因此此时<code>事务 A</code> 的 id 是 50，所以这条数据的 <code>txr_id</code> 就是 50，<code>roll_pointer</code> 指向一个空的 <code>undo log</code>，因为之前这条数据是没有的。<br>
<img src="http://weakcc.github.io/post-images/1636681437542.png" alt="" loading="lazy"><br>
接着有一个<code>事务 B</code> 跑来修改了一下这条数据，把值改成了值 B，<code>事务 B</code> 的 id 是 58，那么此时更新之前会生成一个 <code>undo log</code> 记录之前的值，然后会把 <code>roll pointer</code> 指向这个实际的 <code>undo log</code> 回滚日志，如下图所示<br>
<img src="http://weakcc.github.io/post-images/1636681605467.png" alt="" loading="lazy"><br>
接着<code>事务 C</code> 同理，如下图所示<br>
<img src="http://weakcc.github.io/post-images/1636681701729.png" alt="" loading="lazy"><br>
多个事务串行执行的时候，每个人修改了一行数据，都会更新隐藏字段 <code>txr_id</code> 和 <code>roll_pointer</code>，同时之前多个数据快照对应的 <code>undo log</code>，会通过 <code>roll_pointer</code> 指针串联起来，形成一个重要的版本链。</p>
<h2 id="readview-可读视图">ReadView （可读视图）</h2>
<p>ReadView 实际上是当前系统中所有活跃事务的列表，主要包含以下组成部分：</p>
<ul>
<li><code>m_ids</code>：在生成 ReadView 时当前系统中活跃的事务 ID 列表</li>
<li><code>min_trx_id</code>：在生成 ReadView 时当前系统中活跃的事务中最小的事务 ID，也就是 m_ids 中的最小值</li>
<li><code>max_trx_id</code>：在生成 ReadView 时系统中应该分配给下一个事务的 ID 值</li>
<li><code>creator_trx_id</code>：生成 ReadView 的事务对应的事务 ID，也就是当前事务 ID</li>
</ul>
<p>有了这个 ReadView 之后，在访问某条记录时，只需要按照下边的步骤判断该记录的某个版本是否可见：</p>
<ul>
<li>如果被访问版本的 <code>trx_id</code> 属性值与 ReadView 中的 <code>tcreator_trx_id</code> 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本记录可以被当前事务访问</li>
<li>如果被访问版本的 <code>trx_id</code> 属性值小于 ReadView 中的 <code>min_trx_id</code> 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本记录可以被当前事务访问</li>
<li>如果被访问版本的 <code>trx_id</code> 属性值大于或等于 ReadView 中的 <code>max_trx_id</code> 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本记录不可以被当前事务访问</li>
<li>如果被访问版本的 <code>trx_id</code> 属性值在 ReadView 的 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，那就需要判断一下 <code>trx_id</code> 属性值是不是在 <code>m_ids</code> 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本记录可以被访问</li>
<li>如果某个版本的记录对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录</li>
</ul>
<p>🌰<br>
假设原来数据库里就有一行数据，很早以前就有事务插入过了，事务 id 是 32，他的初始值，如下图<br>
<img src="http://weakcc.github.io/post-images/1636682975510.png" alt="" loading="lazy"><br>
接着呢，此时两个事务并发来执行了，一个<code>事务 A</code>（id=45），一个<code>事务 B</code>（id=59），<code>事务 B</code> 是要去更新这行数据的，<code>事务 A</code> 是要去读取这行数据的，此时两个事务如下<br>
<img src="http://weakcc.github.io/post-images/1636683099964.png" alt="" loading="lazy"><br>
现在<code>事务 A</code> 直接开启一个 <code>ReadView</code>，这刚 <code>ReadView</code> 里的 <code>m_ids</code> 就包含了<code>事务 A</code> 和<code>事务 B</code> 的两个 id，45 和 59，然后 <code>min_trx_id</code> 就是 45，<code>max_trx_id</code> 就是 60，<code>creator_trx_id 就是 45，是</code>事务 A` 自己。</p>
<p>这刚时候<code>事务 A</code> 第一次查询这行数据，会走一个判断，就是判断一下当前这行数据的 <code>trx_id</code> 是否小于 <code>ReadView</code> 中的 <code>min_trx_id</code>，此时发现 <code>trx_id=32</code> ，是小于 <code>ReadView</code> 里的 <code>min_trx_id</code> 就是 45 的，说明你事务开启之前，修改这行数据的事务早已提交，所以此时可以查询这行数据，如下<br>
<img src="http://weakcc.github.io/post-images/1636683428146.png" alt="" loading="lazy"><br>
接着<code>事务 B</code> 开始动手了，他把这行数据的值改为了值 B，然后这行数据的 <code>trx_id</code> 设置为自己的 id，也就是 59，同时 <code>roll_pointer</code> 指向了修改之前生成的一个 <code>undo log</code>，接着这个<code>事务 B</code> 就提交了，如下<br>
<img src="http://weakcc.github.io/post-images/1636683586822.png" alt="" loading="lazy"><br>
这个时候 <code>事务 A</code> 再次查询，此时查询的时候，会发现一个问题，那就是此时数据行里的 <code>trx_id=59</code>，那么这个 <code>trx_id</code> 是大于 <code>ReadView</code> 里的 <code>min_trx_id（45）</code>，同时小于 <code>ReadView</code> 里的 <code>max_trx_id（60）</code>，说明更新这条数据的事务，很可能就跟自己差不多是同时开启的，于是会看一下这个 <code>trx_id=59</code>，是否在 <code>ReadView</code> 的 <code>m_ids</code> 列表里的？果然，在 <code>ReadView</code> 的 <code>m_ids</code> 列表里，有 45 和 59 两个事务 id，直接证实了，这个修改数据的事务是跟自己同一时段并发执行然后提交的，所以这行数据是不能查询的，如下<br>
<img src="http://weakcc.github.io/post-images/1636683916110.png" alt="" loading="lazy"><br>
既然这行数据不能查询，那么查询什么呢？<br>
简单，顺着这条数据的 <code>roll_pointer</code> 顺着 <code>undo log</code> 日志链条往下找，就会找到最近一条 <code>undo log</code>，<code>trx_id</code> 是 32，此时发现 <code>trx_id=32</code>，是小于 <code>ReadView</code> 里的 <code>min_trx_id（45）</code>的，说明这个 <code>undo log</code> 版本必然是在<code>事务 A</code> 开启之前就执行且提交的。<br>
好了，那么就查询最近的 <code>undo log</code> 里的值就好了，这就是 <code>undo log</code> 对版本链条的作用，他可以保存一个快照链条，让你可以读到之前的快照值。如下<br>
<img src="http://weakcc.github.io/post-images/1636684163556.png" alt="" loading="lazy"><br>
多个事务并发执行的时候，<code>事务 B</code> 更新的值，通过这套 <strong>ReadView + undo log</strong> 日志链条的机制，就可以保证<code>事务 A</code> 不会读到并发执行的<code>事务 B</code> 更新的值，只会读到之前的值。</p>
<p>接着假设<code>事务 A</code> 自己更新了这行数据，改为值 A，<code>trxt_id</code>修好为 45，同时保存之前<code>事务 B</code> 修改值的快照，如下<br>
<img src="http://weakcc.github.io/post-images/1636684360943.png" alt="" loading="lazy"><br>
此时<code>事务 A</code> 来查询这条数据的值，会发现这个 <code>trx_id=45</code>，居然跟自己的 <code>ReadView</code>里的 <code>creator_trx_id（45）</code>是一样的，说明什么？</p>
<p>说明这行数据的就是自己修改的，自己修改的值当然是可以看到的，如下<br>
<img src="http://weakcc.github.io/post-images/1636684489534.png" alt="" loading="lazy"><br>
接着在事务A执行的过程中，突然开启一个<code>事务 C</code>，这个事务的 id 是 78，然后他更新了那行数据的值为值 C，还提交了，如下<br>
<img src="http://weakcc.github.io/post-images/1636684574035.png" alt="" loading="lazy"><br>
这个时候<code>事务 A</code> 再去查询，会发现当前数据的 <code>trx_id=78</code>，大于了自己的 <code>ReadView</code> 中的 <code>max_trx_id（60）</code>，此时说明了什么？</p>
<p>说明是这个 <code>事务 A</code> 开启之后，然后有一个事务更新了数据，自己当然是不能看到的，如下<br>
<img src="http://weakcc.github.io/post-images/1636684712358.png" alt="" loading="lazy"><br>
此时就会顺着 <code>undo log</code> 多版本链条往下找，先找到值 A 是自己之前修改过的版本，因为那个 <code>trx_id=45</code> 跟自己的 <code>ReadVie</code> 里的 <code>creator_trx_id</code> 是一样的，所以此时直接读取自己之前修改的那个版本，如下<br>
<img src="http://weakcc.github.io/post-images/1636684860422.png" alt="" loading="lazy"></p>
<blockquote>
<p>注：在 MySQL InnoDB 引擎中，只有 READ COMMITTD 和 REPEATABLE READ 这两种隔离级别才可以使用 MVCC，应对高并发事务，MVCC 比单纯的加行锁更有效，开销更小。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ 从入门到放弃]]></title>
        <id>http://weakcc.github.io/post/rabbitmq-cong-ru-men-dao-fang-qi/</id>
        <link href="http://weakcc.github.io/post/rabbitmq-cong-ru-men-dao-fang-qi/">
        </link>
        <updated>2021-11-11T06:24:30.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="概念说明">概念说明</h1>
<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1636619280369.png" alt="" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<h1 id="概念说明">概念说明</h1>
<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1636619280369.png" alt="" loading="lazy"></figure>
<!-- more -->
<h2 id="broker">Broker</h2>
<p>简单来说就是消息队列服务器实体。</p>
<h2 id="exchange">Exchange</h2>
<p>消息交换机，它指定消息按什么规则，路由到哪个队列。</p>
<h2 id="queue">Queue</h2>
<p>消息队列载体，每个消息都会被投入到一个或多个队列。</p>
<h2 id="binding">Binding</h2>
<p>绑定，它的作用就是把 <code>exchange</code> 和 <code>queue</code> 按照路由规则绑定起来。</p>
<h2 id="routing-key">Routing Key</h2>
<p>路由关键字，<code>exchange</code> 根据这个关键字进行消息投递。</p>
<h2 id="vhost">vhost</h2>
<p>虚拟主机，一个 <code>broker</code> 里可以开设多个 <code>vhost</code>，用作不同用户的权限分离。</p>
<h2 id="producer">producer</h2>
<p>消息生产者，就是投递消息的程序。</p>
<h2 id="consumer">consumer</h2>
<p>消息消费者，就是接受消息的程序。</p>
<h2 id="channel">channel</h2>
<p>消息通道，在客户端的每个连接里，可建立多个 <code>channel</code>，每个 <code>channel</code> 代表一个会话任务。</p>
<h2 id="使用过程">使用过程</h2>
<ul>
<li>
<ol>
<li>客户端连接到消息队列服务器，打开一个channel</li>
</ol>
</li>
<li>
<ol start="2">
<li>客户端声明一个 <code>exchange</code>，并设置相关属性</li>
</ol>
</li>
<li>
<ol start="3">
<li>客户端声明一个 <code>queue</code>，并设置相关属性</li>
</ol>
</li>
<li>
<ol start="4">
<li>客户端使用 <code>routing key</code>，在 <code>exchange</code> 和 <code>queue</code> 之间建立好绑定关系</li>
</ol>
</li>
<li>
<ol start="5">
<li>客户端投递消息到 <code>exchange</code></li>
</ol>
</li>
</ul>
<p><code>exchange</code> 接收到消息后，就根据消息的 <code>key</code> 和已经设置的 <code>binding</code>，进行消息路由，将消息投递到一个或多个队列里。</p>
<p><code>exchange</code> 也有几个类型，完全根据 <code>key</code> 进行投递的叫做 <strong>Direct</strong> 交换机，例如，绑定时设置了 <code>routing key</code>为 “abc”，那么客户端提交的消息，只有设置了 <code>key</code> 为 “abc” 的才会投递到队列。对 <code>key</code> 进行模式匹配后进行投递的叫做 <strong>Topic</strong> 交换机，符号 <b>#</b> 匹配一个或多个词，符号 <b>*</b> 匹配正好一个词。例如 “abc.#” 匹配 “abc.def.ghi”，“abc.*” 只匹配 “abc.def”。还有一种不需要 <code>key</code> 的，叫做 <strong>Fanout</strong> 交换机，它采取广播模式，一个消息进来时，投递到与该交换机绑定的所有队列。</p>
<h3 id="direct">Direct</h3>
<figure data-type="image" tabindex="2"><img src="http://weakcc.github.io/post-images/1636619505554.png" alt="" loading="lazy"></figure>
<h3 id="fanout">Fanout</h3>
<figure data-type="image" tabindex="3"><img src="http://weakcc.github.io/post-images/1636619513185.png" alt="" loading="lazy"></figure>
<h3 id="topic">Topic</h3>
<figure data-type="image" tabindex="4"><img src="http://weakcc.github.io/post-images/1636619518110.png" alt="" loading="lazy"></figure>
<p><strong>RabbitMQ</strong> 支持消息的持久化，也就是数据写在磁盘上：</p>
<ul>
<li>
<ol>
<li><code>exchange</code> 持久化，在声明时指定 <code>durable =&gt; 1</code></li>
</ol>
</li>
<li>
<ol start="2">
<li><code>queue</code> 持久化，在声明时指定 <code>durable =&gt; 1</code></li>
</ol>
</li>
<li>
<ol start="3">
<li>消息持久化，在投递时指定 <code>delivery_mode =&gt; 2</code>（1是非持久化）</li>
</ol>
</li>
</ul>
<blockquote>
<p>如果 exchange 和 queue 都是持久化的，那么它们之间的 binding 也是持久化的。如果 exchange 和 queue 两者之间有一个持久化，一个非持久化，就不允许建立绑定。</p>
</blockquote>
<h1 id="mac-下搭建-php-开发环境">Mac 下搭建 PHP 开发环境</h1>
<h2 id="安装-rabbitmq">安装 RabbitMQ</h2>
<pre><code class="language-php">brew install rabbitmq

brew install rabbitmq-c

pecl install amqp
</code></pre>
<h2 id="php-中实现消息发送和接收">PHP 中实现消息发送和接收</h2>
<p><code>send.php</code></p>
<pre><code class="language-php">&lt;?php

$exchangeName = 'demo';
$routeKey = 'hello';
$message = 'Hello World!';

// 建立 TCP 连接
$connection = new AMQPConnection(
    [
        'host' =&gt; 'localhost',
        'port' =&gt; 5672,
        'vhost' =&gt; '/',
        'login' =&gt; 'guest',
        'password' =&gt; 'guest',
    ]
);
$connection-&gt;connect() or die('Cannot connect to the broker!\n');

try {
    $channel = new AMQPChannel($connection);

    $exchange = new AMQPExchange($channel);
    $exchange-&gt;setName($exchangeName);
    $exchange-&gt;setType(AMQP_EX_TYPE_DIRECT);
    $exchange-&gt;declareExchange();

    echo 'Send Message: ' . $exchange-&gt;publish($message, $routeKey) . &quot;\n&quot;;
    echo &quot;Message Is Sent: &quot; . $message . &quot;\n&quot;;
} catch (AMQPConnectionException $e) {
    var_dump($e-&gt;getMessage());
} catch (Exception $e) {
    var_dump($e-&gt;getMessage());
}

// 断开连接
$connection-&gt;disconnect();
</code></pre>
<p><code>receive.php</code></p>
<pre><code class="language-php">&lt;?php

$exchangeName = 'demo';
$queueName = 'hello';
$routeKey = 'hello';

// 建立TCP连接
$connection = new AMQPConnection([
    'host' =&gt; 'localhost',
    'port' =&gt; '5672',
    'vhost' =&gt; '/',
    'login' =&gt; 'guest',
    'password' =&gt; 'guest'
]);
$connection-&gt;connect() or die(&quot;Cannot connect to the broker!\n&quot;);

$channel = new AMQPConnection($connection);
$exchange = new AMQPExchange($channel);
$exchange-&gt;setName($exchangeName);
$exchange-&gt;setType(AMQP_EX_TYPE_DIRECT);
echo 'Exchange Status: ' . $exchange-&gt;declareExchange() . &quot;\n&quot;;

$queue = new AMQPQueue();
$queue-&gt;setName($queueName);

echo 'Message Total: ' . $queue-&gt;declareQueue() . &quot;\n&quot;;

// 交换机和队列绑定
echo 'Queue Bind: ' . $queue-&gt;bind($exchangeName, $routeKey) . &quot;\n&quot;;

var_dump(&quot;Waiting for message...&quot;);
while(true) {
    $queue-&gt;consume('processMessage');
}

// 断开连接
$connection-&gt;disconnect();

function processMessage($envelope, $queue)
{
    $msg = $envelope-&gt;getBody();
    var_dump(&quot;Received: &quot; . $msg);
    // 手动发送ACK应答
    $queue-&gt;ack($envelope-&gt;getDeliveryTag);
}
</code></pre>
<h1 id="php-php-amqplib-库操作-rabbitmq">PHP php-amqplib 库操作 RabbitMQ</h1>
<h2 id="使用-composer-进行-rabbitmq-依赖安装">使用 composer 进行 rabbitmq 依赖安装</h2>
<pre><code class="language-shell">composer require php-amqplib/php-amqplib
</code></pre>
<h2 id="php-操作-rabbitmq-的简单示例">PHP 操作 RabbitMQ 的简单示例</h2>
<h3 id="生产者">生产者</h3>
<pre><code class="language-php">&lt;?php
require '../vendor/autoload.php';

$conf = [
    'host' =&gt; '127.0.0.1',
    'port' =&gt; 5672,
    'user' =&gt; 'guest',
    'pwd'  =&gt; 'guest',
    'vhost' =&gt; '/',
];

$exchangeName = 'kd_sms_send_ex'; // 交换机名
$queueName = 'kd_sms_send_q'; // 队列名称
$routingKey = 'sms_send'; // 路由关键字(也可以省略) 一般都带上方便交换机对消息进行不同队列的推送 如果绑定的时候使用了 $routingKey,那么在 bashic_publish 的时候也要指定 $routingKey，不然交换机无法路由到指定队列，默认就推送到不使用关键字的队列了

// 建立生产者与 mq 之间的连接
$conn = new \PhpAmqpLib\Connection\AMQPStreamConnection($conf['host'], $conf['port'], $conf['user'], $conf['pwd'], $conf['vhost']);
// 在已连接基础上建立生产者与 mq 之间的通道
$channel = $conn-&gt;channel();
/*
声明初始化交换机
参数说明：
exchange：交换机名称
type：交换机类型，常见的如fanout、direct、topic =》directirect 精准推送 fanout 广播 推送到绑定到此交换机下的所有队列 topic 组播 比如上面我绑定的关键字是sms_send，那么他可以推送到*.sms_send的所有队列
passive：只查询不创建.如果为true,如果存在这个队列,则会返回队列的信息.如果不存在这个队列..则会抛异常(与交换机不同的是,如果交换机判断存在,则返回NULL,否则异常)
durable：设置是否持久化。durable设置true表示持久化，反之是持久化。持久化可以将将换机存盘，在服务器重启时不会丢失相关信息
autoDelete：设置是否自动删除。autoDelete设置为true则表示自动删除。自动删除的前提是至少有一个队列或者交换机与这个交换器绑定的队列或者交换器都与之解绑
internal：设置是否内置的。如果设置为true，则表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式
argument：其他一些结构化参数，比如alternate-exchange
*/
$channel-&gt;exchange_declare($exchangeName, AMQP_EX_TYPE_DIRECT, false, false, false);
/*
声明初始化一条队列
参数说明：
queue：队列的名称
durable：设置是否持久化。为true则设置队列为持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息
exclusive：设置是否排他。为true则设置对列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意的三点：排他队列是基于连接可见，同一个连接的不同信道是可以同时访问同一个连接创建的排他队列；”首次“是指如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；即使该队列是持久华东，一旦连接关闭或者客户端退出，该排他队列都会自动被删除，这种队列适用于一个客户端同事发送和读取消息的应用场景
autoDelete：设置是否自动删除。为true则设置队列为自动删除。自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为：”当连接到此队列的所有客户端断开时，这个队列自动删除“，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列
arguments：设置队列的其他一些参数，如x-message-ttl等
*/
$channel-&gt;queue_declare($queueName, false, true, false, false);
// 将队列与某个交换机进行绑定，并使用路由关键字
$channel-&gt;queue_bind($queueName, $exchangeName, $routingKey);

//生成消息
$msgBody = json_encode([&quot;name&quot; =&gt; &quot;xiaomi&quot;, &quot;age&quot; =&gt; 18]);
// DELIVERY_MODE_PERSISTENT 2 消息持久化
$msg = new \PhpAmqpLib\Message\AMQPMessage($msgBody, ['content_type' =&gt; 'text/plain', 'delivery_mode' =&gt; \PhpAmqpLib\Message\AMQPMessage::DELIVERY_MODE_PERSISTENT]);
// 推送消息到某个交换机
$r = $channel-&gt;basic_publish($msg, $exchangeName, $routingKey);

// 关闭通道
$channel-&gt;close();
// 关闭连接
$conn-&gt;close();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel 速查表]]></title>
        <id>http://weakcc.github.io/post/laravel-su-cha-biao/</id>
        <link href="http://weakcc.github.io/post/laravel-su-cha-biao/">
        </link>
        <updated>2021-11-11T06:09:21.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://learnku.com/docs/laravel-cheatsheet/8.x">Laravel速查表</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP 速查表]]></title>
        <id>http://weakcc.github.io/post/php-su-cha-biao/</id>
        <link href="http://weakcc.github.io/post/php-su-cha-biao/">
        </link>
        <updated>2021-11-10T10:03:53.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.p2hp.com/phpfuncs.html">PHP 速查表</a></p>
<h1 id="本地服务器">本地服务器</h1>
<pre><code class="language-php">php -S localhost:3000
</code></pre>
<h1 id="注释">注释</h1>
<pre><code class="language-php">// 单行注释

/*
这是一个多行注释块
跨越多行
*/
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.p2hp.com/phpfuncs.html">PHP 速查表</a></p>
<h1 id="本地服务器">本地服务器</h1>
<pre><code class="language-php">php -S localhost:3000
</code></pre>
<h1 id="注释">注释</h1>
<pre><code class="language-php">// 单行注释

/*
这是一个多行注释块
跨越多行
*/
</code></pre>
<!-- more -->
<h1 id="命名约定">命名约定</h1>
<h2 id="开始结束-标记">开始/结束 标记</h2>
<pre><code class="language-php">&lt;?php
  echo &quot;Hello World&quot;;
?&gt;
</code></pre>
<h2 id="如果没有结束标记文件的其余部分将被视为-php-代码">如果没有结束标记，文件的其余部分将被视为 PHP 代码</h2>
<pre><code class="language-php">&lt;?php
  echo &quot;Hello World&quot;;
</code></pre>
<h2 id="简短的-php-语法输出">简短的 PHP 语法输出</h2>
<pre><code class="language-php">&lt;?= &quot;Hello World&quot; ?&gt;
</code></pre>
<h2 id="启用严格模式-它必须在-php-文件的第一行">启用严格模式 (它必须在 PHP 文件的第一行)</h2>
<pre><code class="language-php">&lt;? declare(strict_types=1);
</code></pre>
<h2 id="包括一个-php-文件">包括一个 PHP 文件</h2>
<pre><code class="language-php">require 'app/Product.php'
</code></pre>
<h2 id="创建命名空间">创建命名空间</h2>
<pre><code class="language-php">namespace App;
</code></pre>
<h2 id="使用命名空间">使用命名空间</h2>
<pre><code class="language-php">use App\Product;
</code></pre>
<h2 id="小驼峰命名">小驼峰命名</h2>
<pre><code class="language-php">$firstName = 'Mike'

function updateProduct()
</code></pre>
<h2 id="大驼峰命名">大驼峰命名</h2>
<pre><code class="language-php">class ProductItem
</code></pre>
<h2 id="所有大写字母用下划线分隔">所有大写字母用下划线分隔</h2>
<pre><code class="language-php">const ACCESS_KEY = '123abc';
</code></pre>
<h1 id="输出-输入">输出 &amp; 输入</h1>
<h2 id="输出">输出</h2>
<pre><code class="language-php">echo 'Hello World';
</code></pre>
<h2 id="调式输出">调式输出</h2>
<pre><code class="language-php">var_dump($names);
print_r($products);
</code></pre>
<h2 id="从控制台输入">从控制台输入</h2>
<pre><code class="language-php">$name = readline('What is your name : ');
</code></pre>
<h1 id="变量声明">变量声明</h1>
<h2 id="字符串">字符串</h2>
<pre><code class="language-php">$name = 'Mike';
</code></pre>
<h2 id="布尔型">布尔型</h2>
<pre><code class="language-php">$isActive = true;
</code></pre>
<h2 id="整型">整型</h2>
<pre><code class="language-php">$number = 25;
</code></pre>
<h2 id="浮点型">浮点型</h2>
<pre><code class="language-php">$amount = 99.95;
</code></pre>
<h2 id="数组">数组</h2>
<pre><code class="language-php">$fruits = ['orange', 'apple', 'banana'];
</code></pre>
<h2 id="常量">常量</h2>
<pre><code class="language-php">const MAX_USERS = 50;

define('MAX_USERS', 50);
</code></pre>
<h2 id="赋值-引用-是通过-关键字">赋值 '引用' 是通过 &amp; 关键字</h2>
<pre><code class="language-php">$name_2 = &amp;$name_1;
</code></pre>
<h2 id="类型转换">类型转换</h2>
<pre><code class="language-php">$age = (int)readline('Your age: ');

echo 'Your age is' . (string)$age;
</code></pre>
<h2 id="获取变量类型">获取变量类型</h2>
<pre><code class="language-php">echo gettype($age); // int
</code></pre>
<h2 id="判断是否整形">判断是否整形</h2>
<pre><code class="language-php">echo is_int($age)
</code></pre>
<h2 id="判断是否浮点型">判断是否浮点型</h2>
<pre><code class="language-php">echo is_float($age)
</code></pre>
<h2 id="判断是否字符串">判断是否字符串</h2>
<pre><code class="language-php">echo is_string($age)
</code></pre>
<h1 id="字符串-2">字符串</h1>
<h2 id="单引号">单引号</h2>
<pre><code class="language-php">$name = 'Mike';
</code></pre>
<h2 id="双引号">双引号</h2>
<pre><code class="language-php">$name = &quot;Mike&quot;;
</code></pre>
<h2 id="双引号字符串能够使用转义字符-n-new-line-t-tab-backslash">双引号字符串能够使用转义字符 \n = new line  \t = tab  \ = backslash</h2>
<pre><code class="language-php">echo &quot;Hello Mike\nHello David&quot;;
</code></pre>
<h2 id="双引号字符串能够插入变量">双引号字符串能够插入变量</h2>
<pre><code class="language-php">echo &quot;Hello $name&quot;;
</code></pre>
<h2 id="字符串拼接">字符串拼接</h2>
<pre><code class="language-php">echo 'Hello ' . $name;
</code></pre>
<h2 id="字符串长度">字符串长度</h2>
<pre><code class="language-php">echo strlen($name);
</code></pre>
<h2 id="删除首部和尾部的空格">删除首部和尾部的空格</h2>
<pre><code class="language-php">echo trim($text);
</code></pre>
<h2 id="转换为小写">转换为小写</h2>
<pre><code class="language-php">echo strtolower($email);
</code></pre>
<h2 id="转换为大写">转换为大写</h2>
<pre><code class="language-php">echo strtoupper($email);
</code></pre>
<h2 id="将首字符转换为大写">将首字符转换为大写</h2>
<pre><code class="language-php">echo ucfirst($name);  // 'Mike' 
</code></pre>
<h2 id="替换-将-text-中的文本-a-替换成文本-b">替换 将 $text 中的文本 a 替换成文本 b</h2>
<pre><code class="language-php">echo str_replace('a', 'b', $text);
</code></pre>
<h2 id="字符串包含-php-8">字符串包含 (PHP 8)</h2>
<pre><code class="language-php">echo str_contains($name, 'ke')  # true
</code></pre>
<h2 id="查找-k-在字符串中第一次出现的位置">查找 &quot;k&quot; 在字符串中第一次出现的位置</h2>
<pre><code class="language-php">$pos = strpos($name, 'k');
</code></pre>
<h2 id="返回字符串的一部分-偏移量-长度">返回字符串的一部分 (偏移量 / 长度)</h2>
<pre><code class="language-php">echo substr($name, 0, $pos); # Mi
</code></pre>
<h1 id="数字">数字</h1>
<h2 id="快捷增加并赋值">快捷增加并赋值</h2>
<pre><code class="language-php">$value = 10;
$value++;
// or 
$value += 1;
</code></pre>
<h2 id="快捷减少并赋值">快捷减少并赋值</h2>
<pre><code class="language-php">$value = 10;
$value--;
// or 
$value -= 1;
</code></pre>
<h2 id="检查是否是数字">检查是否是数字</h2>
<pre><code class="language-php">echo is_numeric('59.99'); # true
</code></pre>
<h2 id="四舍五入">四舍五入</h2>
<pre><code class="language-php">echo round(0.80);  // returns 1
</code></pre>
<h2 id="精确地对数字进行四舍五入">精确地对数字进行四舍五入</h2>
<pre><code class="language-php">echo round(1.49356, 2));  // returns 1.49
</code></pre>
<h2 id="随机数">随机数</h2>
<pre><code class="language-php">echo(rand(10, 100)); # 89
</code></pre>
<h1 id="条件语句">条件语句</h1>
<h2 id="if-elseif-else">If / elseif / else</h2>
<pre><code class="language-php">if ($condition == 10) {
    echo 'condition 10'
} elseif  ($condition == 5) {
    echo 'condition 5'
} else {
    echo 'all other conditions'
}
</code></pre>
<h2 id="and-等于">And 等于 &amp;&amp;</h2>
<pre><code class="language-php">if ($condition === 10 &amp;&amp; $condition2 === 5) {
    echo '10 and 5'
}
</code></pre>
<h2 id="or-等于">Or 等于 ||</h2>
<pre><code class="language-php">if ($condition === 10 || $condition2 === 5) {
    echo '10 or 5'
}
</code></pre>
<h2 id="单行">单行</h2>
<pre><code class="language-php">if ($isActive) return true;
</code></pre>
<h2 id="检查-null-值">检查 null 值</h2>
<pre><code class="language-php">if (is_null($name)) {
    
}
</code></pre>
<h2 id="比较操作符">比较操作符</h2>
<pre><code class="language-php">== // 松散比较
=== // 严格比较
!= // 不等于
|| // 或
&amp;&amp; // 且
&gt; // 大于
&lt; // 小于
</code></pre>
<h2 id="三元运算-true-false">三元运算 (true : false)</h2>
<pre><code class="language-php">echo $isValid ? 'user valid' : 'user not valid';
</code></pre>
<h2 id="null-合并运算">null 合并运算</h2>
<pre><code class="language-php">echo $name ?? 'Mike';  //output 'Mike' if $name is null
</code></pre>
<h2 id="null-合并赋值">null 合并赋值</h2>
<pre><code class="language-php">$name ??= 'Mike';
</code></pre>
<h2 id="null-安全运算符php-8如果有一个为-null将返回-null">null 安全运算符（PHP 8）如果有一个？为 null，将返回 null</h2>
<pre><code class="language-php">echo $user?-&gt;profile?-&gt;activate();
</code></pre>
<h2 id="null-安全-null-合并-如果为-null-将返回-no-user-profile">null 安全 + null 合并 (如果为 null 将返回 『No user profile』)</h2>
<pre><code class="language-php">echo $user?-&gt;profile?-&gt;activate() ?? 'Not applicable';
</code></pre>
<h2 id="飞船符号-返回-1-0-1">飞船符号 返回 -1 0 1</h2>
<pre><code class="language-php">$names = ['Mike', 'Paul', 'John']
usort($names, function($a, $b) {
    return $a &lt;=&gt; $b;
}
// ['John', 'Mike', 'Paul']
</code></pre>
<h2 id="转换为布尔值时返回-false">转换为布尔值时返回 false</h2>
<pre><code class="language-php">false, 0, 0.0, null, unset, '0', '', []
</code></pre>
<h2 id="将同一变量与多个值进行比较">将同一变量与多个值进行比较</h2>
<pre><code class="language-php">switch ($color) {
    case 'red':
        echo 'The color is red';
         break;
    case 'yellow':
        echo 'The color is yellow';
        break;
    case 'red':
        echo 'The color is red';
        break;
    default:
        echo 'The color is unknown';
}
</code></pre>
<h2 id="match-表达式php-8">Match 表达式（PHP 8）</h2>
<pre><code class="language-php">$type = match($color) {
    'red' =&gt; 'danger',
    'yellow', 'orange' =&gt; 'warning',
    'green' =&gt; 'success',
    default =&gt; 'Unknown'
};
</code></pre>
<h2 id="检查变量是否声明">检查变量是否声明</h2>
<pre><code class="language-php">isset($color['red']);  # true
</code></pre>
<h1 id="循环和迭代">循环和迭代</h1>
<h2 id="for-循环">for 循环</h2>
<pre><code class="language-php">for ($i = 0; $i &lt; 20; $i++) {
    echo &quot;i value = &quot; . i;
}
</code></pre>
<h2 id="while-循环">while 循环</h2>
<pre><code class="language-php">$number = 1;
while ($number &lt; 10) {
    echo 'value : ' . $number ;
    $number += 1;
}
</code></pre>
<h2 id="do-while">do while</h2>
<pre><code class="language-php">$number = 1;
do {
    echo 'value : ' . $number ;
    $number += 1;
} while ($number &lt; 10);
</code></pre>
<h2 id="foreach-带有-break-continue-的示例">foreach 带有 break / continue 的示例</h2>
<pre><code class="language-php">$values = ['one', 'two', 'three'];
foreach ($values as $value) {
    if ($value === 'two') {
        break; // 退出循环
    } elseif ($value === 'three') {
        continue; // 下一个循环迭代
    }
}
</code></pre>
<h1 id="数组-2">数组</h1>
<h2 id="数组声明可以包含任何类型">数组声明可以包含任何类型</h2>
<pre><code class="language-php">$example = ['Mike', 50.2, true, ['10', '20'];
</code></pre>
<h2 id="数组声明">数组声明</h2>
<pre><code class="language-php">$names = ['Mike', 'Peter', 'Shawn', 'John'];
</code></pre>
<h2 id="直接访问特定元素">直接访问特定元素</h2>
<pre><code class="language-php">$name[1]
</code></pre>
<h2 id="如何访问数组中的数组元素">如何访问数组中的数组元素</h2>
<pre><code class="language-php">$example[3][1]
</code></pre>
<h2 id="将元素添加到数组">将元素添加到数组</h2>
<pre><code class="language-php">$names[] = 'Micheal';
</code></pre>
<h2 id="数组合并">数组合并</h2>
<pre><code class="language-php">$array3 = array_merge($array1, $array2);
</code></pre>
<h2 id="使用扩展运算符来进行数组合并">使用扩展运算符来进行数组合并</h2>
<pre><code class="language-php">$names = ['Mike', 'Peter', 'Paul'];
$people = ['John', ...$names]; // ['John', 'Mike', 'Peter', 'Paul']
</code></pre>
<h2 id="删除数组元素">删除数组元素</h2>
<pre><code class="language-php">unset($names['Peter']);
</code></pre>
<h2 id="数组转字符串">数组转字符串</h2>
<pre><code class="language-php">echo implode(', ', $names); // 输出 Mike, Shawn, John, Micheal
</code></pre>
<h2 id="字符串转数组">字符串转数组</h2>
<pre><code class="language-php">echo explode(',', $text); // ['Mike', 'Shawn', 'John']
</code></pre>
<h2 id="遍历数组元素">遍历数组元素</h2>
<pre><code class="language-php">foreach($names as $name) { 
   echo 'Hello ' . $name;
}
</code></pre>
<h2 id="数组中元素的个数">数组中元素的个数</h2>
<pre><code class="language-php">echo count($names);
</code></pre>
<h2 id="关联数组声明-key-value">关联数组声明 (key =&gt; value):</h2>
<pre><code class="language-php">$person = ['age' =&gt; 45, 'genre' =&gt; 'men'];
</code></pre>
<h2 id="添加到末尾-数组">添加到末尾. 数组:</h2>
<pre><code class="language-php">$person['name'] = 'Mike';
</code></pre>
<h2 id="循环数组-key-value">循环数组 key =&gt; value:</h2>
<pre><code class="language-php">foreach($names as $key =&gt; $value) { 
   echo $key . ' : ' . $value
}
</code></pre>
<h2 id="检查是否存在某个特定键">检查是否存在某个特定键</h2>
<pre><code class="language-php">echo array_key_exists('age', $person);
</code></pre>
<h2 id="返回键">返回键</h2>
<pre><code class="language-php">echo array_keys($person); // ['age', 'genre']
</code></pre>
<h2 id="返回值">返回值</h2>
<pre><code class="language-php">echo array_values($person) // [45, 'men']
</code></pre>
<h2 id="数组过滤器-返回过滤后的数组">数组过滤器 (返回过滤后的数组)</h2>
<pre><code class="language-php">$filteredPeople = array_filter($people, function ($person) {
    return $names-&gt;active;
})
</code></pre>
<h2 id="数组映射-返回变换后的数组">数组映射 (返回变换后的数组)</h2>
<pre><code class="language-php">$onlyNames = array_map(function($person) {
    return ['name' =&gt; $person-&gt;name];
}, $people)
</code></pre>
<h2 id="搜索关联数组">搜索关联数组</h2>
<pre><code class="language-php">$items = [
        ['id' =&gt; '100', 'name' =&gt; 'product 1'],
        ['id' =&gt; '200', 'name' =&gt; 'product 2'],
        ['id' =&gt; '300', 'name' =&gt; 'product 3'],
        ['id' =&gt; '400', 'name' =&gt; 'product 4'],
    ];
</code></pre>
<h2 id="在-name-列中搜索所有值">在 'name' 列中搜索所有值</h2>
<pre><code class="language-php">$found_key = array_search('product 3', array_column($items, 'name'));
</code></pre>
<h1 id="函数">函数</h1>
<h2 id="函数声明">函数声明</h2>
<pre><code class="language-php">function name($firstName, $lastName = 'defaultvalue') {
    return &quot;$firstName $lastName&quot;
}
</code></pre>
<h2 id="函数调用">函数调用</h2>
<pre><code class="language-php">name('Mike', 'Taylor');
</code></pre>
<h2 id="带命名参数的函数调用-php-8">带命名参数的函数调用 (PHP 8)</h2>
<pre><code class="language-php">name(firstName: 'Mike', lastName: 'Taylor'); // 排序能够改变
</code></pre>
<h2 id="函数可变数量参数">函数可变数量参数</h2>
<pre><code class="language-php">function name(...$params) {
    return $params[0] . “ “ . params[1];
}
</code></pre>
<h2 id="闭包函数">闭包函数</h2>
<pre><code class="language-php">Route::get('/', function () {
     return view('welcome');
});
</code></pre>
<h2 id="箭头函数">箭头函数</h2>
<pre><code class="language-php">Route::get('/', fn () =&gt; view('welcome');
</code></pre>
<h2 id="参数类型和返回类型">参数类型和返回类型</h2>
<pre><code class="language-php">function display(string $first, string $last) : string {
    return &quot;$first $last&quot;;
}
</code></pre>
<h2 id="类型或空值">类型或空值</h2>
<pre><code class="language-php">function display(?string $name) {
   
}
</code></pre>
<h1 id="文件">文件</h1>
<h2 id="获取当前目录">获取当前目录</h2>
<pre><code class="language-php">$current_dir = __DIR__;
</code></pre>
<h2 id="检查文件是否存在">检查文件是否存在</h2>
<pre><code class="language-php">if (file_exists('/posts/first.txt')) {
 
}
</code></pre>
<h2 id="读取文件内容到一个变量中">读取文件内容到一个变量中</h2>
<pre><code class="language-php">$post = file_get_contents($file);
</code></pre>
<h2 id="文件读取">文件读取</h2>
<pre><code class="language-php">$file = fopen(&quot;test.txt&quot;, &quot;r&quot;);
</code></pre>
<h2 id="输出行-直到-eof-结束">输出行, 直到 EOF 结束</h2>
<pre><code class="language-php">while(! feof($file)) {
  $line = fgets($file);
  echo $line. &quot;&lt;br&gt;&quot;;
}
fclose($file);
</code></pre>
<h2 id="文件写入">文件写入</h2>
<pre><code class="language-php">$file = fopen('export.csv', 'a');
$array = ['name' =&gt; 'Mike', 'age' =&gt; 45];
</code></pre>
<h2 id="将键名写为-csv-标题">将键名写为 CSV 标题</h2>
<pre><code class="language-php">fputcsv($file, array_keys($array[0]));
</code></pre>
<h2 id="写入行-格式为-csv">写入行 (格式为 csv)</h2>
<pre><code class="language-php">foreach ($array as $row) {
    fputcsv($file, $row); 
}
fclose($file);
</code></pre>
<h1 id="errors">Errors</h1>
<h2 id="抛出错误">抛出错误</h2>
<pre><code class="language-php">if (someCondition) {
    throw new Exception('Data format error');
}
</code></pre>
<h2 id="捕获错误">捕获错误</h2>
<pre><code class="language-php">try {
  $db-&gt;checkData($data);
} catch (Exception $e) {
    echo $e-&gt;getMessage();
}
</code></pre>
<pre><code class="language-php">// 如果try catch都有return，按照正常执行，然后执行finally的逻辑，再返回对应的try 或者catch里执行return
// 如果try catch finally都有return，执行完finally的逻辑后，会调用finally的return
try {
  $db-&gt;checkData($data);
} catch (Exception $e) {
    echo $e-&gt;getMessage();
} finally {

}
</code></pre>
<h1 id="oop">OOP</h1>
<h2 id="类声明">类声明</h2>
<pre><code class="language-php">class Person 
{
}
</code></pre>
<h2 id="对象实例">对象实例</h2>
<pre><code class="language-php">$person = new Person
</code></pre>
<h2 id="类属性和构造方法">类属性和构造方法</h2>
<pre><code class="language-php">class Person 
{
   protected $firstName;
   protected $lastName;
   public function __construct($firstName, $lastName) {
        $this-&gt;firstName = $firstName;
        $this-&gt;lastName = $lastName
   }
}
</code></pre>
<h2 id="构造器属性提升php-8">构造器属性提升（PHP 8）</h2>
<pre><code class="language-php">class Person 
{
    public function __construct(protected $firstName, protected $lastName) 
    {

    }
}
</code></pre>
<h2 id="获取和设置">获取和设置</h2>
<pre><code class="language-php">class Person
{
    private $name;

    public function setName($name){
        if(!is_string($name)){
            throw new Exception('$name must be a string!');
        }
        $this-&gt;name = $name;
    }

    public function getName(){
        return $this-&gt;name;
    }
}
</code></pre>
<h2 id="静态构造方法">静态构造方法</h2>
<pre><code class="language-php">public static function create(...$params) {
    return new self($params)
}
$person = Person::create(‘Mike’, ‘Taylor’);
</code></pre>
<h2 id="静态方法">静态方法</h2>
<pre><code class="language-php">class greeting {
  public static function welcome() {
    echo &quot;Hello World!&quot;;
  }
}
</code></pre>
<h2 id="调用静态方法">调用静态方法</h2>
<pre><code class="language-php">greeting::welcome();
</code></pre>
<h2 id="静态方法调用">静态方法调用</h2>
<pre><code class="language-php">class greeting {
  public static function welcome() {
    echo &quot;Hello World!&quot;;
  }

  public function __construct() {
    static::welcome();
  }
}
new greeting();
</code></pre>
<h2 id="静态常量">静态常量</h2>
<pre><code class="language-php">class Connection
{
  const MAX_USER = 100;
}
echo Connection::MAX_USER # 100
</code></pre>
<h2 id="类继承">类继承</h2>
<pre><code class="language-php">class Customer extends Person
{
    public function name()
    {
        parent::name();
        echo 'Override method';  
    }
}
</code></pre>
<h2 id="self-关键字引用当前类不会像静态那样通过继承后期绑定修改">self 关键字引用当前类（不会像静态那样通过继承后期绑定修改）</h2>
<pre><code class="language-php">self::welcome();
</code></pre>
<h2 id="接口">接口</h2>
<pre><code class="language-php">interface Animal {
  public function makeSound();
}

class Cat implements Animal {
  public function makeSound() {
    echo &quot;Meow&quot;;
  }
}
$animal = new Cat();
$animal-&gt;makeSound();
</code></pre>
<h2 id="trait-mix-in">Trait (mix-in)</h2>
<pre><code class="language-php">trait HelloWorld {
    public function sayHello() {
        echo 'Hello World!';
    }
}
class Greetings {
    use HelloWorld;
}
$object = new Greetings();
$object-&gt;sayHello();
</code></pre>
<blockquote>
<p>https://learnku.com/php/t/62217</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go 操作MySQL]]></title>
        <id>http://weakcc.github.io/post/go-cao-zuo-mysql/</id>
        <link href="http://weakcc.github.io/post/go-cao-zuo-mysql/">
        </link>
        <updated>2021-11-03T08:44:38.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="下载依赖">下载依赖</h2>
<pre><code class="language-go">go get -u github.com/go-sql-driver/mysql
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="下载依赖">下载依赖</h2>
<pre><code class="language-go">go get -u github.com/go-sql-driver/mysql
</code></pre>
<!-- more -->
<h2 id="连接">连接</h2>
<pre><code class="language-go">package main

import (
	&quot;database/sql&quot;
	&quot;fmt&quot;

	_ &quot;github.com/go-sql-driver/mysql&quot;
)

var db *sql.DB

func initDB() (err error) {
	// 用户名:密码@tcp(ip:端口)/数据库名
	dsn := &quot;root:123456@tcp(127.0.0.1:3306)/go_test&quot;
	// Open 不会校验账号密码是否正确
	db, err = sql.Open(&quot;mysql&quot;, dsn)
	if err != nil {
		return
	}
	// 尝试与数据库建立连接（校验dsn是否正确）
	err = db.Ping()
	if err != nil {
		return
    }
	return nil
}

func main()  {
	err:= initDB()
	if err!= nil {
		fmt.Println(err)
		return
	}
	fmt.Println(&quot;连接成功！&quot;)
}
</code></pre>
<blockquote>
<p>其中 <code>sql.DB</code> 是表示连接的数据库对象（结构体实例），它保存了连接数据库相关的所有信息。它内部维护着一个具有零到多个底层连接的连接池，它可以安全地被多个 goroutine 同时使用</p>
</blockquote>
<h2 id="curd">CURD</h2>
<h3 id="插入">插入</h3>
<pre><code class="language-go">func insertRow()  {
	sqlStr := &quot;insert into user (name, age) values (?, ?)&quot;
	result, err := db.Exec(sqlStr, &quot;小晓&quot;, 11)
	if err != nil {
		fmt.Println(err)
		return
	}
	id, err := result.LastInsertId()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(id)
}
</code></pre>
<h3 id="查询">查询</h3>
<h4 id="单行查询">单行查询</h4>
<pre><code class="language-go">func queryRow()  {
	sqlStr := &quot;select id, name, age from user where id = ?&quot;
    var u user
    // 确保 QueryRow 之后调用 Scan 方法，否则持有的数据库链接不会被释放
	err := db.QueryRow(sqlStr, 1).Scan(&amp;u.id, &amp;u.name, &amp;u.age)
	if err != nil {
		fmt.Println(&quot;错误：&quot;, err)
		return
	}
	fmt.Println(u)
}
</code></pre>
<h4 id="多行查询">多行查询</h4>
<pre><code class="language-go">func queryRows()  {
	sqlStr := &quot;select id, name, age from user where id &gt;= ?&quot;
	rows, err := db.Query(sqlStr, 1)
	if err != nil {
		fmt.Println(err)
	}
	// 关闭 rows 释放持有的数据库链接
	defer rows.Close()

	// 循环读取结果集中的数据
	for rows.Next() {
		var u user
		err := rows.Scan(&amp;u.id, &amp;u.name, &amp;u.age)
		if err != nil {
			fmt.Println(&quot;错误：&quot;, err)
			return
		}
		fmt.Println(u)
	}
}
</code></pre>
<h3 id="更新">更新</h3>
<pre><code class="language-go">func updateRow()  {
	sqlStr := &quot;update user set age = ? where id &gt; ?&quot;
	result, err := db.Exec(sqlStr, 12, 2)
	if err != nil {
		fmt.Println(err)
		return
	}
	n, err := result.RowsAffected() // 操作受影响的行数
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(n)
}
</code></pre>
<h3 id="删除数据">删除数据</h3>
<pre><code class="language-go">func deleteRow()  {
	sqlStr := &quot;delete from user where id = ?&quot;
	result, err := db.Exec(sqlStr, 4)
	if err != nil {
		fmt.Println(err)
		return
	}
	n, err := result.RowsAffected()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(n)
}
</code></pre>
<h2 id="预处理">预处理</h2>
<p>防止 <code>SQL 注入</code></p>
<h3 id="查询-2">查询</h3>
<pre><code class="language-go">func prepareQuery()  {
	sqlStr := &quot;select id, name, age from user where id &gt;= ?&quot;
	stmt, err := db.Prepare(sqlStr)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer stmt.Close()
	rows, err := stmt.Query(1)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer rows.Close()
	for rows.Next() {
		var u user
		err := rows.Scan(&amp;u.id, &amp;u.name, &amp;u.age)
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Println(u)
	}
}
</code></pre>
<h3 id="插入更新删除类似">插入，更新，删除类似</h3>
<pre><code class="language-go">func prepareInsert() {
	sqlStr := &quot;insert into user(name, age) values (?, ?)&quot;
	stmt, err := db.Prepare(sqlStr)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer stmt.Close()
	_, err = stmt.Exec(&quot;小爱&quot;, 5)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(&quot;success&quot;)
}
</code></pre>
<h2 id="事务">事务</h2>
<pre><code class="language-go">func transactionDemo()  {
	tx, err := db.Begin() // 开启事务
	if err != nil {
		if tx != nil {
			tx.Rollback() // 回滚
		}
		fmt.Println(err)
		return
	}
	sqlStr1 := &quot;update user set age = 18 where id = ?&quot;
	result1, err := tx.Exec(sqlStr1, 2)
	if err != nil {
		tx.Rollback()
		fmt.Println(err)
		return
	}
	n1, err := result1.RowsAffected()
	if err != nil {
		tx.Rollback()
		fmt.Println(err)
		return
	}
	sqlStr2 := &quot;update user set age = 18 where id = ?&quot;
	result2, err := tx.Exec(sqlStr2, 1)
	if err != nil {
		tx.Rollback()
		fmt.Println(err)
		return
	}
	n2, err := result2.RowsAffected()
	if err != nil {
		tx.Rollback()
		fmt.Println(err)
		return
	}
	fmt.Println(n1, n2)
	if 1 == n1 &amp;&amp; 1 == n2 {
		tx.Commit() // 提交
	} else {
		tx.Rollback()
	}
}
</code></pre>
]]></content>
    </entry>
</feed>