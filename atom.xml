<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://weakcc.github.io</id>
    <title>腰盐醋</title>
    <updated>2021-11-01T07:57:46.128Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://weakcc.github.io"/>
    <link rel="self" href="http://weakcc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://weakcc.github.io/images/avatar.png</logo>
    <icon>http://weakcc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 腰盐醋</rights>
    <entry>
        <title type="html"><![CDATA[PHP 随机字符串]]></title>
        <id>http://weakcc.github.io/post/php-sui-ji-zi-fu-chuan/</id>
        <link href="http://weakcc.github.io/post/php-sui-ji-zi-fu-chuan/">
        </link>
        <updated>2021-11-01T06:12:51.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-php">function getRandChar($length = 6)
{
    $charStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz';

    $str = '';
    $max = strlen($charStr);
    for ($i = 0; $i &lt; $length; $i++) {
        $str .= $charStr[rand(0, $max - 1)];
    }

    return $str;
}

var_dump(getRandChar(5));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP 无限极分类]]></title>
        <id>http://weakcc.github.io/post/php-wu-xian-ji-fen-lei/</id>
        <link href="http://weakcc.github.io/post/php-wu-xian-ji-fen-lei/">
        </link>
        <updated>2021-11-01T06:10:47.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="递归">递归</h1>
<pre><code class="language-php">&lt;?php

$array = [
    ['id' =&gt; 1, 'parent_id' =&gt; 0, 'name' =&gt; '河北省'],
    ['id' =&gt; 2, 'parent_id' =&gt; 0, 'name' =&gt; '北京市'],
    ['id' =&gt; 3, 'parent_id' =&gt; 1, 'name' =&gt; '邯郸市'],
    ['id' =&gt; 4, 'parent_id' =&gt; 2, 'name' =&gt; '朝阳区'],
    ['id' =&gt; 5, 'parent_id' =&gt; 2, 'name' =&gt; '通州区'],
    ['id' =&gt; 6, 'parent_id' =&gt; 4, 'name' =&gt; '望京'],
    ['id' =&gt; 7, 'parent_id' =&gt; 4, 'name' =&gt; '酒仙桥'],
    ['id' =&gt; 8, 'parent_id' =&gt; 3, 'name' =&gt; '永年区'],
    ['id' =&gt; 9, 'parent_id' =&gt; 1, 'name' =&gt; '武安市'],
];

function getTree($array, $parent_id = 0, $level = 0)
{
    static $list = [];
    foreach ($array as $key =&gt; $value) {
        if ($value['parent_id'] == $parent_id) {
            $value['level'] = $level;
            $list[] = $value;
            unset($array[$key]);
            getTree($array, $value['id'], $level + 1);
        }
    }
    return $list;
}

$list = getTree($array);

foreach ($list as $value) {
    echo str_repeat('--', $value['level']) . $value['name'] . PHP_EOL;
}
/**
河北省
--邯郸市
----永年区
--武安市
北京市
--朝阳区
----望京
----酒仙桥
--通州区
 **/
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="递归">递归</h1>
<pre><code class="language-php">&lt;?php

$array = [
    ['id' =&gt; 1, 'parent_id' =&gt; 0, 'name' =&gt; '河北省'],
    ['id' =&gt; 2, 'parent_id' =&gt; 0, 'name' =&gt; '北京市'],
    ['id' =&gt; 3, 'parent_id' =&gt; 1, 'name' =&gt; '邯郸市'],
    ['id' =&gt; 4, 'parent_id' =&gt; 2, 'name' =&gt; '朝阳区'],
    ['id' =&gt; 5, 'parent_id' =&gt; 2, 'name' =&gt; '通州区'],
    ['id' =&gt; 6, 'parent_id' =&gt; 4, 'name' =&gt; '望京'],
    ['id' =&gt; 7, 'parent_id' =&gt; 4, 'name' =&gt; '酒仙桥'],
    ['id' =&gt; 8, 'parent_id' =&gt; 3, 'name' =&gt; '永年区'],
    ['id' =&gt; 9, 'parent_id' =&gt; 1, 'name' =&gt; '武安市'],
];

function getTree($array, $parent_id = 0, $level = 0)
{
    static $list = [];
    foreach ($array as $key =&gt; $value) {
        if ($value['parent_id'] == $parent_id) {
            $value['level'] = $level;
            $list[] = $value;
            unset($array[$key]);
            getTree($array, $value['id'], $level + 1);
        }
    }
    return $list;
}

$list = getTree($array);

foreach ($list as $value) {
    echo str_repeat('--', $value['level']) . $value['name'] . PHP_EOL;
}
/**
河北省
--邯郸市
----永年区
--武安市
北京市
--朝阳区
----望京
----酒仙桥
--通州区
 **/
</code></pre>
<!-- more -->
<h1 id="引用">引用</h1>
<pre><code class="language-php">&lt;?php

$array = [
    1 =&gt; ['id' =&gt; 1, 'parent_id' =&gt; 0, 'name' =&gt; '河北省'],
    2 =&gt; ['id' =&gt; 2, 'parent_id' =&gt; 0, 'name' =&gt; '北京市'],
    3 =&gt; ['id' =&gt; 3, 'parent_id' =&gt; 1, 'name' =&gt; '邯郸市'],
    4 =&gt; ['id' =&gt; 4, 'parent_id' =&gt; 2, 'name' =&gt; '朝阳区'],
    5 =&gt; ['id' =&gt; 5, 'parent_id' =&gt; 2, 'name' =&gt; '通州区'],
    6 =&gt; ['id' =&gt; 6, 'parent_id' =&gt; 4, 'name' =&gt; '望京'],
    7 =&gt; ['id' =&gt; 7, 'parent_id' =&gt; 4, 'name' =&gt; '酒仙桥'],
    8 =&gt; ['id' =&gt; 8, 'parent_id' =&gt; 3, 'name' =&gt; '永年区'],
    9 =&gt; ['id' =&gt; 9, 'parent_id' =&gt; 1, 'name' =&gt; '武安市'],
];

function getTree($list)
{
    $tree = [];
    foreach ($list as &amp;$item) {
        $parent_id = $item['parent_id'];

        if (isset($list[$parent_id]) &amp;&amp; !empty($list[$parent_id])) {
            $list[$parent_id]['list'][] = &amp;$item;
        } else {
            $tree[] = &amp;$item;
        }
    }
    unset($item);

    return $tree;
}

$list = getTree($array);
print_r($list);
</code></pre>
<h1 id="laravel-orm-模型">Laravel ORM 模型</h1>
<table>
<thead>
<tr>
<th style="text-align:center">字段名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id</td>
<td style="text-align:center">自增长 ID</td>
<td style="text-align:center">unsigned big int</td>
</tr>
<tr>
<td style="text-align:center">name</td>
<td style="text-align:center">类目名称</td>
<td style="text-align:center">varchar</td>
</tr>
<tr>
<td style="text-align:center">parent_id</td>
<td style="text-align:center">父类目 ID</td>
<td style="text-align:center">unsigned big int, null</td>
</tr>
<tr>
<td style="text-align:center">is_directory</td>
<td style="text-align:center">是否拥有子类目</td>
<td style="text-align:center">tinyint</td>
</tr>
<tr>
<td style="text-align:center">level</td>
<td style="text-align:center">当前类目层级</td>
<td style="text-align:center">unsigned int</td>
</tr>
<tr>
<td style="text-align:center">path</td>
<td style="text-align:center">该类目所有父类目 id</td>
<td style="text-align:center">varchar</td>
</tr>
</tbody>
</table>
<pre><code class="language-php">&lt;?php
namespace App\Services;

use App\Models\Category;

class CategoryService
{
    // 这是一个递归方法
    // $parentId 参数代表要获取子类目的父类目 ID，null 代表获取所有根类目
    // $allCategories 参数代表数据库中所有的类目，如果是 null 代表需要从数据库中查询
    public function getCategoryTree($parentId = null, $allCategories = null)
    {
        if (is_null($allCategories)) {
            // 从数据库中一次性取出所有类目
            $allCategories = Category::all();
        }

        return $allCategories
            // 从所有类目中挑选出父类目 ID 为 $parentId 的类目
            -&gt;where('parent_id', $parentId)
            // 遍历这些类目，并用返回值构建一个新的集合
            -&gt;map(function (Category $category) use ($allCategories) {
                $data = ['id' =&gt; $category-&gt;id, 'name' =&gt; $category-&gt;name];
                // 如果当前类目不是父类目，则直接返回
                if (!$category-&gt;is_directory) {
                    return $data;
                }
                // 否则递归调用本方法，将返回值放入 children 字段中
                $data['children'] = $this-&gt;getCategoryTree($category-&gt;id, $allCategories);

                return $data;
            });
    }
}

// 调用
app(App\Services\CategoryService::class)-&gt;getCategoryTree()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Selenium 从入门到放弃]]></title>
        <id>http://weakcc.github.io/post/selenium-cong-ru-men-dao-fang-qi/</id>
        <link href="http://weakcc.github.io/post/selenium-cong-ru-men-dao-fang-qi/">
        </link>
        <updated>2021-10-30T08:14:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装浏览器驱动">安装浏览器驱动</h1>
<p><a href="https://chromedriver.storage.googleapis.com/index.html">Chrome 浏览器驱动</a><br>
<a href="https://github.com/mozilla/geckodriver/releases">Firefox 浏览器驱动</a><br>
<a href="http://selenium-release.storage.googleapis.com/index.html">IE 浏览器驱动</a><br>
<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">Edge 浏览器驱动</a><br>
<a href="https://phantomjs.org/">PhantomJS 浏览器驱动</a><br>
<a href="https://github.com/operasoftware/operachromiumdriver/releases">Opera 浏览器驱动</a></p>
<p>测试</p>
<pre><code class="language-python">from selenium import webdriver

# Chrome浏览器
driver = webdriver.Chrome()
driver.get('https://www.baidu.com/')
</code></pre>
<h1 id="定位页面元素">定位页面元素</h1>
<h2 id="id-定位">id 定位</h2>
<pre><code class="language-html">&lt;input id=&quot;toolbar-search-input&quot; autocomplete=&quot;off&quot; type=&quot;text&quot; value=&quot;&quot; placeholder=&quot;C++难在哪里？&quot;&gt;
</code></pre>
<pre><code class="language-python">driver.find_element_by_id('toolbar-search-input')
</code></pre>
<h2 id="name-定位">name 定位</h2>
<pre><code class="language-html">&lt;meta name=&quot;keywords&quot; content=&quot;CSDN博客,CSDN学院,CSDN论坛,CSDN直播&quot;&gt;
</code></pre>
<pre><code class="language-python">driver.find_element_by_name(&quot;keywords&quot;)
</code></pre>
<h2 id="class-定位">class 定位</h2>
<pre><code class="language-html">&lt;div class=&quot;toolbar-search-container&quot;&gt;
</code></pre>
<pre><code class="language-python">driver.find_element_by_class_name(&quot;toolbar-search-container&quot;)
</code></pre>
<h2 id="tag-定位">tag 定位</h2>
<pre><code class="language-html">&lt;div class=&quot;toolbar-search-container&quot;&gt;
</code></pre>
<pre><code class="language-python">driver.find_element_by_tag_name(&quot;div&quot;)
</code></pre>
<h2 id="xpath-定位">xpath 定位</h2>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;...&lt;head/&gt;
  &lt;body&gt;
    &lt;div id=&quot;csdn-toolbar&quot;&gt;
      &lt;div class=&quot;toolbar-inside&quot;&gt;
        &lt;div class=&quot;toolbar-container&quot;&gt;
          &lt;div class=&quot;toolbar-container-left&quot;&gt;...&lt;/div&gt;
          &lt;div class=&quot;toolbar-container-middle&quot;&gt;
            &lt;div class=&quot;toolbar-search onlySearch&quot;&gt;
			&lt;div class=&quot;toolbar-search-container&quot;&gt;
				&lt;input id=&quot;toolbar-search-input&quot; autocomplete=&quot;off&quot; type=&quot;text&quot; value=&quot;&quot; placeholder=&quot;C++难在哪里？&quot;&gt;
</code></pre>
<pre><code class="language-python"># 绝对路径（层级关系）定位
driver.find_element_by_xpath(
	&quot;/html/body/div/div/div/div[2]/div/div/input[1]&quot;)

# 利用元素属性定位
driver.find_element_by_xpath(
	&quot;//*[@id='toolbar-search-input']&quot;))

# 层级+元素属性定位
driver.find_element_by_xpath(
	&quot;//div[@id='csdn-toolbar']/div/div/div[2]/div/div/input[1]&quot;)

# 逻辑运算符定位
driver.find_element_by_xpath(
	&quot;//*[@id='toolbar-search-input' and @autocomplete='off']&quot;)
</code></pre>
<h2 id="css-定位">css 定位</h2>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.class</td>
<td style="text-align:center">.toolbar-search-container</td>
<td style="text-align:center">选择 class = 'toolbar-search-container' 的所有元素</td>
</tr>
<tr>
<td style="text-align:center">#id</td>
<td style="text-align:center">#toolbar-search-input</td>
<td style="text-align:center">选择 id = 'toolbar-search-input' 的元素</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">选择所有元素</td>
</tr>
<tr>
<td style="text-align:center">element</td>
<td style="text-align:center">input</td>
<td style="text-align:center">选择所有 &lt;input&gt; 元素</td>
</tr>
<tr>
<td style="text-align:center">element&gt;element</td>
<td style="text-align:center">div&gt;input</td>
<td style="text-align:center">选择父元素为 &lt;div&gt; 的所有 &lt;input&gt; 元素</td>
</tr>
<tr>
<td style="text-align:center">element+element</td>
<td style="text-align:center">div+input</td>
<td style="text-align:center">选择同一级中在 &lt;div&gt; 之后的所有 &lt;input&gt; 元素</td>
</tr>
<tr>
<td style="text-align:center">[attribute=value]</td>
<td style="text-align:center">type='text'</td>
<td style="text-align:center">选择 type = 'text' 的所有元素</td>
</tr>
</tbody>
</table>
<pre><code class="language-python">driver.find_element_by_css_selector('#toolbar-search-input')
driver.find_element_by_css_selector('html&gt;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&gt;input')
</code></pre>
<h2 id="link-定位">link 定位</h2>
<p><code>link</code> 专门用来定位文本链接，假如要定位下面这一标签。</p>
<pre><code class="language-html">&lt;div class=&quot;practice-box&quot; data-v-04f46969=&quot;&quot;&gt;加入！每日一练&lt;/div&gt;
</code></pre>
<pre><code class="language-python">driver.find_element_by_link_text(&quot;加入！每日一练&quot;)
</code></pre>
<h2 id="partial_link-定位">partial_link 定位</h2>
<p><code>partial_link</code> 翻译过来就是“部分链接”，对于有些文本很长，这时候就可以只指定部分文本即可定位，同样使用刚才的例子。</p>
<pre><code class="language-html">&lt;div class=&quot;practice-box&quot; data-v-04f46969=&quot;&quot;&gt;加入！每日一练&lt;/div&gt;
</code></pre>
<pre><code class="language-python">driver.find_element_by_partial_link_text(&quot;加入&quot;)
</code></pre>
<h1 id="浏览器控制">浏览器控制</h1>
<h2 id="修改浏览器窗口大小">修改浏览器窗口大小</h2>
<p><code>webdriver</code> 提供 <code>set_window_size()</code> 方法来修改浏览器窗口的大小。</p>
<pre><code class="language-python">from selenium import webdriver

# Chrome浏览器
driver = webdriver.Chrome()
driver.get('https://www.csdn.net/')
# 设置浏览器浏览器的宽高为：600x800
driver.set_window_size(600, 800)
</code></pre>
<p>也可以使用 <code>maximize_window()</code> 方法可以实现浏览器全屏显示<br>
from selenium import webdriver</p>
<pre><code class="language-python"># Chrome浏览器
driver = webdriver.Chrome()
driver.get('https://www.csdn.net/')
# 设置浏览器浏览器的宽高为全屏
driver.maximize_window()
</code></pre>
<h2 id="浏览器前进后退">浏览器前进&amp;后退</h2>
<p><code>webdriver</code> 提供 <code>back</code> 和 <code>forward</code> 方法来实现页面的后退与前进</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()

# 访问CSDN首页
driver.get('https://www.csdn.net/')
sleep(2)
#访问CSDN个人主页
driver.get('https://blog.csdn.net/qq_43965708')
sleep(2)
#返回（后退）到CSDN首页
driver.back()
sleep(2)
#前进到个人主页
driver.forward()
</code></pre>
<h2 id="新的标签页打开">新的标签页打开</h2>
<p>如果想的话也可以在新的标签页中打开新的链接，但需要更改一下代码，执行 js 语句来打开新的标签。</p>
<pre><code class="language-python"># 在原页面打开
driver.get('https://blog.csdn.net/qq_43965708')

# 新标签中打开
js = &quot;window.open('https://blog.csdn.net/qq_43965708')&quot;
driver.execute_script(js)
</code></pre>
<h2 id="浏览器刷新">浏览器刷新</h2>
<p>可以使用 <code>refresh()</code> 来刷新当前页面。</p>
<pre><code class="language-python"># 刷新页面
driver.refresh()
</code></pre>
<h2 id="浏览器窗口切换">浏览器窗口切换</h2>
<p>在很多时候我们都需要用到窗口切换，比如：当我们点击注册按钮时，它一般会打开一个新的标签页，但实际上代码并没有切换到最新页面中，这时你如果要定位注册页面的标签就会发现定位不到，这时就需要将实际窗口切换到最新打开的那个窗口。我们先获取当前各个窗口的句柄，这些信息的保存顺序是按照时间来的，最新打开的窗口放在数组的末尾，这时我们就可以定位到最新打开的那个窗口了。</p>
<pre><code class="language-python"># 获取打开的多个窗口句柄
windows = driver.window_handles
# 切换到当前最新打开的窗口
driver.switch_to.window(windows[-1])
</code></pre>
<h2 id="常见操作">常见操作</h2>
<p>webdriver中的常见操作有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">send_keys()</td>
<td style="text-align:center">模拟输入指定内容</td>
</tr>
<tr>
<td style="text-align:center">clear()</td>
<td style="text-align:center">清除文本内容</td>
</tr>
<tr>
<td style="text-align:center">is_displayed()</td>
<td style="text-align:center">判断该元素是否可见</td>
</tr>
<tr>
<td style="text-align:center">get_attribute()</td>
<td style="text-align:center">获取标签属性值</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:center">返回元素的尺寸</td>
</tr>
<tr>
<td style="text-align:center">text</td>
<td style="text-align:center">返回元素文本</td>
</tr>
</tbody>
</table>
<p>🌰</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()

driver.get('https://www.csdn.net/')
sleep(2)
# 定位搜索输入框
text_label = driver.find_element_by_xpath('//*[@id=&quot;toolbar-search-input&quot;]')

# 在搜索框中输入 Dream丶Killer
text_label.send_keys('Dream丶Killer')

sleep(2)
# 清除搜索框中的内容
text_label.clear()

# 输出搜索框元素是否可见
print(text_label.is_displayed())
# 输出placeholder的值
print(text_label.get_attribute('placeholder'))

# 定位搜索按钮
button = driver.find_element_by_xpath('//*[@id=&quot;toolbar-search-button&quot;]/span')
# 输出按钮的大小
print(button.size)
# 输出按钮上的文本
print(button.text)

'''输出内容
True
python面试100问
{'height': 32, 'width': 28}
搜索
'''
</code></pre>
<h1 id="鼠标控制">鼠标控制</h1>
<p>在webdriver 中，鼠标操作都封装在ActionChains类中，常见方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">click()</td>
<td style="text-align:center">单击左键</td>
</tr>
<tr>
<td style="text-align:center">context_click()</td>
<td style="text-align:center">单击右键</td>
</tr>
<tr>
<td style="text-align:center">double_click()</td>
<td style="text-align:center">双击</td>
</tr>
<tr>
<td style="text-align:center">drag_and_drop()</td>
<td style="text-align:center">拖动</td>
</tr>
<tr>
<td style="text-align:center">move_to_element()</td>
<td style="text-align:center">鼠标悬停</td>
</tr>
<tr>
<td style="text-align:center">perform()</td>
<td style="text-align:center">执行所有ActionChains中存储的动作</td>
</tr>
</tbody>
</table>
<h2 id="单击左键">单击左键</h2>
<p>模拟完成单击鼠标左键的操作，一般点击进入子页面等会用到，左键不需要用到 <code>ActionChains</code> 。</p>
<pre><code class="language-python"># 定位搜索按钮
button = driver.find_element_by_xpath('//*[@id=&quot;toolbar-search-button&quot;]/span')
# 执行单击操作
button.click()
</code></pre>
<h2 id="单击右键">单击右键</h2>
<p>鼠标右击的操作与左击有很大不同，需要使用 <code>ActionChains</code> 。</p>
<pre><code class="language-python">from selenium.webdriver.common.action_chains import ActionChains

# 定位搜索按钮
button = driver.find_element_by_xpath('//*[@id=&quot;toolbar-search-button&quot;]/span')
# 右键搜索按钮
ActionChains(driver).context_click(button).perform()
</code></pre>
<h2 id="双击">双击</h2>
<p>模拟鼠标双击操作</p>
<pre><code class="language-python"># 定位搜索按钮
button = driver.find_element_by_xpath('//*[@id=&quot;toolbar-search-button&quot;]/span')
# 执行双击动作
ActionChains(driver).double_click(button).perform()
</code></pre>
<h2 id="拖动">拖动</h2>
<p>模拟鼠标拖动操作，该操作有两个必要参数</p>
<ul>
<li><strong>source</strong>：鼠标拖动的元素</li>
<li><strong>target</strong>：鼠标拖至并释放的目标元素</li>
</ul>
<pre><code class="language-python"># 定位要拖动的元素
source = driver.find_element_by_xpath('xxx')
# 定位目标元素
target = driver.find_element_by_xpath('xxx')
# 执行拖动动作
ActionChains(driver).drag_and_drop(source, target).perform()
</code></pre>
<h2 id="鼠标悬停">鼠标悬停</h2>
<p>模拟悬停的作用一般是为了显示隐藏的下拉框。</p>
<pre><code class="language-python"># 定位收藏栏
collect  = driver.find_element_by_xpath('//*[@id=&quot;csdn-toolbar&quot;]/div/div/div[3]/div/div[3]/a')

# 悬停至收藏标签处
ActionChains(driver).move_to_element(collect).perform()
</code></pre>
<h1 id="键盘控制">键盘控制</h1>
<p><code>webdriver</code> 中 <code>Keys</code> 类几乎提供了键盘上的所有按键方法，我们可以使用 <code>send_keys + Keys</code> 实现输出键盘上的组合按键如 “<strong>Ctrl + C</strong>”、“<strong>Ctrl + V</strong>” 等。</p>
<pre><code class="language-python">from selenium.webdriver.common.keys import Keys

# 定位输入框并输入文本
driver.find_element_by_id('xxx').send_keys('Dream丶killer')

# 模拟回车键进行跳转（输入内容后） 
driver.find_element_by_id('xxx').send_keys(Keys.ENTER)

# 使用 Backspace 来删除一个字符
driver.find_element_by_id('xxx').send_keys(Keys.BACK_SPACE)

# Ctrl + A 全选输入框中内容
driver.find_element_by_id('xxx').send_keys(Keys.CONTROL, 'a')

# Ctrl + C 复制输入框中内容
driver.find_element_by_id('xxx').send_keys(Keys.CONTROL, 'c')

# Ctrl + V 粘贴输入框中内容
driver.find_element_by_id('xxx').send_keys(Keys.CONTROL, 'v')
</code></pre>
<p>其他常见键盘操作：</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Keys.F1</td>
<td style="text-align:center">F1键</td>
</tr>
<tr>
<td style="text-align:center">Keys.SPACE</td>
<td style="text-align:center">空格</td>
</tr>
<tr>
<td style="text-align:center">Keys.TAB</td>
<td style="text-align:center">Tab键</td>
</tr>
<tr>
<td style="text-align:center">Keys.ESCAPE</td>
<td style="text-align:center">ESC键</td>
</tr>
<tr>
<td style="text-align:center">Keys.ALT</td>
<td style="text-align:center">Alt键</td>
</tr>
<tr>
<td style="text-align:center">Keys.SHIFT</td>
<td style="text-align:center">Shift键</td>
</tr>
<tr>
<td style="text-align:center">Keys.ARROW_DOWN</td>
<td style="text-align:center">向下箭头</td>
</tr>
<tr>
<td style="text-align:center">Keys.ARROW_LEFT</td>
<td style="text-align:center">向左箭头</td>
</tr>
<tr>
<td style="text-align:center">Keys.ARROW_RIGHT</td>
<td style="text-align:center">向右箭头</td>
</tr>
<tr>
<td style="text-align:center">Keys.ARROW_UP</td>
<td style="text-align:center">向上箭头</td>
</tr>
</tbody>
</table>
<h1 id="设置元素等待">设置元素等待</h1>
<p>很多页面都使用 <code>ajax</code> 技术，页面的元素不是同时被加载出来的，为了防止定位这些尚在加载的元素报错，可以设置元素等来增加脚本的稳定性。<code>webdriver</code> 中的等待分为 <strong>显式等待</strong> 和 <strong>隐式等待</strong>。</p>
<h2 id="显式等待">显式等待</h2>
<p>显式等待：设置一个超时时间，每个一段时间就去检测一次该元素是否存在，如果存在则执行后续内容，如果超过最大时间（超时时间）则抛出超时异常（<code>TimeoutException</code>）。显示等待需要使用 <code>WebDriverWait</code>，同时配合 <code>until</code> 或 <code>not until</code> 。下面详细讲解一下。</p>
<p><code>WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)</code></p>
<ul>
<li><code>driver</code>：浏览器驱动</li>
<li><code>timeout</code>：超时时间，单位秒</li>
<li><code>poll_frequency</code>：每次检测的间隔时间，默认为0.5秒</li>
<li><code>ignored_exceptions</code>：指定忽略的异常，如果在调用 <code>until</code> 或 <code>until_not</code> 的过程中抛出指定忽略的异常，则不中断代码，默认忽略的只有 <code>NoSuchElementException</code>。</li>
</ul>
<p><code>until(method, message=' ') until_not(method, message=' ')</code></p>
<ul>
<li><code>method</code>：指定预期条件的判断方法，在等待期间，每隔一段时间调用该方法，判断元素是否存在，直到元素出现。<code>until_not</code> 正好相反，当元素消失或指定条件不成立，则继续执行后续代码</li>
<li><code>message</code>: 如果超时，抛出 <code>TimeoutException</code>，并显示 <code>message</code> 中的内容</li>
</ul>
<p><code>method</code> 中的预期条件判断方法是由 <code>expected_conditions</code> 提供，下面列举常用方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">title_is('百度一下')</td>
<td style="text-align:center">判断当前页面的 title 是否等于预期</td>
</tr>
<tr>
<td style="text-align:center">title_contains('百度')</td>
<td style="text-align:center">判断当前页面的 title 是否包含预期字符串</td>
</tr>
<tr>
<td style="text-align:center">presence_of_element_located(locator)</td>
<td style="text-align:center">presence_of_element_located(locator)</td>
</tr>
<tr>
<td style="text-align:center">visibility_of_element_located(locator)</td>
<td style="text-align:center">判断元素是否可见，可见代表元素非隐藏，并且元素的宽和高都不等于0</td>
</tr>
<tr>
<td style="text-align:center">visibility_of(element)</td>
<td style="text-align:center">跟上一个方法作用相同，但传入参数为 element</td>
</tr>
<tr>
<td style="text-align:center">text_to_be_present_in_element(locator , '百度')</td>
<td style="text-align:center">判断元素中的 text 是否包含了预期的字符串</td>
</tr>
<tr>
<td style="text-align:center">text_to_be_present_in_element_value(locator , '某值')</td>
<td style="text-align:center">判断元素中的 value 属性是否包含了预期的字符串</td>
</tr>
<tr>
<td style="text-align:center">frame_to_be_available_and_switch_to_it(locator)</td>
<td style="text-align:center">判断该 frame 是否可以 switch 进去，True 则 switch 进去，反之 False</td>
</tr>
<tr>
<td style="text-align:center">invisibility_of_element_located(locator)</td>
<td style="text-align:center">判断元素中是否不存在于 dom 树或不可见</td>
</tr>
<tr>
<td style="text-align:center">element_to_be_clickable(locator)</td>
<td style="text-align:center">判断元素中是否可见并且是可点击的</td>
</tr>
<tr>
<td style="text-align:center">staleness_of(element)</td>
<td style="text-align:center">等待元素从 dom 树中移除</td>
</tr>
<tr>
<td style="text-align:center">element_to_be_selected(element)</td>
<td style="text-align:center">判断元素是否被选中,一般用在下拉列表</td>
</tr>
<tr>
<td style="text-align:center">element_selection_state_to_be(element, True)</td>
<td style="text-align:center">判断元素的选中状态是否符合预期，参数 element，第二个参数为 True/False</td>
</tr>
<tr>
<td style="text-align:center">element_located_selection_state_to_be(locator, True)</td>
<td style="text-align:center">跟上一个方法作用相同，但传入参数为 locator</td>
</tr>
<tr>
<td style="text-align:center">alert_is_present()</td>
<td style="text-align:center">判断页面上是否存在 alert</td>
</tr>
</tbody>
</table>
<p>🌰</p>
<h3 id="普通定位">普通定位</h3>
<pre><code class="language-python">from selenium.webdriver.common.by import By
from selenium import webdriver

driver = webdriver.Chrome()
locator = (By.ID, 'kw')
element = driver.find_element_by_id('kw')
</code></pre>
<h3 id="显示定位">显示定位</h3>
<pre><code class="language-python">from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By

driver = webdriver.Chrome()
element = WebDriverWait(driver, 5, 0.5).until(
            EC.presence_of_element_located((By.ID, 'kw')),
                                           message='超时啦!')
</code></pre>
<h2 id="隐式等待">隐式等待</h2>
<p>隐式等待也是指定一个超时时间，如果超出这个时间指定元素还没有被加载出来，就会抛出 <code>NoSuchElementException</code> 异常。 除了抛出的异常不同外，还有一点，隐式等待是全局性的，即运行过程中，如果元素可以定位到，它不会影响代码运行，但如果定位不到，则它会以轮询的方式不断地访问元素直到元素被找到，若超过指定时间，则抛出异常。</p>
<p>使用 <code>implicitly_wait()</code> 来实现隐式等待，使用难度相对于显式等待要简单很多。 示例：打开个人主页，设置一个隐式等待时间 5s，通过 <code>id</code> 定位一个不存在的元素，最后打印 抛出的异常 与 运行时间。</p>
<p>🌰</p>
<pre><code class="language-python">from selenium import webdriver
from time import time

driver = webdriver.Chrome()
driver.get('https://blog.csdn.net/qq_43965708')

start = time()
driver.implicitly_wait(5)
try:
    driver.find_element_by_id('kw')
except Exception as e:
    print(e)
    print(f'耗时：{time()-start}')
</code></pre>
<blockquote>
<p>代码运行到 driver.find_element_by_id('kw') 这句之后触发隐式等待，在轮询检查 5s 后仍然没有定位到元素，抛出异常。</p>
</blockquote>
<h2 id="强制等待">强制等待</h2>
<p>使用 <code>time.sleep()</code> 强制等待，设置固定的休眠时间，对于代码的运行效率会有影响。以上面的例子作为参照，将 隐式等待 改为 强制等待。</p>
<pre><code class="language-python">from selenium import webdriver
from time import time, sleep

driver = webdriver.Chrome()
driver.get('https://blog.csdn.net/qq_43965708')

start = time()
sleep(5)
try:
    driver.find_element_by_id('kw')
except Exception as e:
    print(e)
    print(f'耗时：{time()-start}')
</code></pre>
<blockquote>
<p>值得一提的是，对于定位不到元素的时候，从耗时方面隐式等待和强制等待没什么区别。但如果元素经过 2s 后被加载出来，这时隐式等待就会继续执行下面的代码，但 sleep还要继续等待 3s。</p>
</blockquote>
<h1 id="定位一组元素">定位一组元素</h1>
<p>上篇讲述了定位一个元素的 8 种方法，定位一组元素使用的方法只需要将 <code>element</code> 改为 <code>elements</code> 即可，它的使用场景一般是为了批量操作元素。</p>
<ul>
<li><code>find_elements_by_id()</code></li>
<li><code>find_elements_by_name()</code></li>
<li><code>find_elements_by_class_name()</code></li>
<li><code>find_elements_by_tag_name()</code></li>
<li><code>find_elements_by_xpath()</code></li>
<li><code>find_elements_by_css_selector()</code></li>
<li><code>find_elements_by_link_text()</code></li>
<li><code>find_elements_by_partial_link_text()</code></li>
</ul>
<p>🌰</p>
<pre><code class="language-python">from selenium import webdriver

# 设置无头浏览器
option = webdriver.ChromeOptions()
option.add_argument('--headless')

driver = webdriver.Chrome(options=option)
driver.get('https://blog.csdn.net/')

p_list = driver.find_elements_by_xpath(&quot;//p[@class='name']&quot;)
name = [p.text for p in p_list]
print(name)
'''
['花生', '编程', '卓']
'''
</code></pre>
<h1 id="切换操作">切换操作</h1>
<h2 id="窗口切换">窗口切换</h2>
<p>在 <code>selenium</code> 操作页面的时候，可能会因为点击某个链接而跳转到一个新的页面（打开了一个新标签页），这时候 <code>selenium</code> 实际还是处于上一个页面的，需要我们进行切换才能够定位最新页面上的元素。</p>
<p>窗口切换需要使用 <code>switch_to.windows()</code> 方法。</p>
<p>🌰</p>
<pre><code class="language-python">from selenium import webdriver

handles = []
driver = webdriver.Chrome()
driver.get('https://blog.csdn.net/')
# 设置隐式等待
driver.implicitly_wait(3)
# 获取当前窗口的句柄
handles.append(driver.current_window_handle)
# 点击 python，进入分类页面
driver.find_element_by_xpath('//*[@id=&quot;mainContent&quot;]/aside/div[1]/div').click()
# 获取当前窗口的句柄
handles.append(driver.current_window_handle)

print(handles)
# 获取当前所有窗口的句柄
print(driver.window_handles)
'''
['CDwindow-D032106A36A4D596E67B6A8D9CC7DE6B', 'CDwindow-D032106A36A4D596E67B6A8D9CC7DE6B']
['CDwindow-D032106A36A4D596E67B6A8D9CC7DE6B', 'CDwindow-DC9A05D1F67FE0AF0CEC441EB9FBD316']
'''
</code></pre>
<p>可以看到第一个列表 <code>handle</code> 是相同的，说明 <code>selenium</code> 实际操作的还是 CSDN首页 ，并未切换到新页面。 下面使用 <code>switch_to.windows()</code> 进行切换。</p>
<pre><code class="language-python">from selenium import webdriver

handles = []
driver = webdriver.Chrome()
driver.get('https://blog.csdn.net/')
# 设置隐式等待
driver.implicitly_wait(3)
# 获取当前窗口的句柄
handles.append(driver.current_window_handle)
# 点击 python，进入分类页面
driver.find_element_by_xpath('//*[@id=&quot;mainContent&quot;]/aside/div[1]/div').click()
# 切换窗口
driver.switch_to.window(driver.window_handles[-1])
# 获取当前窗口的句柄
handles.append(driver.current_window_handle)

print(handles)
print(driver.window_handles)
'''
['CDwindow-9329E73908B77E0AA52FE5EEB1AA3147', 'CDwindow-327C23C8937C00202FF541E843C37101']
['CDwindow-9329E73908B77E0AA52FE5EEB1AA3147', 'CDwindow-327C23C8937C00202FF541E843C37101']
'''
</code></pre>
<p>上面代码在点击跳转后，使用 <code>switch_to</code> 切换窗口，<code>window_handles</code> 返回的 <code>handle</code> 列表是按照页面出现时间进行排序的，最新打开的页面肯定是最后一个。</p>
<blockquote>
<p>那如果打开的窗口有多个，如何跳转到之前打开的窗口，如果确实有这个需求，那么打开窗口是就需要记录每一个窗口的 <code>key</code>(别名) 与 <code>value</code>(<code>handle</code>)，保存到字典中，后续根据 <code>key</code> 来取 <code>handle</code> 。</p>
</blockquote>
<h2 id="表单切换">表单切换</h2>
<p>很多页面也会用带 <code>frame/iframe</code> 表单嵌套，对于这种内嵌的页面 <code>selenium</code> 是无法直接定位的，需要使用 <code>switch_to.frame()</code> 方法将当前操作的对象切换成 <code>frame/iframe</code> 内嵌的页面。</p>
<p><code>switch_to.frame()</code> 默认可以用的 <code>id</code> 或 <code>name</code> 属性直接定位，但如果 <code>iframe</code> 没有 <code>id</code> 或 <code>name</code> ，这时就需要使用 <code>xpath</code> 进行定位。</p>
<p>🌰</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        div p {
            color: #red;
            animation: change 2s infinite;
        }
        @keyframes change {
            from {
                color: red;
            }
            to {
                color: blue;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div&gt;
        &lt;p&gt;简单的栗子&lt;/p&gt;
    &lt;/div&gt;
    &lt;iframe src=&quot;https://blog.csdn.net/qq_43965708&quot; width=&quot;400&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt;
&lt;!--     &lt;iframe id=&quot;CSDN_info&quot; name=&quot;lizi&quot; src=&quot;https://blog.csdn.net/qq_43965708&quot; width=&quot;400&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt; --&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1635753252992.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">from selenium import webdriver
from pathlib import Path


driver = webdriver.Chrome()
# 读取本地html文件
driver.get('file:///' + str(Path(Path.cwd(), 'iframe测试.html')))

# 1.通过id定位
driver.switch_to.frame('CSDN_info')
# 2.通过name定位
# driver.switch_to.frame('lizi')
# 3.通过xpath定位
# iframe_label = driver.find_element_by_xpath('/html/body/iframe')
# driver.switch_to.frame(iframe_label)

driver.find_element_by_xpath('//*[@id=&quot;csdn-toolbar&quot;]/div/div/div[1]/div/a/img').click()
</code></pre>
<blockquote>
<p>https://juejin.cn/post/7022925905395875847</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 safari 浏览器导出 Excel 文件后缀会加一个 .html]]></title>
        <id>http://weakcc.github.io/post/shi-yong-safari-liu-lan-qi-dao-chu-excel-wen-jian-hou-zhui-hui-jia-yi-ge-html/</id>
        <link href="http://weakcc.github.io/post/shi-yong-safari-liu-lan-qi-dao-chu-excel-wen-jian-hou-zhui-hui-jia-yi-ge-html/">
        </link>
        <updated>2021-10-28T02:45:52.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://weakcc.github.io/post-images/1635389216714.png" alt="" loading="lazy"></figure>
<p>解决办法</p>
<pre><code class="language-php">header(&quot;Pragma: public&quot;);  
header(&quot;Expires: 0&quot;);  
header(&quot;Cache-Control:must-revalidate, post-check=0, pre-check=0&quot;);  
header(&quot;Content-Type:application/force-download&quot;);  
header(&quot;Content-Type:application/vnd.ms-excel&quot;);  
header(&quot;Content-Type:application/octet-stream&quot;);  
header(&quot;Content-Type:application/download&quot;);;  
header('Content-Disposition:attachment;filename=&quot;'.$filename.'.xls&quot;');
header(&quot;Content-Transfer-Encoding:binary&quot;);
$objWriter-&gt;save('php://output');
exit;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP 动态语言静态化]]></title>
        <id>http://weakcc.github.io/post/php-dong-tai-yu-yan-jing-tai-hua/</id>
        <link href="http://weakcc.github.io/post/php-dong-tai-yu-yan-jing-tai-hua/">
        </link>
        <updated>2021-10-26T02:26:40.000Z</updated>
        <summary type="html"><![CDATA[<p>新建文件 <code>demo.php</code><br>
正常输出</p>
<pre><code class="language-php">&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
</code></pre>
<p>开启输出控制缓冲 <code>ob_start</code></p>
<pre><code class="language-php">&lt;?php
    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲
    var_dump($content);
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>新建文件 <code>demo.php</code><br>
正常输出</p>
<pre><code class="language-php">&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
</code></pre>
<p>开启输出控制缓冲 <code>ob_start</code></p>
<pre><code class="language-php">&lt;?php
    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲
    var_dump($content);
</code></pre>
<!--more-->
<p>把缓存写入文件</p>
<pre><code class="language-php">&lt;?php
    $cache_name = md5(__FILE__) . '.html';

    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲

    $handle = fopen($cache_name, 'w');
    fwrite($handle, $content);
    fclose($handle);
</code></pre>
<pre><code>var_dump($cache_name);
</code></pre>
<p>运行后生成临时文件 <code>xxxx.html</code> 缓存</p>
<p>关键缓存判断</p>
<pre><code class="language-php">&lt;?php
    $cache_name = md5(__FILE__) . '.html';
    $cache_lifetime = 3600;
    // filectime() 函数返回指定文件的上次修改时间
    if (file_exists($cache_name)
        &amp;&amp; filectime(__FILE__) &lt;= filectime($cache_name)
        &amp;&amp; filectime($cache_name) + $cache_lifetime &gt; time()) {
        // 缓存文件存在
        // 当前文件是否有修改（文件的修改时间小于缓存文件的修改问）
        // 缓存文件是否已经过期
        include $cache_name;
        exit;
    }

    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲

    $handle = fopen($cache_name, 'w');
    fwrite($handle, $content);
    fclose($handle);
</code></pre>
<p>根据不同的用户 <code>id</code> 做不同的缓存</p>
<pre><code class="language-php">&lt;?php
    $id = intval($_GET['id']);
    if (empty($id)) {
        $id = '';
    }

    $cache_name = md5(__FILE__) . '-' . $id .'.html';
    $cache_lifetime = 3600;
    // filectime() 函数返回指定文件的上次修改时间
    if (file_exists($cache_name)
        &amp;&amp; filectime(__FILE__) &lt;= filectime($cache_name)
        &amp;&amp; filectime($cache_name) + $cache_lifetime &gt; time()) {
        // 缓存文件存在
        // 当前文件是否有修改（文件的修改时间小于缓存文件的修改问）
        // 缓存文件是否已经过期
        include $cache_name;
        exit;
    }

    ob_start(); // 打开输出控制缓冲
?&gt;
&lt;p&gt;在 demo.php 文件下输出 html 文本. &lt;?php echo $id?&gt;&lt;/p&gt;
&lt;?php
    $content = ob_get_contents(); // 返回输出缓冲区的内容
    ob_end_flush(); // 冲刷出（送出）输出缓冲区内容并关闭缓冲

    $handle = fopen($cache_name, 'w');
    fwrite($handle, $content);
    fclose($handle);
</code></pre>
]]></content>
    </entry>
</feed>